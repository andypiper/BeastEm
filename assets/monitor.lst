0001   0000             ;
0002   0000             ; Monitor using CP/M BIOS
0003   0000             ;
0004   0000             ;
0005   0000             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0006   0000             ;
0007   0000             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0008   0000             ;
0009   0000             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0010   0000             ; of this software and associated documentation files (the "Software"), to deal
0011   0000             ; in the Software without restriction, including without limitation the rights
0012   0000             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0013   0000             ; copies of the Software, and to permit persons to whom the Software is
0014   0000             ; furnished to do so, subject to the following conditions:
0015   0000             ; 
0016   0000             ; The above copyright notice and this permission notice shall be included in all
0017   0000             ; copies or substantial portions of the Software.
0018   0000             ; 
0019   0000             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0020   0000             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0021   0000             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0022   0000             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0023   0000             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0024   0000             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0025   0000             ; SOFTWARE.
0026   0000             ;
0027   0000                                 .MODULE  main
0028   0000             
0029   0000             MONITOR_START       .EQU   0DF00h
0030   0000             
0031   DF00                                 .ORG   MONITOR_START
0032   DF00 CD B3 F3                        CALL   configure_hardware
0033   DF03             
0034   DF03 3E 01                           LD      A, 1
0035   DF05 32 03 00                        LD      (iobyte), A
0036   DF08             
0037   DF08 3E 24                           LD      A, DRIVE_B_PAGE
0038   DF0A 32 38 FF                        LD      (drive_b_mem_page), A
0039   DF0D             
0040   DF0D 21 40 E9                        LD      HL, timer_int
0041   DF10 22 FE FD                        LD      (0FDFEh), HL
0042   DF13             
0043   DF13 3E 01                           LD      A, 1
0044   DF15 32 04 FF                        LD      (timer), A
0045   DF18 3E 03                           LD      A, 3
0046   DF1A CD 31 E9                        CALL    detect_int
0047   DF1D             
0048   DF1D 79                              LD      A, C
0049   DF1E B0                              OR      B
0050   DF1F 20 13                           JR      NZ, _clock_detected
0051   DF21             
0052   DF21 CD 9B F3    _no_clock           CALL    m_print_inline
0053   DF24 4E 6F 20 69                     .DB     "No interrupt", 0
0053   DF28 6E 74 65 72 
0053   DF2C 72 75 70 74 
0053   DF30 00 
0054   DF31 C3 31 DF                        JP      $
0055   DF34             
0056   DF34 3E 07       _clock_detected     LD      A, 7
0057   DF36 CD 31 E9                        CALL    detect_int
0058   DF39 79                              LD      A, C
0059   DF3A B0                              OR      B 
0060   DF3B 28 E4                           JR      Z, _no_clock
0061   DF3D             
0062   DF3D                                 ; At this point BC ~= 13 * (clock * 100)
0063   DF3D                                 ; Divide by 13, round lowest digit up/down
0064   DF3D             
0065   DF3D C5                              PUSH    BC
0066   DF3E E1                              POP     HL
0067   DF3F 0E 0D                           LD      C, 13
0068   DF41 CD 4D E9                        CALL    divide_hl_c
0069   DF44             
0070   DF44 E5                              PUSH    HL
0071   DF45 D1                              POP     DE
0072   DF46 CD 5A E9                        CALL    de_to_bcd
0073   DF49             
0074   DF49 3A 92 E9                        LD      A, (bcd_scratch)         ; Units
0075   DF4C FE 06                           CP      6
0076   DF4E 38 11                           JR      C, _display_speed
0077   DF50             
0078   DF50 2A 93 E9                        LD      HL, (bcd_scratch+1)
0079   DF53 06 04                           LD      B,  4
0080   DF55             
0081   DF55 7E          _increment_bcd      LD      A, (HL)
0082   DF56 3C                              INC     A
0083   DF57 77                              LD      (HL), A
0084   DF58 FE 0A                           CP      10
0085   DF5A 38 05                           JR      C, _display_speed        ; No carry here
0086   DF5C AF                              XOR     A
0087   DF5D 77                              LD      (HL), A
0088   DF5E 23                              INC     HL
0089   DF5F 10 F4                           DJNZ    _increment_bcd
0090   DF61             
0091   DF61 3A 95 E9    _display_speed      LD      A, (bcd_scratch+3)
0092   DF64 A7                              AND     A
0093   DF65 28 05                           JR      Z, _skip_leading
0094   DF67 C6 30                           ADD     A, '0'
0095   DF69 32 93 DF                        LD      (_speed_value),A
0096   DF6C 3A 94 E9    _skip_leading       LD       A, (bcd_scratch+2)
0097   DF6F C6 30                           ADD     A, '0'
0098   DF71 32 94 DF                        LD      (_speed_value+1), A
0099   DF74 3A 93 E9                        LD      A, (bcd_scratch+1)
0100   DF77 C6 30                           ADD     A, '0'
0101   DF79 32 96 DF                        LD      (_speed_value+3), A
0102   DF7C             
0103   DF7C 01 60 00                        LD      BC, 60h
0104   DF7F CD 1A E9                        CALL    pause_for_ticks
0105   DF82             
0106   DF82 CD 9B F3                        CALL    m_print_inline
0107   DF85 0A 0D 43 6C                     .DB     NEWLINE, CARRIAGE_RETURN, "Clock speed "
0107   DF89 6F 63 6B 20 
0107   DF8D 73 70 65 65 
0107   DF91 64 20 
0108   DF93 20 30 2C 30 _speed_value        .DB     " 0,0Mhz", 0
0108   DF97 4D 68 7A 00 
0109   DF9B             
0110   DF9B 21 7E F4                        LD      HL, interrupt_handler
0111   DF9E 22 FE FD                        LD      (0FDFEh), HL
0112   DFA1             
0113   DFA1 01 60 00                        LD      BC, 60h
0114   DFA4 CD 1A E9                        CALL    pause_for_ticks
0115   DFA7             
0116   DFA7 CD 9B F3                        CALL    m_print_inline
0117   DFAA 0A 0D 4D 69                     .DB     NEWLINE, CARRIAGE_RETURN, "MicroBeast Monitor 1.2", 0
0117   DFAE 63 72 6F 42 
0117   DFB2 65 61 73 74 
0117   DFB6 20 4D 6F 6E 
0117   DFBA 69 74 6F 72 
0117   DFBE 20 31 2E 32 
0117   DFC2 00 
0118   DFC3             
0119   DFC3 01 60 00                        LD      BC, 60h
0120   DFC6 CD 1A E9                        CALL    pause_for_ticks
0121   DFC9             
0122   DFC9 0E 0A                           LD      C, NEWLINE
0123   DFCB CD 00 F0                        CALL    bios_conout
0124   DFCE             
0125   DFCE CD 97 E9    _monitor_menu       CALL    rtc_display_time
0126   DFD1             
0127   DFD1 01 40 00                        LD      BC, 040h
0128   DFD4 CD 1A E9                        CALL    pause_for_ticks
0129   DFD7             
0130   DFD7 CD 71 EF    _monitor_read       CALL    bios_conist
0131   DFDA A7                              AND     A
0132   DFDB 28 F1                           JR      Z, _monitor_menu
0133   DFDD             
0134   DFDD CD 9A EF                        CALL    bios_conin
0135   DFE0             
0136   DFE0 21 07 E0                        LD      HL, main_menu
0137   DFE3 CD 4B E8                        CALL    start_menu
0138   DFE6 18 E6                           JR      _monitor_menu
0139   DFE8             
0140   DFE8             
0141   DFE8 CD 9B F3    boot_cpm            CALL    m_print_inline
0142   DFEB 0A 0D 46 6F                     .DB     NEWLINE, CARRIAGE_RETURN, "Format RAM disk", 0
0142   DFEF 72 6D 61 74 
0142   DFF3 20 52 41 4D 
0142   DFF7 20 64 69 73 
0142   DFFB 6B 00 
0143   DFFD             
0144   DFFD CD 7C E7                        CALL    format_memdisk
0145   E000             
0146   E000 21 F1 EE    boot_without_format LD      HL, bios_boot
0147   E003 E5                              PUSH    HL
0148   E004 C3 31 EF                        JP      load_ccp
0149   E007             
0150   E007             
0151   E007 53 65 6C 65 main_menu           .DB     "Select action", 0
0151   E00B 63 74 20 61 
0151   E00F 63 74 69 6F 
0151   E013 6E 00 
0152   E015             
0153   E015 E8 DF                           .DW     boot_cpm
0154   E017 4C 61 75 6E                     .DB     "Launch CP/M", 0
0154   E01B 63 68 20 43 
0154   E01F 50 2F 4D 00 
0155   E023             
0156   E023 81 E5                           .DW     memory_view
0157   E025 4D 65 6D 6F                     .DB     "Memory Editor", 0
0157   E029 72 79 20 45 
0157   E02D 64 69 74 6F 
0157   E031 72 00 
0158   E033             
0159   E033 BB E1                           .DW     ymodem_loader
0160   E035 59 2D 4D 6F                     .DB     "Y-Modem Transfer", 0
0160   E039 64 65 6D 20 
0160   E03D 54 72 61 6E 
0160   E041 73 66 65 72 
0160   E045 00 
0161   E046             
0162   E046 5E E0                           .DW     set_date
0163   E048 53 65 74 20                     .DB     "Set Date", 0
0163   E04C 44 61 74 65 
0163   E050 00 
0164   E051             
0165   E051 25 E1                           .DW     set_time
0166   E053 53 65 74 20                     .DB     "Set Time", 0
0166   E057 54 69 6D 65 
0166   E05B 00 
0167   E05C 00 00                           .DW     0
0168   E05E             
0169   E05E             
0170   E05E                                 .INCLUDE monitor_dates.asm
0001+  E05E             ;
0002+  E05E             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0003+  E05E             ;
0004+  E05E             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0005+  E05E             ;
0006+  E05E             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0007+  E05E             ; of this software and associated documentation files (the "Software"), to deal
0008+  E05E             ; in the Software without restriction, including without limitation the rights
0009+  E05E             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0010+  E05E             ; copies of the Software, and to permit persons to whom the Software is
0011+  E05E             ; furnished to do so, subject to the following conditions:
0012+  E05E             ; 
0013+  E05E             ; The above copyright notice and this permission notice shall be included in all
0014+  E05E             ; copies or substantial portions of the Software.
0015+  E05E             ; 
0016+  E05E             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0017+  E05E             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0018+  E05E             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0019+  E05E             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0020+  E05E             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0021+  E05E             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0022+  E05E             ; SOFTWARE.
0023+  E05E             ;
0024+  E05E             
0025+  E05E 3A 2D FF    set_date            LD      A, (cursor_row)
0026+  E061 C6 1F                           ADD     A, 31
0027+  E063 32 7E E0                        LD      (_set_date_row), A
0028+  E066 32 91 E0                        LD      (_set_week_row), A
0029+  E069 CD 9B F3                        CALL    m_print_inline
0030+  E06C 0D 44 61 74                     .DB     CARRIAGE_RETURN, "Date YY/MM/DD", ESCAPE_CHAR, "K", ESCAPE_CHAR, "Y",
0030+  E070 65 20 59 59 
0030+  E074 2F 4D 4D 2F 
0030+  E078 44 44 1B 4B 
0030+  E07C 1B 59 
0031+  E07E 00          _set_date_row       .DB     0
0032+  E07F 25 00                           .DB     31+6, 0
0033+  E081 21 6C E1                        LD      HL, date_limits
0034+  E084 CD 7A E1                        CALL    get_date_time
0035+  E087             
0036+  E087 3E 01                           LD      A, 1
0037+  E089 32 72 E1    _select_loop        LD      (day_of_week), A
0038+  E08C             
0039+  E08C CD 9B F3                        CALL    m_print_inline
0040+  E08F 1B 59                           .DB     ESCAPE_CHAR, "Y", 
0041+  E091 00          _set_week_row       .DB     0
0042+  E092 2F 00                           .DB     31+16, 0
0043+  E094             
0044+  E094 3A 72 E1                        LD      A, (day_of_week)
0045+  E097 47                              LD      B, A
0046+  E098 21 30 EA                        LD      HL, weekdays
0047+  E09B 10 0A       _week_loop          DJNZ    _next_week
0048+  E09D             
0049+  E09D 7E          _print_week         LD      A, (HL)
0050+  E09E 23                              INC     HL
0051+  E09F A7                              AND     A
0052+  E0A0 28 0C                           JR      Z, _select_week
0053+  E0A2 CD A8 F3                        CALL    m_print_a_safe
0054+  E0A5 18 F6                           JR      _print_week
0055+  E0A7             
0056+  E0A7 7E          _next_week          LD      A, (HL)
0057+  E0A8 23                              INC     HL
0058+  E0A9 A7                              AND     A
0059+  E0AA 20 FB                           JR      NZ, _next_week
0060+  E0AC 18 ED                           JR      _week_loop
0061+  E0AE             
0062+  E0AE CD 71 EF    _select_week        CALL    bios_conist
0063+  E0B1 A7                              AND     A
0064+  E0B2 28 FA                           JR      Z, _select_week
0065+  E0B4 CD 9A EF                        CALL    bios_conin
0066+  E0B7 FE 80                           CP      KEY_UP
0067+  E0B9 20 0A                           JR      NZ, _test_down
0068+  E0BB 3A 72 E1                        LD      A, (day_of_week)
0069+  E0BE FE 07                           CP      7
0070+  E0C0 28 EC                           JR      Z, _select_week
0071+  E0C2 3C                              INC     A
0072+  E0C3 18 C4                           JR      _select_loop
0073+  E0C5 FE 81       _test_down          CP      KEY_DOWN
0074+  E0C7 20 0A                           JR      NZ, _test_enter 
0075+  E0C9 3A 72 E1                        LD      A, (day_of_week)
0076+  E0CC FE 01                           CP      1
0077+  E0CE 28 DE                           JR      Z, _select_week
0078+  E0D0 3D                              DEC     A
0079+  E0D1 18 B6                           JR      _select_loop
0080+  E0D3 FE 0D       _test_enter         CP      KEY_ENTER
0081+  E0D5 20 D7                           JR      NZ, _select_week
0082+  E0D7             
0083+  E0D7 F3                              DI
0084+  E0D8 26 6F                           LD      H, RTC_ADDRESS      
0085+  E0DA 2E 03                           LD      L, RTC_REG_WKDAY
0086+  E0DC CD FE F8                        CALL    i2c_write_to
0087+  E0DF D2 0E E1                        JP      NC, _clock_error
0088+  E0E2             
0089+  E0E2 21 72 E1                        LD      HL, day_of_week
0090+  E0E5 7E                              LD      A, (HL)
0091+  E0E6 23                              INC     HL
0092+  E0E7             
0093+  E0E7 F6 08                           OR      RTC_WEEKDAY_RUNNING
0094+  E0E9 CD 12 F9                        CALL    i2c_write
0095+  E0EC D2 0E E1                        JP      NC, _clock_error
0096+  E0EF             
0097+  E0EF 46          _write_date_loop    LD      B, (HL)
0098+  E0F0 23                              INC     HL
0099+  E0F1             
0100+  E0F1 7E                              LD      A, (HL)
0101+  E0F2 23                              INC     HL
0102+  E0F3 CB 27                           SLA     A
0103+  E0F5 CB 27                           SLA     A
0104+  E0F7 CB 27                           SLA     A
0105+  E0F9 CB 27                           SLA     A
0106+  E0FB             
0107+  E0FB B0                              OR      B
0108+  E0FC FE FF                           CP      0ffh
0109+  E0FE CA 09 E1                        JP      Z, _start_clock
0110+  E101 CD 12 F9                        CALL    i2c_write
0111+  E104 D2 0E E1                        JP      NC, _clock_error
0112+  E107 18 E6                           JR      _write_date_loop
0113+  E109             
0114+  E109 CD D4 F8    _start_clock        CALL    i2c_stop
0115+  E10C FB                              EI
0116+  E10D C9                              RET
0117+  E10E             
0118+  E10E CD D4 F8    _clock_error        CALL    i2c_stop
0119+  E111 FB                              EI
0120+  E112 CD 9B F3                        CALL    m_print_inline
0121+  E115 0D 52 54 43                     .DB     CARRIAGE_RETURN, "RTC Error", ESCAPE_CHAR, "K", 0
0121+  E119 20 45 72 72 
0121+  E11D 6F 72 1B 4B 
0121+  E121 00 
0122+  E122 C3 9A EF                        JP      bios_conin
0123+  E125             
0124+  E125 3A 2D FF    set_time            LD      A, (cursor_row)
0125+  E128 C6 1F                           ADD     A, 31
0126+  E12A 32 42 E1                        LD      (_set_time_row), A
0127+  E12D CD 9B F3                        CALL    m_print_inline
0128+  E130 0D 54 69 6D                     .DB     CARRIAGE_RETURN, "Time HH/mm/ss", ESCAPE_CHAR, "K", ESCAPE_CHAR, "Y",
0128+  E134 65 20 48 48 
0128+  E138 2F 6D 6D 2F 
0128+  E13C 73 73 1B 4B 
0128+  E140 1B 59 
0129+  E142 00          _set_time_row       .DB     0
0130+  E143 25 00                           .DB     31+6, 0
0131+  E145 21 66 E1                        LD      HL, time_limits
0132+  E148 CD 7A E1                        CALL    get_date_time
0133+  E14B             
0134+  E14B 3A 74 E1                        LD      A, (digit_values+1)
0135+  E14E F6 08                           OR      08h
0136+  E150 32 74 E1                        LD      (digit_values+1), A
0137+  E153 CD 9A EF                        CALL    bios_conin
0138+  E156             
0139+  E156 F3                              DI
0140+  E157 26 6F                           LD      H, RTC_ADDRESS      
0141+  E159 2E 00                           LD      L, RTC_REG_SEC
0142+  E15B CD FE F8                        CALL    i2c_write_to
0143+  E15E D2 0E E1                        JP      NC, _clock_error
0144+  E161             
0145+  E161 21 73 E1                        LD      HL, digit_values
0146+  E164 18 89                           JR      _write_date_loop
0147+  E166                                 
0148+  E166 09 05 09 05 time_limits         .DB     9,5,9,5,3,2
0148+  E16A 03 02 
0149+  E16C             
0150+  E16C 01 03 02 01 date_limits         .DB     1,3,2,1,9,9
0150+  E170 09 09 
0151+  E172             
0152+  E172 01          day_of_week         .DB     1
0153+  E173 00 00 00 00 digit_values        .DB     0,0,0,0,0,0
0153+  E177 00 00 
0154+  E179 FF                              .DB     0FFh
0155+  E17A             
0156+  E17A 11 73 E1    get_date_time       LD      DE, digit_values
0157+  E17D 01 06 00                        LD      BC, 6
0158+  E180 ED B0                           LDIR
0159+  E182 2B                              DEC     HL
0160+  E183 1B                              DEC     DE
0161+  E184 06 06                           LD      B, 6
0162+  E186             
0163+  E186 E5          _get_digit          PUSH    HL
0164+  E187 D5                              PUSH    DE
0165+  E188 C5                              PUSH    BC
0166+  E189 CD 9A EF                        CALL    bios_conin
0167+  E18C C1                              POP     BC
0168+  E18D D1                              POP     DE
0169+  E18E E1                              POP     HL
0170+  E18F D6 30                           SUB     '0'
0171+  E191 38 F3                           JR      C, _get_digit
0172+  E193 4F                              LD      C, A
0173+  E194 1A                              LD      A, (DE)
0174+  E195 32 AA E1                        LD      (_digit_compare+1),A
0175+  E198 B9                              CP      C
0176+  E199 38 EB                           JR      C, _get_digit
0177+  E19B             
0178+  E19B 79                              LD      A, C
0179+  E19C 12                              LD      (DE), A
0180+  E19D C6 30                           ADD     A,'0'
0181+  E19F CD A8 F3                        CALL    m_print_a_safe
0182+  E1A2             
0183+  E1A2 1A                              LD      A,(DE)
0184+  E1A3 2B                              DEC     HL
0185+  E1A4 1B                              DEC     DE
0186+  E1A5 CB 40                           BIT     0, B
0187+  E1A7 20 0A                           JR      NZ, _next_tuple
0188+  E1A9 FE 00       _digit_compare      CP      0
0189+  E1AB 28 03                           JR      Z, _next_digit
0190+  E1AD 3E 09                           LD      A, 9
0191+  E1AF 12                              LD      (DE), A
0192+  E1B0 10 D4       _next_digit         DJNZ    _get_digit
0193+  E1B2 C9                              RET
0194+  E1B3 CD 9B F3    _next_tuple         CALL    m_print_inline
0195+  E1B6 1B 43 00                        .DB     ESCAPE_CHAR, 'C', 0
0196+  E1B9 18 F5                           JR      _next_digit0171   E1BB             
0172   E1BB             
0173   E1BB AF          ymodem_loader       XOR     A
0174   E1BC 32 0D E4                        LD      (_ymodem_set), A
0175   E1BF 21 86 E4                        LD      HL, ymodem_menu
0176   E1C2 CD 4B E8                        CALL    start_menu
0177   E1C5                                 
0178   E1C5 3A 0D E4                        LD      A, (_ymodem_set)
0179   E1C8 A7                              AND     A
0180   E1C9 C8                              RET     Z
0181   E1CA             
0182   E1CA ED 5B 0A E4                     LD      DE, (_ymodem_address)
0183   E1CE 3A 0C E4                        LD      A, (_ymodem_page)
0184   E1D1 21 6F DE                        LD      HL, MONITOR_START-YMODEM_BUFFER
0185   E1D4 F3                              DI
0186   E1D5 CD BA EA                        CALL    ymodem
0187   E1D8 FB                              EI
0188   E1D9 A7                              AND     A
0189   E1DA CA 8C E2                        JP      Z, _ymodem_success
0190   E1DD             
0191   E1DD 3D                              DEC     A
0192   E1DE 5F                              LD      E, A
0193   E1DF 16 00                           LD      D, 0
0194   E1E1 21 0C E2                        LD      HL, _ymodem_errors
0195   E1E4 19                              ADD     HL, DE
0196   E1E5 19                              ADD     HL, DE
0197   E1E6             
0198   E1E6 7E                              LD      A, (HL)
0199   E1E7 23                              INC     HL
0200   E1E8 66                              LD      H, (HL)
0201   E1E9 6F                              LD      L, A
0202   E1EA             
0203   E1EA 79                              LD      A, C
0204   E1EB C6 30                           ADD     A, '0'
0205   E1ED 32 48 E2                        LD      (_packet_err_code), A
0206   E1F0             
0207   E1F0 E5                              PUSH    HL
0208   E1F1 CD 9B F3                        CALL    m_print_inline
0209   E1F4 0D 45 52 52                     .DB     CARRIAGE_RETURN, "ERROR: ", 0
0209   E1F8 4F 52 3A 20 
0209   E1FC 00 
0210   E1FD             
0211   E1FD E1                              POP     HL
0212   E1FE             
0213   E1FE 7E          _ymodem_err_loop    LD      A, (HL)
0214   E1FF 23                              INC     HL
0215   E200 A7                              AND     A
0216   E201 CA 9A EF                        JP      Z, bios_conin                   ; Wait for a key then go to main menu..
0217   E204 4F                              LD      C, A
0218   E205 E5                              PUSH    HL
0219   E206 CD 00 F0                        CALL    bios_conout
0220   E209 E1                              POP     HL
0221   E20A 18 F2                           JR      _ymodem_err_loop
0222   E20C             
0223   E20C 1C E2       _ymodem_errors      .DW     _y_msg_timeout
0224   E20E 26 E2                           .DW     _y_msg_unknown
0225   E210 37 E2                           .DW     _y_msg_cancel     
0226   E212 40 E2                           .DW     _y_msg_packet
0227   E214 4D E2                           .DW     _y_msg_length
0228   E216 5B E2                           .DW     _y_msg_no_dest
0229   E218 6C E2                           .DW     _y_msg_send
0230   E21A 7B E2                           .DW     _y_msg_files
0231   E21C             
0232   E21C 54 69 6D 65 _y_msg_timeout      .DB     "Timeout", ESCAPE_CHAR, "K", 0
0232   E220 6F 75 74 1B 
0232   E224 4B 00 
0233   E226 55 6E 6B 6E _y_msg_unknown      .DB     "Unknown packet", ESCAPE_CHAR, "K", 0
0233   E22A 6F 77 6E 20 
0233   E22E 70 61 63 6B 
0233   E232 65 74 1B 4B 
0233   E236 00 
0234   E237 43 61 6E 63 _y_msg_cancel       .DB     "Cancel", ESCAPE_CHAR, "K", 0
0234   E23B 65 6C 1B 4B 
0234   E23F 00 
0235   E240 50 61 63 6B _y_msg_packet       .DB     "Packet (", 
0235   E244 65 74 20 28 
0236   E248             
0237   E248 30 29 1B 4B _packet_err_code    .DB     "0)", ESCAPE_CHAR, "K", 0
0237   E24C 00 
0238   E24D             
0239   E24D 46 69 6C 65 _y_msg_length       .DB     "File length", ESCAPE_CHAR, "K", 0
0239   E251 20 6C 65 6E 
0239   E255 67 74 68 1B 
0239   E259 4B 00 
0240   E25B 4E 6F 20 64 _y_msg_no_dest      .DB     "No destination", ESCAPE_CHAR, "K", 0
0240   E25F 65 73 74 69 
0240   E263 6E 61 74 69 
0240   E267 6F 6E 1B 4B 
0240   E26B 00 
0241   E26C 53 65 6E 64 _y_msg_send         .DB     "Send Timeout", ESCAPE_CHAR, "K", 0
0241   E270 20 54 69 6D 
0241   E274 65 6F 75 74 
0241   E278 1B 4B 00 
0242   E27B 4D 75 6C 74 _y_msg_files        .DB     "Multiple files", ESCAPE_CHAR, "K", 0
0242   E27F 69 70 6C 65 
0242   E283 20 66 69 6C 
0242   E287 65 73 1B 4B 
0242   E28B 00 
0243   E28C             
0244   E28C CD 9B F3    _ymodem_success     CALL    m_print_inline           
0245   E28F 0D 4F 4B 20                     .DB     CARRIAGE_RETURN, "OK ",0
0245   E293 00 
0246   E294 3A 73 DE                        LD      A, (MONITOR_START-YMODEM_INFO+ym_length_high)
0247   E297 FE FF                           CP      0FFh
0248   E299 28 06                           JR      Z, _ymodem_no_high
0249   E29B C6 30                           ADD     A, '0'
0250   E29D 4F                              LD      C, A
0251   E29E CD 00 F0                        CALL    bios_conout
0252   E2A1 3A 72 DE    _ymodem_no_high     LD      A, (MONITOR_START-YMODEM_INFO+ym_length_mid)
0253   E2A4 CD D9 E8                        CALL    hex_out
0254   E2A7 3A 71 DE                        LD      A, (MONITOR_START-YMODEM_INFO+ym_length_low)
0255   E2AA CD D9 E8                        CALL    hex_out
0256   E2AD CD 9B F3                        CALL    m_print_inline
0257   E2B0 20 42 59 54                     .DB     " BYTES @ ", 0
0257   E2B4 45 53 20 40 
0257   E2B8 20 00 
0258   E2BA 3A 6F DE                        LD      A, (MONITOR_START-YMODEM_INFO+ym_file_mode)
0259   E2BD 17                              RLA
0260   E2BE 38 10                           JR      C, _ymodem_show_addr
0261   E2C0 1F                              RRA
0262   E2C1 CD D9 E8                        CALL    hex_out
0263   E2C4 0E 2F                           LD      C, '/'
0264   E2C6 CD 00 F0                        CALL    bios_conout
0265   E2C9 3A 79 DE                        LD      A, (MONITOR_START-YMODEM_INFO+ym_dest_high)
0266   E2CC D6 40                           SUB     40h
0267   E2CE 18 03                           JR      _ymodem_addr
0268   E2D0             
0269   E2D0 3A 79 DE    _ymodem_show_addr   LD      A, (MONITOR_START-YMODEM_INFO+ym_dest_high)
0270   E2D3 CD D9 E8    _ymodem_addr        CALL    hex_out
0271   E2D6 3A 78 DE                        LD      A, (MONITOR_START-YMODEM_INFO+ym_dest_low)
0272   E2D9 CD D9 E8                        CALL    hex_out
0273   E2DC CD 9B F3                        CALL    m_print_inline
0274   E2DF 1B 4B 00                        .DB     ESCAPE_CHAR, "K", 0
0275   E2E2 CD 71 EF    _ymodem_waitkey     CALL    bios_conist                  
0276   E2E5 A7                              AND     A
0277   E2E6 28 FA                           JR      Z, _ymodem_waitkey
0278   E2E8             
0279   E2E8 CD 9A EF                        CALL    bios_conin
0280   E2EB             
0281   E2EB             
0282   E2EB 3A 6F DE                        LD      A, (MONITOR_START-YMODEM_INFO+ym_file_mode)      ; Do something with the file.
0283   E2EE 17                              RLA
0284   E2EF 30 06                           JR      NC, _ymodem_handle_page
0285   E2F1             
0286   E2F1 21 0E E4                        LD      HL, ymodem_mem_menu
0287   E2F4 C3 4B E8                        JP      start_menu
0288   E2F7             
0289   E2F7             
0290   E2F7 21 3B E4    _ymodem_handle_page LD      HL, ymodem_page_menu
0291   E2FA C3 4B E8                        JP      start_menu
0292   E2FD             
0293   E2FD 2A 78 DE    _ymodem_view        LD      HL, (MONITOR_START-YMODEM_INFO+ym_dest_low)
0294   E300 22 7B E5                        LD      (monitor_address), HL
0295   E303 C3 5A E6                        JP      edit_memory
0296   E306             
0297   E306 2A 78 DE    _ymodem_exec        LD      HL, (MONITOR_START-YMODEM_INFO+ym_dest_low)
0298   E309 E5                              PUSH    HL
0299   E30A C9          _ymodem_exit        RET
0300   E30B             
0301   E30B CD 9B F3    _ymodem_flash       CALL    m_print_inline
0302   E30E 0D 0A 50 61                     .DB     CARRIAGE_RETURN, NEWLINE, "Page 00-1f >", ESCAPE_CHAR, "K", 0
0302   E312 67 65 20 30 
0302   E316 30 2D 31 66 
0302   E31A 20 3E 1B 4B 
0302   E31E 00 
0303   E31F             
0304   E31F 06 02                           LD      B, 2
0305   E321 CD C5 E7                        CALL    hex_input
0306   E324 CD 37 E8                        CALL    delete_or_enter
0307   E327 3A 35 E8                        LD      A, (hex_input_result)
0308   E32A FE 1F                           CP      1fh
0309   E32C 30 DD                           JR      NC, _ymodem_flash
0310   E32E             
0311   E32E CD 9B F3                        CALL    m_print_inline
0312   E331 20 59 2F 4E                     .DB     " Y/N?", 0
0312   E335 3F 00 
0313   E337 CD 9A EF                        CALL    bios_conin
0314   E33A FE 79                           CP      'y'
0315   E33C 20 B9                           JR      NZ, _ymodem_handle_page
0316   E33E             
0317   E33E CD 9B F3                        CALL    m_print_inline
0318   E341 0D 0A 57 72                     .DB     CARRIAGE_RETURN, NEWLINE, "Writing", ESCAPE_CHAR, "K", 0
0318   E345 69 74 69 6E 
0318   E349 67 1B 4B 00 
0319   E34D             
0320   E34D 3A 35 E8                        LD      A, (hex_input_result)
0321   E350 17                              RLA
0322   E351 17                              RLA
0323   E352 57                              LD      D, A
0324   E353             
0325   E353 3A 6F DE                        LD      A, (MONITOR_START-YMODEM_INFO+ym_file_mode)         ; Page loaded
0326   E356 32 0C E4    _next_page          LD      (_ymodem_page), A
0327   E359 D3 71                           OUT     (IO_MEM_1), A
0328   E35B             
0329   E35B 2A 72 DE                        LD      HL, (MONITOR_START-YMODEM_INFO+ym_length_mid)
0330   E35E 7D                              LD      A, L
0331   E35F E6 C0                           AND     0c0h
0332   E361 B4                              OR      H
0333   E362 20 22                           JR      NZ, _full_page
0334   E364             
0335   E364 ED 4B 71 DE                     LD      BC, (MONITOR_START-YMODEM_INFO+ym_length_low)
0336   E368 78                              LD      A, B
0337   E369 B1                              OR      C
0338   E36A 28 06                           JR      Z, _flash_done
0339   E36C 21 00 40                        LD      HL, 4000h
0340   E36F CD 6E FD                        CALL    flash_write
0341   E372             
0342   E372 3E 20       _flash_done         LD      A, RAM_PAGE_0
0343   E374 D3 70                           OUT     (IO_MEM_0), A
0344   E376             
0345   E376 CD 9B F3                        CALL    m_print_inline
0346   E379 0D 0A 44 6F                     .DB     CARRIAGE_RETURN, NEWLINE, "Done ", ESCAPE_CHAR, "K", 0           
0346   E37D 6E 65 20 1B 
0346   E381 4B 00 
0347   E383 C3 9A EF                        JP      bios_conin
0348   E386             
0349   E386 01 40 00    _full_page          LD      BC, 0040h
0350   E389 AF                              XOR     A
0351   E38A ED 42                           SBC     HL, BC
0352   E38C 22 72 DE                        LD      (MONITOR_START-YMODEM_INFO+ym_length_mid), HL
0353   E38F 21 00 40                        LD      HL, 4000h
0354   E392 44                              LD      B, H
0355   E393 4D                              LD      C, L
0356   E394 CD 6E FD                        CALL    flash_write
0357   E397 14                              INC     D
0358   E398 3A 0C E4                        LD      A,(_ymodem_page)
0359   E39B 3C                              INC     A
0360   E39C 18 B8                           JR      _next_page
0361   E39E             
0362   E39E 3A 73 DE    _ymodem_firmware    LD      A, (MONITOR_START-YMODEM_INFO+ym_length_high)
0363   E3A1 A7                              AND     A
0364   E3A2 20 52                           JR      NZ, _not_firmware
0365   E3A4 3A 72 DE                        LD      A, (MONITOR_START-YMODEM_INFO+ym_length_mid)
0366   E3A7 FE 40                           CP      040h
0367   E3A9 30 4B                           JR      NC, _not_firmware
0368   E3AB             
0369   E3AB CD 9B F3                        CALL    m_print_inline
0370   E3AE 0D 57 72 69                     .DB     CARRIAGE_RETURN, "Write firmware, Y/N?", ESCAPE_CHAR, "K", 0
0370   E3B2 74 65 20 66 
0370   E3B6 69 72 6D 77 
0370   E3BA 61 72 65 2C 
0370   E3BE 20 59 2F 4E 
0370   E3C2 3F 1B 4B 00 
0371   E3C6 CD 9A EF                        CALL    bios_conin
0372   E3C9 FE 79                           CP      'y'
0373   E3CB C2 F7 E2                        JP      NZ, _ymodem_handle_page
0374   E3CE             
0375   E3CE ED 4B 71 DE                     LD      BC, (MONITOR_START-YMODEM_INFO+ym_length_low)
0376   E3D2 3A 6F DE                        LD      A, (MONITOR_START-YMODEM_INFO+ym_file_mode)         ; Page loaded
0377   E3D5 D3 71                           OUT     (IO_MEM_1), A
0378   E3D7                                 
0379   E3D7 21 00 40                        LD      HL, 4000h
0380   E3DA 16 00                           LD      D, 0
0381   E3DC CD 6E FD                        CALL    flash_write
0382   E3DF             
0383   E3DF CD 9B F3                        CALL    m_print_inline
0384   E3E2 0D 0A 44 6F                     .DB     CARRIAGE_RETURN, NEWLINE, "Done ", ESCAPE_CHAR, "K", 0
0384   E3E6 6E 65 20 1B 
0384   E3EA 4B 00 
0385   E3EC ED 5B 71 DE                     LD      DE, (MONITOR_START-YMODEM_INFO+ym_length_low)
0386   E3F0 CD D2 E8                        CALL    hex_word
0387   E3F3 C3 9A EF                        JP      bios_conin
0388   E3F6             
0389   E3F6 CD 9B F3    _not_firmware       CALL    m_print_inline
0390   E3F9 0D 0A 54 6F                     .DB     CARRIAGE_RETURN, NEWLINE, "Too large", ESCAPE_CHAR, "K", 0
0390   E3FD 6F 20 6C 61 
0390   E401 72 67 65 1B 
0390   E405 4B 00 
0391   E407 C3 9A EF                        JP      bios_conin
0392   E40A             
0393   E40A             
0394   E40A 00 00       _ymodem_address     .DW     0
0395   E40C 00          _ymodem_page        .DB     0
0396   E40D 00          _ymodem_set         .DB     0
0397   E40E             
0398   E40E 46 69 6C 65 ymodem_mem_menu     .DB     "File actions", 0
0398   E412 20 61 63 74 
0398   E416 69 6F 6E 73 
0398   E41A 00 
0399   E41B FD E2                           .DW     _ymodem_view
0400   E41D 56 69 65 77                     .DB     "View file", 0
0400   E421 20 66 69 6C 
0400   E425 65 00 
0401   E427 06 E3                           .DW     _ymodem_exec
0402   E429 52 75 6E 00                     .DB     "Run", 0
0403   E42D 0A E3                           .DW     _ymodem_exit
0404   E42F 4D 61 69 6E                     .DB     "Main menu", 0
0404   E433 20 6D 65 6E 
0404   E437 75 00 
0405   E439 00 00                           .DW     0
0406   E43B             
0407   E43B 46 69 6C 65 ymodem_page_menu    .DB     "File actions", 0
0407   E43F 20 61 63 74 
0407   E443 69 6F 6E 73 
0407   E447 00 
0408   E448 0B E3                           .DW     _ymodem_flash
0409   E44A 43 6F 70 79                     .DB     "Copy to flash", 0
0409   E44E 20 74 6F 20 
0409   E452 66 6C 61 73 
0409   E456 68 00 
0410   E458 00 E0                           .DW     boot_without_format
0411   E45A 43 50 4D 20                     .DB     "CPM Drive B", 0
0411   E45E 44 72 69 76 
0411   E462 65 20 42 00 
0412   E466 9E E3                           .DW     _ymodem_firmware
0413   E468 55 70 64 61                     .DB     "Update firmware", 0
0413   E46C 74 65 20 66 
0413   E470 69 72 6D 77 
0413   E474 61 72 65 00 
0414   E478 0A E3                           .DW     _ymodem_exit
0415   E47A 4D 61 69 6E                     .DB     "Main menu", 0
0415   E47E 20 6D 65 6E 
0415   E482 75 00 
0416   E484 00 00                           .DW     0
0417   E486             
0418   E486 44 6F 77 6E ymodem_menu         .DB     "Download options", 0
0418   E48A 6C 6F 61 64 
0418   E48E 20 6F 70 74 
0418   E492 69 6F 6E 73 
0418   E496 00 
0419   E497 D8 E4                           .DW     _ymodem_from_file
0420   E499 41 64 64 72                     .DB     "Address from file", 0
0420   E49D 65 73 73 20 
0420   E4A1 66 72 6F 6D 
0420   E4A5 20 66 69 6C 
0420   E4A9 65 00 
0421   E4AB F9 E4                           .DW     _ymodem_logical
0422   E4AD 43 50 55 20                     .DB     "CPU (Logical) address",0
0422   E4B1 28 4C 6F 67 
0422   E4B5 69 63 61 6C 
0422   E4B9 29 20 61 64 
0422   E4BD 64 72 65 73 
0422   E4C1 73 00 
0423   E4C3 2F E5                           .DW     _ymodem_physical
0424   E4C5 50 68 79 73                     .DB     "Physical address", 0
0424   E4C9 69 63 61 6C 
0424   E4CD 20 61 64 64 
0424   E4D1 72 65 73 73 
0424   E4D5 00 
0425   E4D6 00 00                           .DW     0
0426   E4D8             
0427   E4D8 11 FF FF    _ymodem_from_file   LD      DE, 0FFFFh
0428   E4DB ED 53 0A E4                     LD      (_ymodem_address), DE
0429   E4DF ED 53 0C E4                     LD      (_ymodem_page), DE
0430   E4E3 CD 9B F3    _ymodem_transfer    CALL    m_print_inline
0431   E4E6 0D 53 74 61                     .DB     CARRIAGE_RETURN, "Start transfer", ESCAPE_CHAR, "K", 0
0431   E4EA 72 74 20 74 
0431   E4EE 72 61 6E 73 
0431   E4F2 66 65 72 1B 
0431   E4F6 4B 00 
0432   E4F8 C9                              RET
0433   E4F9             
0434   E4F9 CD 9B F3    _ymodem_logical     CALL    m_print_inline
0435   E4FC 0D 41 64 64                     .DB     CARRIAGE_RETURN, "Address 0000-FFFF >", ESCAPE_CHAR, "K", 0
0435   E500 72 65 73 73 
0435   E504 20 30 30 30 
0435   E508 30 2D 46 46 
0435   E50C 46 46 20 3E 
0435   E510 1B 4B 00 
0436   E513 06 04                           LD      B, 4
0437   E515 CD C5 E7                        CALL    hex_input
0438   E518 CD 37 E8                        CALL    delete_or_enter
0439   E51B 3E FF                           LD      A, 0FFh
0440   E51D 32 0C E4                        LD      (_ymodem_page), A
0441   E520             
0442   E520 ED 5B 35 E8 _ymodem_set_and_go  LD      DE, (hex_input_result)
0443   E524 ED 53 0A E4                     LD      (_ymodem_address), DE
0444   E528 3E FF                           LD      A, 0FFh
0445   E52A 32 0D E4                        LD      (_ymodem_set), A
0446   E52D 18 B4                           JR      _ymodem_transfer
0447   E52F             
0448   E52F CD 9B F3    _ymodem_physical    CALL    m_print_inline
0449   E532 0D 50 61 67                     .DB     CARRIAGE_RETURN, "Page 20-3F >", ESCAPE_CHAR, "K", 0
0449   E536 65 20 32 30 
0449   E53A 2D 33 46 20 
0449   E53E 3E 1B 4B 00 
0450   E542 06 02                           LD      B, 2
0451   E544 CD C5 E7                        CALL    hex_input
0452   E547 CD 37 E8                        CALL    delete_or_enter
0453   E54A 3A 35 E8                        LD      A, (hex_input_result)
0454   E54D 32 0C E4                        LD      (_ymodem_page), A
0455   E550 CD 9B F3                        CALL    m_print_inline
0456   E553 0D 4F 66 66                     .DB     CARRIAGE_RETURN, "Offset 0000-3FFF >", ESCAPE_CHAR, "K", 0
0456   E557 73 65 74 20 
0456   E55B 30 30 30 30 
0456   E55F 2D 33 46 46 
0456   E563 46 20 3E 1B 
0456   E567 4B 00 
0457   E569 06 04                           LD      B, 4
0458   E56B CD C5 E7                        CALL    hex_input
0459   E56E CD 37 E8                        CALL    delete_or_enter
0460   E571 3A 36 E8                        LD      A, (hex_input_result+1)         ; YModem loads to page 1, so allow for offset..
0461   E574 F6 40                           OR      040h
0462   E576 32 36 E8                        LD      (hex_input_result+1), A
0463   E579 18 A5                           JR      _ymodem_set_and_go
0464   E57B             
0465   E57B             ;------------------------------ Memory Editor --------------------------------------------
0466   E57B             
0467   E57B 00 80       monitor_address     .DW     08000h              ; Default address is 0x8000
0468   E57D 00          monitor_mode        .DB     0                   ; 0 = show address + 3 characters, ~0 = hide address + 8 characters
0469   E57E 00          edit_col            .DB     0                   ; Column currently being edited..
0470   E57F 00 00       edit_digit          .DW     0
0471   E581             
0472   E581 CD 17 E7    memory_view         CALL    display_mem_row
0473   E584             
0474   E584 CD 71 EF    _wait_key           CALL    bios_conist
0475   E587 A7                              AND     A
0476   E588 28 FA                           JR      Z, _wait_key
0477   E58A CD 9A EF                        CALL    bios_conin
0478   E58D             
0479   E58D FE 80                           CP      KEY_UP
0480   E58F 20 0D                           JR      NZ, _not_up
0481   E591 2A 7B E5    memory_up           LD      HL, (monitor_address)
0482   E594 11 08 00                        LD      DE, 8
0483   E597 ED 52                           SBC     HL, DE
0484   E599 22 7B E5                        LD      (monitor_address), HL
0485   E59C 18 E3                           JR      memory_view
0486   E59E             
0487   E59E FE 81       _not_up             CP      KEY_DOWN
0488   E5A0 20 0C                           JR      NZ, _not_down
0489   E5A2 2A 7B E5    memory_down         LD      HL, (monitor_address)
0490   E5A5 11 08 00                        LD      DE, 8
0491   E5A8 19                              ADD     HL, DE
0492   E5A9 22 7B E5                        LD      (monitor_address), HL
0493   E5AC 18 D3                           JR      memory_view
0494   E5AE             
0495   E5AE FE 20       _not_down           CP      ' '
0496   E5B0 20 09                           JR      NZ, _not_space
0497   E5B2 3A 7D E5                        LD      A, (monitor_mode)
0498   E5B5 2F                              CPL
0499   E5B6 32 7D E5                        LD      (monitor_mode), A
0500   E5B9 18 C6                           JR      memory_view
0501   E5BB             
0502   E5BB FE 0D       _not_space          CP      CARRIAGE_RETURN
0503   E5BD 28 0E                           JR      Z, _input_address
0504   E5BF             
0505   E5BF FE 83                           CP      KEY_RIGHT
0506   E5C1 CA 5A E6                        JP      Z, edit_memory
0507   E5C4 FE 08                           CP      KEY_BACKSPACE
0508   E5C6 C8                              RET     Z
0509   E5C7             
0510   E5C7 FE 78                           CP      'x'
0511   E5C9 28 1C                           JR      Z, execute
0512   E5CB 18 B7                           JR      _wait_key
0513   E5CD             
0514   E5CD AF          _input_address      XOR     A
0515   E5CE 32 7D E5                        LD      (monitor_mode), A
0516   E5D1 CD 17 E7                        CALL    display_mem_row
0517   E5D4 0E 0D                           LD      C, CARRIAGE_RETURN
0518   E5D6 CD 00 F0                        CALL    bios_conout
0519   E5D9             
0520   E5D9 06 04                           LD      B, 4
0521   E5DB CD C5 E7                        CALL    hex_input
0522   E5DE 2A 35 E8                        LD      HL, (hex_input_result)
0523   E5E1 22 7B E5                        LD      (monitor_address), HL
0524   E5E4 C3 81 E5                        JP      memory_view
0525   E5E7             
0526   E5E7 AF          execute             XOR     A
0527   E5E8 32 7E E5                        LD      (edit_col), A
0528   E5EB CD 9B F3    execute_col         CALL    m_print_inline
0529   E5EE 0D 1B 62 2E                     .DB     CARRIAGE_RETURN, ESCAPE_CHAR, 'b', CPM_NUM+15, "Execute from ", 0
0529   E5F2 45 78 65 63 
0529   E5F6 75 74 65 20 
0529   E5FA 66 72 6F 6D 
0529   E5FE 20 00 
0530   E600 21 3E E6                        LD      HL, _exec_done
0531   E603 E5                              PUSH    HL
0532   E604 2A 7B E5                        LD      HL, (monitor_address)
0533   E607 3A 7E E5                        LD      A, (edit_col)
0534   E60A 5F                              LD      E, A
0535   E60B 16 00                           LD      D, 0
0536   E60D 19                              ADD     HL, DE
0537   E60E                                 
0538   E60E E5                              PUSH    HL
0539   E60F EB                              EX      DE, HL
0540   E610 CD D2 E8                        CALL    hex_word
0541   E613 CD 9B F3                        CALL    m_print_inline
0542   E616 20 59 2F 4E                     .DB     " Y/N?", ESCAPE_CHAR, "K", 0
0542   E61A 3F 1B 4B 00 
0543   E61E             
0544   E61E CD 9A EF    _exec_loop          CALL    bios_conin
0545   E621 FE 79                           CP      'y'
0546   E623 28 09                           JR      Z, _exec_go
0547   E625 FE 6E                           CP      'n'
0548   E627 20 F5                           JR      NZ, _exec_loop
0549   E629 E1                              POP     HL
0550   E62A E1                              POP     HL
0551   E62B C3 81 E5                        JP      memory_view
0552   E62E             
0553   E62E CD 9B F3    _exec_go            CALL    m_print_inline
0554   E631 0A 0D 52 75                     .DB     NEWLINE, CARRIAGE_RETURN, "Running", ESCAPE_CHAR, "K", 0
0554   E635 6E 6E 69 6E 
0554   E639 67 1B 4B 00 
0555   E63D C9                              RET
0556   E63E             
0557   E63E F5          _exec_done          PUSH    AF
0558   E63F CD 9B F3                        CALL    m_print_inline
0559   E642 0A 0D 44 6F                     .DB     NEWLINE, CARRIAGE_RETURN, "Done. A=",0
0559   E646 6E 65 2E 20 
0559   E64A 41 3D 00 
0560   E64D F1                              POP     AF
0561   E64E CD D9 E8                        CALL    hex_out
0562   E651 CD 9B F3                        CALL    m_print_inline
0563   E654 1B 4B 00                        .DB     ESCAPE_CHAR, "K", 0
0564   E657 CD 9A EF                        CALL    bios_conin ;pause for a key, then return to memory edit at the execution location
0565   E65A             
0566   E65A             
0567   E65A AF          edit_memory         XOR     A
0568   E65B 32 7E E5    _set_col_and_edit   LD      (edit_col), A
0569   E65E CD 17 E7    _edit_loop          CALL    display_mem_row
0570   E661 3A 7E E5                        LD      A, (edit_col)
0571   E664 87                              ADD     A, A
0572   E665 4F                              LD      C, A
0573   E666 3A 7D E5                        LD      A, (monitor_mode)
0574   E669 A7                              AND     A
0575   E66A 20 04                           JR      NZ, _address_hidden
0576   E66C 3E 05                           LD      A, 5
0577   E66E 81                              ADD     A, C
0578   E66F 4F                              LD      C, A
0579   E670 3A 2D FF    _address_hidden     LD      A, (cursor_row)
0580   E673 C6 1F                           ADD     A, 31
0581   E675 32 86 E6                        LD      (_edit_set_row), A
0582   E678 79                              LD      A, C
0583   E679 C6 20                           ADD     A, 32
0584   E67B 32 87 E6                        LD      (_edit_set_col), A
0585   E67E             
0586   E67E CD 9B F3                        CALL    m_print_inline
0587   E681 1B 62 27                        .DB     ESCAPE_CHAR, 'b', CPM_NUM+8         ; Set the correct brightness
0588   E684 1B 59                           .DB     ESCAPE_CHAR, 'Y'                    ; And position the cursor
0589   E686 00          _edit_set_row       .DB     0
0590   E687 00          _edit_set_col       .DB     0
0591   E688 00                              .DB     0
0592   E689             
0593   E689 11 00 02                        LD      DE, 0200h
0594   E68C ED 53 7F E5 _edit_next_digit    LD      (edit_digit), DE
0595   E690             
0596   E690 CD 9A EF    _edit_input         CALL    bios_conin
0597   E693 FE 78                           CP      'x'
0598   E695 CA EB E5                        JP      Z, execute_col
0599   E698             
0600   E698 FE 83                           CP      KEY_RIGHT
0601   E69A 20 1B                           JR      NZ, _not_right
0602   E69C 3A 7E E5    _edit_right         LD      A, (edit_col)
0603   E69F FE 07                           CP      7
0604   E6A1 28 03                           JR      Z, _edit_wrap_down
0605   E6A3 3C                              INC     A
0606   E6A4 18 B5                           JR      _set_col_and_edit
0607   E6A6             
0608   E6A6 AF          _edit_wrap_down     XOR     A
0609   E6A7 32 7E E5                        LD      (edit_col),A
0610   E6AA 11 08 00    _edit_down          LD      DE, 08h
0611   E6AD 2A 7B E5    _edit_move          LD      HL, (monitor_address)
0612   E6B0 19                              ADD     HL, DE
0613   E6B1 22 7B E5                        LD      (monitor_address), HL
0614   E6B4 C3 5E E6                        JP      _edit_loop
0615   E6B7             
0616   E6B7 FE 82       _not_right          CP      KEY_LEFT
0617   E6B9 20 13                           JR      NZ, _not_left
0618   E6BB 3A 7E E5                        LD      A, (edit_col)
0619   E6BE A7                              AND     A
0620   E6BF 28 03                           JR      Z, _edit_wrap_up
0621   E6C1 3D                              DEC     A
0622   E6C2 18 97                           JR      _set_col_and_edit
0623   E6C4             
0624   E6C4 3E 07       _edit_wrap_up       LD      A, 7
0625   E6C6 32 7E E5                        LD      (edit_col),A
0626   E6C9 11 F8 FF    _edit_up            LD      DE, 0FFF8h
0627   E6CC 18 DF                           JR      _edit_move
0628   E6CE             
0629   E6CE FE 80       _not_left           CP      KEY_UP
0630   E6D0 CA C9 E6                        JP      Z, _edit_up
0631   E6D3 FE 81                           CP      KEY_DOWN
0632   E6D5 CA AA E6                        JP      Z, _edit_down
0633   E6D8 FE 08                           CP      KEY_BACKSPACE
0634   E6DA C2 E8 E6                        JP      NZ, _not_delete
0635   E6DD             
0636   E6DD 3A 80 E5                        LD      A, (edit_digit+1)
0637   E6E0 FE 02                           CP      2
0638   E6E2 CA 81 E5                        JP      Z, memory_view
0639   E6E5 C3 5E E6                        JP      _edit_loop
0640   E6E8             
0641   E6E8 CD 00 E9    _not_delete         CALL    valid_hex_char
0642   E6EB 38 A3                           JR      C, _edit_input
0643   E6ED             
0644   E6ED 4F                              LD      C, A
0645   E6EE CD 10 E9                        CALL    hex_char_to_num
0646   E6F1 F5                              PUSH    AF
0647   E6F2 CD 00 F0                        CALL    bios_conout
0648   E6F5 F1                              POP     AF
0649   E6F6                                 
0650   E6F6 ED 5B 7F E5                     LD      DE, (edit_digit)
0651   E6FA CB 23                           SLA     E
0652   E6FC CB 23                           SLA     E
0653   E6FE CB 23                           SLA     E
0654   E700 CB 23                           SLA     E
0655   E702 B3                              OR      E
0656   E703 5F                              LD      E, A
0657   E704 15                              DEC     D
0658   E705 20 85                           JR      NZ, _edit_next_digit
0659   E707             
0660   E707 3A 7E E5                        LD      A, (edit_col)
0661   E70A 4F                              LD      C, A
0662   E70B 06 00                           LD      B, 0
0663   E70D 2A 7B E5                        LD      HL, (monitor_address)
0664   E710 09                              ADD     HL, BC
0665   E711 73                              LD      (HL), E
0666   E712 CD 17 E7                        CALL    display_mem_row
0667   E715 18 85                           JR      _edit_right
0668   E717             
0669   E717 0E 0D       display_mem_row     LD      C, CARRIAGE_RETURN
0670   E719 CD 00 F0                        CALL    bios_conout
0671   E71C 3A 7D E5                        LD      A, (monitor_mode)
0672   E71F A7                              AND     A
0673   E720 20 14                           JR      NZ, _hex_values
0674   E722             
0675   E722 CD 9B F3                        CALL    m_print_inline
0676   E725 0D 1B 62 2E                     .DB     CARRIAGE_RETURN, ESCAPE_CHAR, 'b', CPM_NUM+15, 0
0676   E729 00 
0677   E72A             
0678   E72A ED 5B 7B E5                     LD      DE, (monitor_address)
0679   E72E CD D2 E8                        CALL    hex_word
0680   E731             
0681   E731 0E 20                           LD      C, ' '
0682   E733 CD 00 F0                        CALL    bios_conout
0683   E736             
0684   E736 CD 9B F3    _hex_values         CALL    m_print_inline
0685   E739 1B 62 27 00                     .DB     ESCAPE_CHAR, 'b', CPM_NUM+8, 0
0686   E73D             
0687   E73D 2A 7B E5                        LD      HL, (monitor_address)
0688   E740 06 08                           LD      B, 8
0689   E742 7E          _mem_hex            LD      A, (HL)
0690   E743 E5                              PUSH    HL
0691   E744 C5                              PUSH    BC
0692   E745 CD D9 E8                        CALL    hex_out
0693   E748 C1                              POP     BC
0694   E749 E1                              POP     HL
0695   E74A 23                              INC     HL
0696   E74B 10 F5                           DJNZ    _mem_hex
0697   E74D             
0698   E74D CD 9B F3                        CALL    m_print_inline
0699   E750 1B 62 2E 00                     .DB     ESCAPE_CHAR, 'b', CPM_NUM+15, 0
0700   E754             
0701   E754 2A 7B E5                        LD      HL, (monitor_address)
0702   E757 06 03                           LD      B, 3
0703   E759 3A 7D E5                        LD      A, (monitor_mode)
0704   E75C A7                              AND     A
0705   E75D 28 02                           JR      Z, _mem_char
0706   E75F 06 08                           LD      B, 8
0707   E761             
0708   E761 7E          _mem_char           LD      A, (HL)
0709   E762 FE 20                           CP      ' '
0710   E764 D2 69 E7                        JP      NC, _not_control_char
0711   E767 3E 2E                           LD      A, '.'
0712   E769 FE 80       _not_control_char   CP      128
0713   E76B DA 70 E7                        JP      C, _not_extended_char
0714   E76E 3E 2E                           LD      A, '.'
0715   E770 E5          _not_extended_char  PUSH    HL
0716   E771 C5                              PUSH    BC
0717   E772 4F                              LD      C, A
0718   E773 CD 00 F0                        CALL    bios_conout
0719   E776 C1                              POP     BC
0720   E777 E1                              POP     HL
0721   E778 23                              INC     HL
0722   E779 10 E6                           DJNZ    _mem_char
0723   E77B C9                              RET
0724   E77C             
0725   E77C             ; Format memory disk
0726   E77C             ;
0727   E77C 3E 01       format_memdisk      LD      A, 1
0728   E77E 4F                              LD      C, A
0729   E77F CD C8 F2                        CALL    bios_seldsk
0730   E782             
0731   E782 21 80 00                        LD      HL, BIOS_SECTOR_ADDRESS     ; Sector buffer
0732   E785 22 C3 E7                        LD      (_fmt_address),HL
0733   E788             
0734   E788 54                              LD      D, H                        ; Fill sector buffer with 0E5h (blank byte)
0735   E789 5D                              LD      E, L
0736   E78A 13                              INC     DE
0737   E78B 3E E5                           LD      A, 0E5h
0738   E78D 77                              LD      (HL),A
0739   E78E 01 7F 00                        LD      BC, 07fh
0740   E791 ED B0                           LDIR
0741   E793             
0742   E793 3E 02                           LD      A,BIOS_BOOT_TRACKS          ; First track (Offset = 2)
0743   E795 32 C1 E7    _fmt_track_loop     LD      (_fmt_track),A
0744   E798 4F                              LD      C,A                         ; Set track
0745   E799 CD E3 F2                        CALL    bios_settrk
0746   E79C             
0747   E79C AF                              XOR     A                           ; Initial sector
0748   E79D 32 C2 E7    _fmt_sector_loop    LD      (_fmt_sector),A
0749   E7A0             
0750   E7A0 FE 1A                           CP      MEMDISK_SECTORS
0751   E7A2 28 14                           JR      Z,_fmt_next_track
0752   E7A4 4F                              LD      C,A                         ; Set sector
0753   E7A5 CD E8 F2                        CALL    bios_setsec
0754   E7A8 ED 4B C3 E7                     LD      BC,(_fmt_address)           ; Address to write from
0755   E7AC CD ED F2                        CALL    bios_setdma
0756   E7AF CD 29 F3                        CALL    bios_write
0757   E7B2 3A C2 E7                        LD      A,(_fmt_sector)
0758   E7B5             
0759   E7B5 3C                              INC     A
0760   E7B6 18 E5                           JR      _fmt_sector_loop
0761   E7B8             
0762   E7B8 3A C1 E7    _fmt_next_track     LD      A,(_fmt_track)
0763   E7BB FE 4F                           CP      MEMDISK_TRACKS
0764   E7BD C8                              RET     Z
0765   E7BE 3C                              INC     A
0766   E7BF 18 D4                           JR      _fmt_track_loop
0767   E7C1             
0768   E7C1 00          _fmt_track          .DB     0
0769   E7C2 00          _fmt_sector         .DB     0
0770   E7C3 00 00       _fmt_address        .DW     0
0771   E7C5             
0772   E7C5             ;------------------------------------------------------
0773   E7C5             ; Read hex input into the (input_hex) address
0774   E7C5             ; Params - B = number of characters to input
0775   E7C5             ;
0776   E7C5 78          hex_input           LD      A, B
0777   E7C6 32 0A E8                        LD      (_hi_size), A
0778   E7C9 21 00 00                        LD      HL, 0
0779   E7CC 22 35 E8                        LD      (hex_input_result), HL
0780   E7CF             
0781   E7CF C5          _hi_loop            PUSH    BC
0782   E7D0 CD F4 E8    _hi_loop_join       CALL    hex_char_in
0783   E7D3 FE 08                           CP      KEY_BACKSPACE
0784   E7D5 28 34                           JR      Z, _hi_delete
0785   E7D7 4F                              LD      C, A
0786   E7D8 F5                              PUSH    AF
0787   E7D9 CD 00 F0                        CALL    bios_conout
0788   E7DC F1                              POP     AF
0789   E7DD CD 10 E9                        CALL    hex_char_to_num
0790   E7E0 2A 35 E8                        LD      HL, (hex_input_result)
0791   E7E3 CB 27                           SLA     A
0792   E7E5 CB 27                           SLA     A
0793   E7E7 CB 27                           SLA     A
0794   E7E9 CB 27                           SLA     A
0795   E7EB             
0796   E7EB CB 27                           SLA     A
0797   E7ED CB 15                           RL      L
0798   E7EF CB 14                           RL      H
0799   E7F1 CB 27                           SLA     A
0800   E7F3 CB 15                           RL      L
0801   E7F5 CB 14                           RL      H
0802   E7F7 CB 27                           SLA     A
0803   E7F9 CB 15                           RL      L
0804   E7FB CB 14                           RL      H
0805   E7FD CB 27                           SLA     A
0806   E7FF CB 15                           RL      L
0807   E801 CB 14                           RL      H
0808   E803 22 35 E8                        LD      (hex_input_result), HL
0809   E806 C1                              POP     BC
0810   E807 10 C6                           DJNZ    _hi_loop
0811   E809 C9                              RET
0812   E80A             
0813   E80A 00          _hi_size            .DB     0
0814   E80B             
0815   E80B C1          _hi_delete          POP     BC
0816   E80C 3A 0A E8    _hi_delete_join     LD      A, (_hi_size)
0817   E80F B8                              CP      B
0818   E810 28 BD                           JR      Z, _hi_loop
0819   E812 04                              INC     B
0820   E813 C5                              PUSH    BC
0821   E814             
0822   E814 2A 35 E8                        LD      HL, (hex_input_result)
0823   E817 CB 3C                           SRL     H
0824   E819 CB 1D                           RR      L
0825   E81B CB 3C                           SRL     H
0826   E81D CB 1D                           RR      L
0827   E81F CB 3C                           SRL     H
0828   E821 CB 1D                           RR      L
0829   E823 CB 3C                           SRL     H
0830   E825 CB 1D                           RR      L
0831   E827 22 35 E8                        LD      (hex_input_result), HL
0832   E82A             
0833   E82A CD 9B F3                        CALL    m_print_inline
0834   E82D 1B 44 20 1B                     .DB     ESCAPE_CHAR, "D ", ESCAPE_CHAR, "D", 0
0834   E831 44 00 
0835   E833 18 9B                           JR      _hi_loop_join
0836   E835             
0837   E835 00 00       hex_input_result    .DW     0
0838   E837             
0839   E837             delete_or_enter     ; Wait for Delete or enter keys and handle..
0840   E837 CD 9A EF                        CALL    bios_conin
0841   E83A FE 0D                           CP      CARRIAGE_RETURN
0842   E83C C8                              RET     Z
0843   E83D 06 00                           LD      B, 0
0844   E83F FE 08                           CP      KEY_BACKSPACE
0845   E841 CC 0C E8                        CALL    Z, _hi_delete_join
0846   E844 18 F1                           JR      delete_or_enter
0847   E846             
0848   E846             
0849   E846             ;------------------------------------------------------
0850   E846             ; Menu system
0851   E846 00          menu_index          .DB     0
0852   E847 00 00       menu_address        .DW     0
0853   E849 00 00       menu_current        .DW     0
0854   E84B             
0855   E84B AF          start_menu          XOR    A
0856   E84C 32 46 E8                        LD     (menu_index), A
0857   E84F 22 47 E8                        LD     (menu_address), HL
0858   E852             
0859   E852 CD 92 E8    _menu_loop          CALL   _display_menu
0860   E855 01 58 02                        LD     BC, 600
0861   E858 CD 1A E9                        CALL   pause_for_ticks
0862   E85B CD 71 EF                        CALL   bios_conist
0863   E85E A7                              AND    A
0864   E85F C8                              RET    Z
0865   E860             
0866   E860 CD 9A EF    _menu_key           CALL   bios_conin
0867   E863 FE 81                           CP     KEY_DOWN
0868   E865 20 09                           JR     NZ, _menu_up
0869   E867             
0870   E867 3A 46 E8                        LD      A, (menu_index)
0871   E86A 3C                              INC     A
0872   E86B 32 46 E8    _menu_set_index     LD      (menu_index),A
0873   E86E 18 E2                           JR      _menu_loop
0874   E870             
0875   E870 FE 80       _menu_up            CP      KEY_UP
0876   E872 20 08                           JR      NZ, _menu_delete
0877   E874 3A 46 E8                        LD      A, (menu_index)
0878   E877 3D                              DEC     A
0879   E878 28 D8                           JR      Z, _menu_loop
0880   E87A 18 EF                           JR      _menu_set_index
0881   E87C             
0882   E87C FE 08       _menu_delete        CP      KEY_BACKSPACE
0883   E87E C8                              RET     Z
0884   E87F             
0885   E87F FE 0D       _menu_enter         CP      KEY_ENTER
0886   E881 20 CF                           JR      NZ, _menu_loop
0887   E883 3A 46 E8                        LD      A, (menu_index)
0888   E886 A7                              AND     A
0889   E887 28 C9                           JR      Z, _menu_loop
0890   E889 2A 49 E8                        LD      HL, (menu_current)
0891   E88C 7E                              LD      A, (HL)
0892   E88D 23                              INC     HL
0893   E88E 66                              LD      H, (HL)
0894   E88F 6F                              LD      L, A
0895   E890 E5                              PUSH    HL
0896   E891 C9                              RET
0897   E892             
0898   E892             
0899   E892             
0900   E892 0E 0D       _display_menu       LD      C, CARRIAGE_RETURN
0901   E894 CD 00 F0                        CALL    bios_conout
0902   E897             
0903   E897 3A 46 E8                        LD      A, (menu_index)
0904   E89A 2A 47 E8                        LD      HL, (menu_address)
0905   E89D A7          _entry_loop         AND     A
0906   E89E 28 12                           JR      Z, _display_entry
0907   E8A0 47                              LD      B, A
0908   E8A1 7E          _next_menu          LD      A, (HL)
0909   E8A2 23                              INC     HL
0910   E8A3 A7                              AND     A
0911   E8A4 20 FB                           JR      NZ, _next_menu
0912   E8A6             
0913   E8A6 22 49 E8                        LD      (menu_current), HL
0914   E8A9 7E                              LD      A, (HL)
0915   E8AA 23                              INC     HL
0916   E8AB 5E                              LD      E, (HL)
0917   E8AC 23                              INC     HL
0918   E8AD B3                              OR      E
0919   E8AE 28 19                           JR      Z, _menu_end
0920   E8B0 10 EF                           DJNZ    _next_menu
0921   E8B2                                 
0922   E8B2 7E          _display_entry      LD      A, (HL)
0923   E8B3 A7                              AND     A
0924   E8B4 28 09                           JR      Z, _entry_end
0925   E8B6 4F                              LD      C, A
0926   E8B7 E5                              PUSH    HL
0927   E8B8 CD 00 F0                        CALL    bios_conout
0928   E8BB E1                              POP     HL
0929   E8BC 23                              INC     HL
0930   E8BD 18 F3                           JR      _display_entry
0931   E8BF 0E 1B       _entry_end          LD      C, ESCAPE_CHAR
0932   E8C1 CD 00 F0                        CALL    bios_conout
0933   E8C4 0E 4B                           LD      C, 'K'
0934   E8C6 C3 00 F0                        JP      bios_conout
0935   E8C9             
0936   E8C9 3A 46 E8    _menu_end           LD      A, (menu_index)
0937   E8CC 3D                              DEC     A
0938   E8CD 32 46 E8                        LD      (menu_index), A
0939   E8D0 18 C0                           JR      _display_menu
0940   E8D2             
0941   E8D2             
0942   E8D2             ;------------------------------------------------------
0943   E8D2             ; Write the Hex value of DE as four characters to conout
0944   E8D2             ;
0945   E8D2 D5          hex_word            PUSH    DE
0946   E8D3 7A                              LD      A, D
0947   E8D4 CD D9 E8                        CALL    hex_out
0948   E8D7 D1                              POP     DE
0949   E8D8 7B                              LD      A, E                ; Fall into hex_out..
0950   E8D9             
0951   E8D9             ;------------------------------------------------------
0952   E8D9             ; Write the Hex value of A as two characters to conout
0953   E8D9             ;
0954   E8D9 4F          hex_out             LD      C, A
0955   E8DA CB 3F                           SRL     A
0956   E8DC CB 3F                           SRL     A
0957   E8DE CB 3F                           SRL     A
0958   E8E0 CB 3F                           SRL     A
0959   E8E2 C5                              PUSH    BC
0960   E8E3 CD E8 E8                        CALL    _nibble
0961   E8E6 C1                              POP     BC
0962   E8E7 79                              LD      A, C
0963   E8E8             
0964   E8E8 E6 0F       _nibble             AND     $0F      ;LOW NIBBLE ONLY
0965   E8EA C6 90                           ADD     A,$90
0966   E8EC 27                              DAA 
0967   E8ED CE 40                           ADC     A,$40
0968   E8EF 27                              DAA 
0969   E8F0 4F                              LD      C,A
0970   E8F1 C3 00 F0                        JP      bios_conout
0971   E8F4             
0972   E8F4             
0973   E8F4             ;------------------------------------------------------
0974   E8F4             ; Only accept hex characters (0-9, a-f), or DELETE from the input
0975   E8F4             ; Returns with character in A, a-f are capitalised
0976   E8F4             ;
0977   E8F4 CD 9A EF    hex_char_in         CALL    bios_conin
0978   E8F7 FE 08                           CP      KEY_BACKSPACE
0979   E8F9 C8                              RET     Z
0980   E8FA CD 00 E9                        CALL    valid_hex_char
0981   E8FD 38 F5                           JR      C, hex_char_in
0982   E8FF C9                              RET
0983   E900             ;
0984   E900             ; Return with carry CLEAR if the character is a valid hex digit
0985   E900             ; Enter with A = character to test
0986   E900             ; Returns with A capitalised
0987   E900 FE 30       valid_hex_char      CP      '0'
0988   E902 D8                              RET     C
0989   E903 FE 3A                           CP      ':'
0990   E905 3F                              CCF
0991   E906 D0                              RET     NC
0992   E907 FE 61                           CP      'a'
0993   E909 D8                              RET     C
0994   E90A FE 67                           CP      'g'
0995   E90C CB AF                           RES     5, a                ; Capitalise it..
0996   E90E 3F                              CCF
0997   E90F C9                              RET
0998   E910             
0999   E910 FE 41       hex_char_to_num     CP      'A'
1000   E912 30 03                           JR      NC, _alpha_char
1001   E914 D6 30                           SUB     '0'
1002   E916 C9                              RET
1003   E917 D6 37       _alpha_char         SUB     'A'-10
1004   E919 C9                              RET
1005   E91A             
1006   E91A             ;
1007   E91A             ; Pause for BC ticks
1008   E91A             ; Uses HL, DE
1009   E91A             ;
1010   E91A ED 5B 04 FF pause_for_ticks     LD      DE, (timer)
1011   E91E C5          _pause_loop         PUSH    BC
1012   E91F D5                              PUSH    DE
1013   E920 CD 71 EF                        CALL    bios_conist
1014   E923 D1                              POP     DE
1015   E924 C1                              POP     BC
1016   E925 A7                              AND     A
1017   E926 C0                              RET     NZ
1018   E927 2A 04 FF                        LD      HL, (timer)
1019   E92A ED 52                           SBC     HL, DE
1020   E92C ED 42                           SBC     HL, BC
1021   E92E 38 EE                           JR      C, _pause_loop
1022   E930 C9                              RET
1023   E931             ;
1024   E931             ; Detect (and time) interrupt
1025   E931             ; Enter with A containing the mask for which bits of the timer byte we check for zero
1026   E931             ; Return when the timer is zero, with BC containing 72 + 48*t-states taken
1027   E931             ;
1028   E931 01 00 00    detect_int          LD      BC, 0
1029   E934 57                              LD      D, A
1030   E935 3A 04 FF    _wait_for_tick      LD      A, (timer)               ; 13            ; Loop = 13+4+5+6+4+4+12 (=48) * BC + (13 + 4 + 11 + 13 + 4 + 17 + 10 (CALL)) = 72
1031   E938 A2                              AND     D                        ; 4
1032   E939 C8                              RET     Z                        ; 5 / 11
1033   E93A 03                              INC     BC                       ; 6
1034   E93B 79                              LD      A, C                     ; 4
1035   E93C B0                              OR      B                        ; 4
1036   E93D 20 F6                           JR      NZ, _wait_for_tick       ; 7 / 12
1037   E93F C9                              RET
1038   E940             ;
1039   E940             ; Fast int routine to allow us to time CPU speed
1040   E940             ;
1041   E940 F3          timer_int           DI
1042   E941 E5                              PUSH    HL
1043   E942 2A 04 FF                        LD      HL, (timer)
1044   E945 23                              INC     HL
1045   E946 22 04 FF                        LD      (timer), HL
1046   E949 E1                              POP     HL
1047   E94A FB                              EI
1048   E94B ED 4D                           RETI
1049   E94D             
1050   E94D             ; Divide HL by C (unsigned)
1051   E94D             ;Inputs:
1052   E94D             ;     HL is the numerator
1053   E94D             ;     C is the denominator
1054   E94D             ;Outputs:
1055   E94D             ;     A is the remainder
1056   E94D             ;     B is 0
1057   E94D             ;     C is not changed
1058   E94D             ;     DE is not changed
1059   E94D             ;     HL is the quotient
1060   E94D             ;
1061   E94D             divide_hl_c
1062   E94D 06 10                           LD      B, 16
1063   E94F AF                              XOR     A
1064   E950 29          _div0               ADD     HL, HL
1065   E951 17                              RLA
1066   E952 B9                              CP      C
1067   E953 38 02                           JR      C,_div1
1068   E955 2C                              INC     L
1069   E956 91                              SUB     C
1070   E957 10 F7       _div1               DJNZ    _div0
1071   E959 C9                              RET
1072   E95A             
1073   E95A             ;
1074   E95A             ; Convert DE to a five digit BCD value stored in bcd_scratch
1075   E95A             ; 
1076   E95A AF          de_to_bcd           XOR     A
1077   E95B 21 92 E9                        LD      HL, bcd_scratch
1078   E95E 06 05                           LD      B, 5
1079   E960 77          _clear_scratch      LD      (HL), A
1080   E961 23                              INC     HL
1081   E962 10 FC                           DJNZ    _clear_scratch
1082   E964                 
1083   E964 06 10                           LD      B, 16           ; Convert 16 bits
1084   E966 0E 05       _bcd_loop           LD      C, 5
1085   E968 21 92 E9                        LD      HL, bcd_scratch
1086   E96B 7E          _correct_digits     LD      A, (HL)
1087   E96C FE 05                           CP      5
1088   E96E 38 03                           JR      C, _digit_ok
1089   E970 C6 03                           ADD     A, 3
1090   E972 77                              LD      (HL), A
1091   E973 23          _digit_ok           INC     HL
1092   E974 0D                              DEC     C
1093   E975 20 F4                           JR      NZ, _correct_digits                   
1094   E977             
1095   E977 21 92 E9                        LD      HL, bcd_scratch
1096   E97A 0E 05                           LD      C, 5
1097   E97C CB 23                           SLA     E
1098   E97E CB 12                           RL      D
1099   E980             
1100   E980 7E          _shift_digits       LD      A, (HL)
1101   E981 CB 17                           RL      A
1102   E983 CB 67                           BIT     4, A
1103   E985 28 03                           JR      Z, _skip_carry
1104   E987 E6 0F                           AND     0Fh
1105   E989 37                              SCF
1106   E98A 77          _skip_carry         LD      (HL), A
1107   E98B 23                              INC     HL
1108   E98C 0D                              DEC     C
1109   E98D 20 F1                           JR      NZ, _shift_digits
1110   E98F 10 D5                           DJNZ    _bcd_loop
1111   E991 C9                              RET
1112   E992             
1113   E992 00 00 00 00 bcd_scratch         .DB      0,0,0,0,0      ; Five bytes - 0 to 99,999. Smallest digit (units) first
1113   E996 00 
1114   E997             
1115   E997                                 .INCLUDE  "monitor_rtc.asm"
0001+  E997             ;
0002+  E997             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0003+  E997             ;
0004+  E997             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0005+  E997             ;
0006+  E997             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0007+  E997             ; of this software and associated documentation files (the "Software"), to deal
0008+  E997             ; in the Software without restriction, including without limitation the rights
0009+  E997             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0010+  E997             ; copies of the Software, and to permit persons to whom the Software is
0011+  E997             ; furnished to do so, subject to the following conditions:
0012+  E997             ; 
0013+  E997             ; The above copyright notice and this permission notice shall be included in all
0014+  E997             ; copies or substantial portions of the Software.
0015+  E997             ; 
0016+  E997             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0017+  E997             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0018+  E997             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0019+  E997             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0020+  E997             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0021+  E997             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0022+  E997             ; SOFTWARE.
0023+  E997             ;
0024+  E997                                     .MODULE monitor_rtc
0025+  E997             
0026+  E997             _offset_sec             .EQU    0
0027+  E997             _offset_min             .EQU    1
0028+  E997             _offset_hour            .EQU    2
0029+  E997             _offset_wkday           .EQU    3
0030+  E997             _offset_date            .EQU    4
0031+  E997             _offset_month           .EQU    5
0032+  E997             _offset_year            .EQU    6
0033+  E997             
0034+  E997             
0035+  E997 CD 7C EA    rtc_display_time        CALL    rtc_get_time
0036+  E99A 0E 0D                               LD      C, CARRIAGE_RETURN
0037+  E99C CD 00 F0                            CALL    bios_conout
0038+  E99F                                     
0039+  E99F 3A CA FC                            LD      A, (time_scratch+_offset_wkday)
0040+  E9A2 21 30 EA                            LD      HL, weekdays
0041+  E9A5 E6 07                               AND     7
0042+  E9A7 4F                                  LD      C, A
0043+  E9A8             
0044+  E9A8 CD 1A EA                            CALL    _search_word
0045+  E9AB                                     
0046+  E9AB CD FB E9    _get_date               CALL    _space
0047+  E9AE 3A CB FC                            LD      A, (time_scratch+_offset_date)
0048+  E9B1 E6 3F                               AND     03Fh
0049+  E9B3 CD 00 EA                            CALL    _two_chars
0050+  E9B6 CD FB E9                            CALL    _space
0051+  E9B9             
0052+  E9B9 3A CC FC                            LD      A, (time_scratch+_offset_month)
0053+  E9BC 21 4C EA                            LD      HL, _months
0054+  E9BF E6 1F                               AND     01fh
0055+  E9C1 CB 67                               BIT     4, A
0056+  E9C3 28 02                               JR      Z, _month_ok
0057+  E9C5 D6 06                               SUB     6
0058+  E9C7 4F          _month_ok               LD      C,A
0059+  E9C8             
0060+  E9C8 CD 1A EA                            CALL    _search_word
0061+  E9CB CD FB E9                            CALL    _space
0062+  E9CE 3E 20                               LD      A, 20h
0063+  E9D0 CD 00 EA                            CALL    _two_chars
0064+  E9D3             
0065+  E9D3 3A CD FC                            LD      A, (time_scratch+_offset_year)
0066+  E9D6 CD 00 EA                            CALL    _two_chars
0067+  E9D9 CD FB E9                            CALL    _space
0068+  E9DC             
0069+  E9DC 3A C9 FC                            LD      A, (time_scratch+_offset_hour)
0070+  E9DF E6 3F                               AND     03fh
0071+  E9E1 CD 00 EA                            CALL    _two_chars
0072+  E9E4 CD FB E9                            CALL    _space
0073+  E9E7             
0074+  E9E7 3A C8 FC                            LD      A, (time_scratch+_offset_min)
0075+  E9EA E6 7F                               AND     07fh
0076+  E9EC CD 00 EA                            CALL    _two_chars
0077+  E9EF CD FB E9                            CALL    _space
0078+  E9F2             
0079+  E9F2 3A C7 FC                            LD      A, (time_scratch+_offset_sec)
0080+  E9F5 E6 7F                               AND     07fh
0081+  E9F7 CD 00 EA                            CALL    _two_chars
0082+  E9FA C9                                  RET
0083+  E9FB             
0084+  E9FB 0E 20       _space                  LD      C, ' '
0085+  E9FD C3 00 F0                            JP      bios_conout
0086+  EA00             
0087+  EA00 4F          _two_chars              LD      C,A
0088+  EA01 CB 3F                               SRL     A
0089+  EA03 CB 3F                               SRL     A
0090+  EA05 CB 3F                               SRL     A
0091+  EA07 CB 3F                               SRL     A
0092+  EA09 C6 30                               ADD     A, '0'
0093+  EA0B C5                                  PUSH    BC
0094+  EA0C 4F                                  LD      C, A
0095+  EA0D CD 00 F0                            CALL    bios_conout
0096+  EA10 C1                                  POP     BC
0097+  EA11 79                                  LD      A,C
0098+  EA12 E6 0F                               AND     0fh
0099+  EA14 C6 30                               ADD     A, '0'
0100+  EA16 4F                                  LD      C, A
0101+  EA17 C3 00 F0                            JP      bios_conout
0102+  EA1A             ;
0103+  EA1A             ; Search table pointed to by HL for the C'th word (1-based)
0104+  EA1A             ; Prints the chosen word to conout
0105+  EA1A             ;
0106+  EA1A 0D          _search_word            DEC     C
0107+  EA1B 20 0C                               JR      NZ, _next_char
0108+  EA1D                                     
0109+  EA1D 7E          _print_word             LD      A, (HL)
0110+  EA1E 23                                  INC     HL
0111+  EA1F A7                                  AND     A
0112+  EA20 C8                                  RET     Z
0113+  EA21 4F                                  LD      C, A
0114+  EA22 E5                                  PUSH    HL
0115+  EA23 CD 00 F0                            CALL    bios_conout
0116+  EA26 E1                                  POP     HL
0117+  EA27 18 F4                               JR      _print_word
0118+  EA29             
0119+  EA29 7E          _next_char              LD      A, (HL)
0120+  EA2A 23                                  INC     HL
0121+  EA2B A7                                  AND     A
0122+  EA2C 20 FB                               JR      NZ, _next_char
0123+  EA2E 18 EA                               JR      _search_word
0124+  EA30             
0125+  EA30             
0126+  EA30 4D 6F 6E 00 weekdays                .DB "Mon",0
0127+  EA34 54 75 65 00                         .DB "Tue",0
0128+  EA38 57 65 64 00                         .DB "Wed",0
0129+  EA3C 54 68 75 00                         .DB "Thu",0
0130+  EA40 46 72 69 00                         .DB "Fri",0
0131+  EA44 53 61 74 00                         .DB "Sat",0
0132+  EA48 53 75 6E 00                         .DB "Sun",0
0133+  EA4C             
0134+  EA4C 4A 61 6E 00 _months                 .DB "Jan",0
0135+  EA50 46 65 62 00                         .DB "Feb",0
0136+  EA54 4D 61 72 00                         .DB "Mar",0
0137+  EA58 41 70 72 00                         .DB "Apr",0
0138+  EA5C 4D 61 79 00                         .DB "May",0
0139+  EA60 4A 75 6E 00                         .DB "Jun",0
0140+  EA64 4A 75 6C 00                         .DB "Jul",0
0141+  EA68 41 75 67 00                         .DB "Aug",0
0142+  EA6C 53 65 70 00                         .DB "Sep",0
0143+  EA70 4F 63 74 00                         .DB "Oct",0
0144+  EA74 4E 6F 76 00                         .DB "Nov",0
0145+  EA78 44 65 63 00                         .DB "Dec",0
0146+  EA7C             
0147+  EA7C             ;
0148+  EA7C             ; Read the time into the temp_data area
0149+  EA7C             ; Returns with Carry SET if successful, else Carry CLEAR
0150+  EA7C             ;
0151+  EA7C 26 6F       rtc_get_time            LD      H, RTC_ADDRESS
0152+  EA7E 2E 00                               LD      L, RTC_REG_SEC
0153+  EA80 CD DD F8                            CALL    i2c_read_from
0154+  EA83 30 18                               JR      NC, _get_error
0155+  EA85 21 C7 FC                            LD      HL, time_scratch
0156+  EA88 06 07                               LD      B, 7
0157+  EA8A 18 08                               JR      _store_time
0158+  EA8C C5          _get_loop               PUSH    BC 
0159+  EA8D CD 32 F9                            CALL    i2c_ack
0160+  EA90 CD 1F F9                            CALL    i2c_read
0161+  EA93 C1                                  POP     BC
0162+  EA94 77          _store_time             LD      (HL), A
0163+  EA95 23                                  INC     HL
0164+  EA96 10 F4                               DJNZ    _get_loop
0165+  EA98 CD D4 F8                            CALL    i2c_stop
0166+  EA9B 37                                  SCF
0167+  EA9C C9                                  RET
0168+  EA9D             
0169+  EA9D CD D4 F8    _get_error              CALL    i2c_stop
0170+  EAA0 CD 9B F3                            CALL    m_print_inline 
0171+  EAA3 45 72 72 6F                         .DB     "Error getting time\r\n", 0
0171+  EAA7 72 20 67 65 
0171+  EAAB 74 74 69 6E 
0171+  EAAF 67 20 74 69 
0171+  EAB3 6D 65 0D 0A 
0171+  EAB7 00 
0172+  EAB8 AF                                  XOR     A
0173+  EAB9 C9                                  RET
0174+  EABA             
0175+  EABA                                     .MODULE main1116   EABA                                 .INCLUDE "ymodem.asm"
0001+  EABA             ;
0002+  EABA             ; YModem implementation.
0003+  EABA             ; File format: The filename MAY indicate the load address in memory for the file. If so, the format is:
0004+  EABA             ;       filename_mHHHH.suffix
0005+  EABA             ;    or filename_pHH.suffix
0006+  EABA             ;
0007+  EABA             ; Where:  _mHHHH indicates a preferred destination address of HHHH (in memory) - four digits hexadecimal value (uppercase).
0008+  EABA             ;   or    _pHH   indicates the page in memory that the file is intended for (assumes start at offset 0 in page..)
0009+  EABA             ;
0010+  EABA             ; When _p is used, the file is always written to bank 1 - address 4000h. It is expected that the calling program will
0011+  EABA             ; then copy the data to the target page, which can be retrieved from the ym_file_mode return value.
0012+  EABA             ; 
0013+  EABA             ;
0014+  EABA             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0015+  EABA             ;
0016+  EABA             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0017+  EABA             ;
0018+  EABA             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0019+  EABA             ; of this software and associated documentation files (the "Software"), to deal
0020+  EABA             ; in the Software without restriction, including without limitation the rights
0021+  EABA             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0022+  EABA             ; copies of the Software, and to permit persons to whom the Software is
0023+  EABA             ; furnished to do so, subject to the following conditions:
0024+  EABA             ; 
0025+  EABA             ; The above copyright notice and this permission notice shall be included in all
0026+  EABA             ; copies or substantial portions of the Software.
0027+  EABA             ; 
0028+  EABA             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0029+  EABA             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0030+  EABA             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0031+  EABA             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0032+  EABA             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0033+  EABA             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0034+  EABA             ; SOFTWARE.
0035+  EABA             ;
0036+  EABA             
0037+  EABA                                 .MODULE ymodem
0038+  EABA             
0039+  EABA             _PAGE_PREFIX        .EQU    'p'
0040+  EABA             _DEST_PREFIX        .EQU    'm'
0041+  EABA             
0042+  EABA             ; Return values
0043+  EABA             YMODEM_SUCCESS      .EQU    000h
0044+  EABA             YMODEM_TIMEOUT      .EQU    001h
0045+  EABA             YMODEM_UNKNOWN      .EQU    002h            ; Unknown packet type (Packet byte in C)
0046+  EABA             YMODEM_CANCEL       .EQU    003h            ; Cancelled by sender
0047+  EABA             YMODEM_PACKET_ERROR .EQU    004h            ; Packet data error (Error code in C)
0048+  EABA             YMODEM_LENGTH_ERROR .EQU    005h            ; Length data in zeroth packet is invalid
0049+  EABA             YMODEM_NO_DEST      .EQU    006h            ; No destination provided
0050+  EABA             YMODEM_SEND_TIMEOUT .EQU    007h
0051+  EABA             YMODEM_MULTI_FILES  .EQU    008h            ; Cannot receive more than one file 
0052+  EABA             
0053+  EABA             _SOH                .EQU    001h            ; 128 byte data packet header
0054+  EABA             _STX                .EQU    002h            ; 1024 byte data packet header
0055+  EABA             _EOT                .EQU    004h            ; End transfer
0056+  EABA             _ACK                .EQU    006h            ; Respond
0057+  EABA             _NAK                .EQU    015h            ; No response
0058+  EABA             _CAN                .EQU    018h            ; Transmission aborted
0059+  EABA             _C                  .EQU    043h            ; Request packet
0060+  EABA             
0061+  EABA             _SOH_PACKET_SIZE    .EQU    128
0062+  EABA             _STX_PACKET_SIZE    .EQU    1024
0063+  EABA             _FRAME_OVERHEAD     .EQU    5               ; Three byte header + two byte CRC (high byte first)
0064+  EABA             
0065+  EABA             _TIMEOUT_COUNT      .EQU    50000
0066+  EABA             
0067+  EABA             _ERR_PACKET_COUNT   .EQU    1               ; Wrong packet index
0068+  EABA             _ERR_CHECK_HIGH     .EQU    2               ; High byte of CRC failed
0069+  EABA             _ERR_CHECK_LOW      .EQU    3               ; Low byte of CRC failed
0070+  EABA             _ERR_CANCEL         .EQU    4               ; Got a cancel request without second cancel
0071+  EABA             _ERR_ZERO_PACKET    .EQU    5               ; Zeroth packet must be SOH
0072+  EABA             
0073+  EABA             YM_DEST_FROM_FILE   .EQU    0FEh            ; File destination set from filename
0074+  EABA             
0075+  EABA             ymodem_data_length  .EQU    17              ; Size of data block before buffer
0076+  EABA             
0077+  EABA             ym_file_mode        .EQU    -17             ; FFh : Normal transfer,  FEh : Destination set by file, 0-7Fh : Page write 
0078+  EABA             ym_file_count       .EQU    -16
0079+  EABA             ym_length_low       .EQU    -15             ; Length specified in header packet
0080+  EABA             ym_length_mid       .EQU    -14
0081+  EABA             ym_length_high      .EQU    -13
0082+  EABA             ym_loaded_high      .EQU    -12             ; Tracks high byte of length during load.
0083+  EABA             ym_soh_saved_len    .EQU    -11             ; We have to copy part of a final SOH packet from the buffer - track actual length needed
0084+  EABA             ym_soh_saved_len_h  .EQU    -10 
0085+  EABA             ym_current_page     .EQU    -9              ; FFh if no paging, otherwise page to send data to
0086+  EABA             ym_dest_low         .EQU    -8              ; If specified in file header - the destination address of the file
0087+  EABA             ym_dest_high        .EQU    -7
0088+  EABA             ym_current_packet   .EQU    -6              ; Expected packet number
0089+  EABA             ym_packet_type      .EQU    -5              ; Packet type - SOH/STX
0090+  EABA             ym_packet_num       .EQU    -4              ; Packet number we're currently receiving
0091+  EABA             ym_packet_num_cpl   .EQU    -3              ; Complement..
0092+  EABA             ym_crc_low          .EQU    -2              ; CRC Low byte
0093+  EABA             ym_crc_high         .EQU    -1              ; CRC High byte
0094+  EABA             
0095+  EABA             YMODEM_BUFFER       .EQU    _SOH_PACKET_SIZE + ymodem_data_length
0096+  EABA             YMODEM_INFO         .EQU    _SOH_PACKET_SIZE
0097+  EABA             
0098+  EABA             ;
0099+  EABA             ; ymodem - Main entry point. Call with:
0100+  EABA             ;     HL = Address of YMODEM_BUFFER (=128 + ymodem_data_length) byte buffer for receiving data
0101+  EABA             ;     DE = (Optional) address to write data. 0xFFFF to accept destination from filename otherwise
0102+  EABA             ;      A = Page to write data. 0xFF to disable paging/accept page from filename otherwise
0103+  EABA             ;
0104+  EABA             ; If using A to set a Page destination, DE should be an offset within Bank 1 (ie 4000h - 7FFFh)
0105+  EABA             ; If the file specifies a page destination, DE is initialised to 4000h - the start of the page
0106+  EABA             ;
0107+  EABA             ; Returns status code in A:
0108+  EABA             ;     YMODEM_SUCCESS : (=0) If the file was successfully received
0109+  EABA             ;     YMODEM_xxxx    : (Non zero) If the receiver timed out waiting for a byte
0110+  EABA             ;
0111+  EABA             ; Note Bank 1 may have been set to a new page destination if one was specified.
0112+  EABA             
0113+  EABA 01 11 00    ymodem              LD      BC, ymodem_data_length      ; Skip data block at start of buffer
0114+  EABD 09                              ADD     HL, BC
0115+  EABE E5                              PUSH    HL
0116+  EABF DD E1                           POP     IX
0117+  EAC1 DD 77 F7                        LD      (IX+ym_current_page), A
0118+  EAC4 DD 77 EF                        LD      (IX+ym_file_mode), A           ; Default normal transfer, 0FFh, else page 
0119+  EAC7 AF                              XOR     A                           
0120+  EAC8 DD 77 F0                        LD      (IX+ym_file_count), A
0121+  EACB 3D                              DEC     A
0122+  EACC DD 73 F8                        LD      (IX+ym_dest_low), E
0123+  EACF DD 72 F9                        LD      (IX+ym_dest_high), D
0124+  EAD2             
0125+  EAD2 AF          _ymodem_start       XOR     A                           ; Set initial packet number
0126+  EAD3 DD 77 FA                        LD      (IX+ym_current_packet), A
0127+  EAD6 FD 21 FF FF                     LD      IY, 0FFFFh                  ; IY - bytes to load. Default - load all bytes
0128+  EADA             
0129+  EADA                                 ; Now we can load.
0130+  EADA                                 ; DE = destination
0131+  EADA                                 ; IY = low 16 bits of length
0132+  EADA                                 ; IX = load buffer
0133+  EADA             
0134+  EADA CD 67 ED    _packet_loop        CALL    _recieve_safe
0135+  EADD 20 07                           JR      NZ, _packet_byte
0136+  EADF 3E 43       _send_crc_and_loop  LD      A, _C
0137+  EAE1 CD 92 ED                        CALL    _send_byte
0138+  EAE4 18 F4                           JR      _packet_loop
0139+  EAE6             
0140+  EAE6 FE 01       _packet_byte        CP      _SOH
0141+  EAE8 C2 F3 EA                        JP      NZ, _check_stx
0142+  EAEB             
0143+  EAEB DD E5                           PUSH    IX                          ; SOH - May be zero'th or last packet
0144+  EAED E1                              POP     HL
0145+  EAEE 01 80 00                        LD      BC, _SOH_PACKET_SIZE
0146+  EAF1 18 40                           JR      _receive_packet
0147+  EAF3             
0148+  EAF3 FE 02       _check_stx          CP      _STX
0149+  EAF5 20 07                           JR      NZ, _check_eot
0150+  EAF7                                                                     
0151+  EAF7 62                              LD      H, D                        ; STX packets go straight to DE
0152+  EAF8 6B                              LD      L, E
0153+  EAF9 01 00 04                        LD      BC, _STX_PACKET_SIZE    
0154+  EAFC 18 35                           JR      _receive_packet
0155+  EAFE             
0156+  EAFE FE 04       _check_eot          CP      _EOT
0157+  EB00 20 0A                           JR      NZ, _check_can
0158+  EB02                                                                     ; End of transmission
0159+  EB02 3E 06                           LD      A, _ACK 
0160+  EB04 CD 92 ED                        CALL    _send_byte
0161+  EB07             
0162+  EB07 DD 34 F0                        INC     (IX+ym_file_count)      
0163+  EB0A 18 C6                           JR      _ymodem_start  
0164+  EB0C             
0165+  EB0C FE 18       _check_can          CP      _CAN
0166+  EB0E 20 1E                           JR      NZ, _unknown_packet
0167+  EB10                                                                     ; Single cancel request. Check for another
0168+  EB10 CD 72 ED                        CALL    _receive_byte
0169+  EB13 FE 18                           CP      _CAN
0170+  EB15 3E 04                           LD      A, _ERR_CANCEL
0171+  EB17 20 10                           JR      NZ, _packet_error
0172+  EB19             
0173+  EB19 3E 06                           LD      A, _ACK 
0174+  EB1B CD 92 ED                        CALL    _send_byte
0175+  EB1E CD 67 ED    _purge              CALL    _recieve_safe               ; Purge remains of any cancel request
0176+  EB21 20 FB                           JR      NZ, _purge
0177+  EB23             
0178+  EB23 3E 03                           LD      A, YMODEM_CANCEL
0179+  EB25 A7                              AND     A
0180+  EB26 C9                              RET
0181+  EB27             
0182+  EB27 3E 05       _zero_error         LD      A, _ERR_ZERO_PACKET
0183+  EB29 4F          _packet_error       LD      C, A                        ; Packet data error - return error code in C
0184+  EB2A 3E 04                           LD      A, YMODEM_PACKET_ERROR
0185+  EB2C A7                              AND     A
0186+  EB2D C9                              RET
0187+  EB2E             
0188+  EB2E 4F          _unknown_packet     LD      C, A                        ; Unknown packet type - return header byte in C
0189+  EB2F 3E 02                           LD      A, YMODEM_UNKNOWN
0190+  EB31 A7                              AND     A
0191+  EB32 C9                              RET     
0192+  EB33             
0193+  EB33             ; Receive data for both SOH and STX packets..
0194+  EB33             ; At this point HL is destination (either DE or IX-buffer), and BC is a byte count
0195+  EB33             ;
0196+  EB33 DD 77 FB    _receive_packet     LD      (IX+ym_packet_type), A   
0197+  EB36             
0198+  EB36 DD 7E F7                        LD      A, (IX+ym_current_page)
0199+  EB39 FE FF                           CP      0FFh
0200+  EB3B 28 02                           JR      Z, _no_page_specified
0201+  EB3D D3 71                           OUT     (IO_MEM_1), A
0202+  EB3F             
0203+  EB3F AF          _no_page_specified  XOR     A
0204+  EB40 DD 77 F5                        LD      (IX+ym_soh_saved_len), A     ; Reset how many bytes of an SOH packet we actually loaded..
0205+  EB43 DD 77 F6                        LD      (IX+ym_soh_saved_len_h), A
0206+  EB46             
0207+  EB46 DD BE FA                        CP      (IX+ym_current_packet)         ; If this is the zeroth packet, it must be SOH
0208+  EB49 20 07                           JR      NZ, _not_zeroth_packet
0209+  EB4B 3E 01                           LD      A, _SOH
0210+  EB4D DD 96 FB                        SUB     (IX+ym_packet_type)            ; Leave A as zero if this is OK
0211+  EB50 20 D5                           JR      NZ, _zero_error
0212+  EB52             
0213+  EB52 DD 77 FF    _not_zeroth_packet  LD      (IX+ym_crc_high), A
0214+  EB55 DD 77 FE                        LD      (IX+ym_crc_low), A
0215+  EB58             
0216+  EB58 CD 72 ED                        CALL    _receive_byte   
0217+  EB5B DD 77 FC                        LD      (IX+ym_packet_num), A
0218+  EB5E CD 72 ED                        CALL    _receive_byte   
0219+  EB61 DD 77 FD                        LD      (IX+ym_packet_num_cpl), A
0220+  EB64             
0221+  EB64 7D          _data_loop          LD      A, L                        ; Handle paging if we're loading into paged memory..
0222+  EB65 A7                              AND     A
0223+  EB66 20 12                           JR      NZ, _data_receive
0224+  EB68 7C                              LD      A, H
0225+  EB69 FE 80                           CP      80h
0226+  EB6B 20 0D                           JR      NZ, _data_receive
0227+  EB6D DD 7E F7                        LD      A, (IX+ym_current_page)
0228+  EB70 3C                              INC     A
0229+  EB71 28 07                           JR      Z, _data_receive           ; Paging disabled
0230+  EB73             
0231+  EB73 DD 77 F7                        LD      (IX+ym_current_page), A        ; Move to next page
0232+  EB76 D3 71                           OUT     (IO_MEM_1), A
0233+  EB78 26 40                           LD      H, 40h
0234+  EB7A                                 
0235+  EB7A CD 72 ED    _data_receive       CALL    _receive_byte
0236+  EB7D             
0237+  EB7D 77                              LD      (HL), A
0238+  EB7E             
0239+  EB7E CD 34 ED                        CALL    _calc_checksum  
0240+  EB81             
0241+  EB81 C5                              PUSH    BC                          ; Count down the bytes remaining, and once we get to zero, send bytes to _dev_null
0242+  EB82 01 FF FF                        LD      BC, -1
0243+  EB85 FD 09                           ADD     IY, BC                      ; Carry set if IY not zero
0244+  EB87 C1                              POP     BC
0245+  EB88 38 10                           JR      C, _in_range
0246+  EB8A             
0247+  EB8A DD 35 F4                        DEC     (IX+ym_loaded_high)
0248+  EB8D F2 9A EB                        JP      P, _in_range
0249+  EB90                  
0250+  EB90 DD 34 F4                        INC     (IX+ym_loaded_high)      ; Keep resetting counter...
0251+  EB93 FD 23                           INC     IY
0252+  EB95 21 66 ED                        LD      HL, _dev_null
0253+  EB98 18 09                           JR      _do_next
0254+  EB9A             
0255+  EB9A DD 34 F5    _in_range           INC     (IX+ym_soh_saved_len)
0256+  EB9D 20 03                           JR      NZ, _packet_part_ok
0257+  EB9F DD 34 F6                        INC     (IX+ym_soh_saved_len_h)
0258+  EBA2 23          _packet_part_ok     INC     HL
0259+  EBA3             
0260+  EBA3 0B          _do_next            DEC     BC
0261+  EBA4             
0262+  EBA4 78                              LD      A, B
0263+  EBA5 B1                              OR      C
0264+  EBA6 20 BC                           JR      NZ, _data_loop
0265+  EBA8             
0266+  EBA8 AF                              XOR     A
0267+  EBA9 CD 34 ED                        CALL    _calc_checksum  
0268+  EBAC AF                              XOR     A
0269+  EBAD CD 34 ED                        CALL    _calc_checksum  
0270+  EBB0             
0271+  EBB0 CD 72 ED                        CALL    _receive_byte
0272+  EBB3 47                              LD      B, A
0273+  EBB4 CD 72 ED                        CALL    _receive_byte   
0274+  EBB7 4F                              LD      C, A
0275+  EBB8             ;
0276+  EBB8             ; Now do checks...
0277+  EBB8             
0278+  EBB8 DD 7E FC                        LD      A, (IX+ym_packet_num)
0279+  EBBB 2F                              CPL
0280+  EBBC DD BE FD                        CP      (IX+ym_packet_num_cpl)
0281+  EBBF 3E 01                           LD      A, _ERR_PACKET_COUNT
0282+  EBC1 C2 29 EB                        JP      NZ, _packet_error
0283+  EBC4 DD 7E FF                        LD      A, (IX+ym_crc_high)
0284+  EBC7 B8                              CP      B
0285+  EBC8 3E 02                           LD      A, _ERR_CHECK_HIGH
0286+  EBCA C2 29 EB                        JP      NZ, _packet_error
0287+  EBCD DD 7E FE                        LD      A, (IX+ym_crc_low)
0288+  EBD0 B9                              CP      C
0289+  EBD1 3E 03                           LD      A, _ERR_CHECK_LOW
0290+  EBD3 C2 29 EB                        JP      NZ, _packet_error
0291+  EBD6             
0292+  EBD6             ; CRC and packet number check out... 
0293+  EBD6 DD 7E FC                        LD      A, (IX+ym_packet_num)
0294+  EBD9 DD BE FA                        CP      (IX+ym_current_packet)
0295+  EBDC 20 23                           JR      NZ, _retry_packet               ; We need to restore IY (length) if we wish to survive.. DE is not updated until later, so OK
0296+  EBDE DD 34 FA                        INC     (IX+ym_current_packet)
0297+  EBE1 A7                              AND     A
0298+  EBE2 28 4A                           JR      Z, _header_packet
0299+  EBE4             
0300+  EBE4 DD 7E FB                        LD      A, (IX+ym_packet_type)
0301+  EBE7 FE 01                           CP      _SOH
0302+  EBE9 20 0C                           JR      NZ, _not_soh
0303+  EBEB             
0304+  EBEB             ; SOH packets must be copied to DE -> 
0305+  EBEB DD 4E F5                        LD      C, (IX+ym_soh_saved_len)
0306+  EBEE 06 00                           LD      B, 0
0307+  EBF0 DD E5                           PUSH    IX
0308+  EBF2 E1                              POP     HL
0309+  EBF3 ED B0                           LDIR
0310+  EBF5 18 02                           JR      _send_ack
0311+  EBF7             
0312+  EBF7 54          _not_soh            LD      D, H
0313+  EBF8 5D                              LD      E, L
0314+  EBF9 3E 06       _send_ack           LD      A, _ACK 
0315+  EBFB CD 92 ED    _send_and_loop      CALL    _send_byte
0316+  EBFE C3 DF EA                        JP      _send_crc_and_loop      
0317+  EC01             
0318+  EC01 AF          _retry_packet       XOR     A                           ; Clear carry
0319+  EC02 ED 52                           SBC     HL, DE
0320+  EC04 30 0D                           JR      NC, _retry_page_ok          
0321+  EC06             
0322+  EC06 DD 7E F7                        LD      A,(IX+ym_current_page)         ; If HL (latest write dest) is less than DE (write dest at start of packet) assume we've changed pages..
0323+  EC09 FE FF                           CP      0FFH
0324+  EC0B 28 06                           JR      Z, _retry_page_ok           ; We're not paging anyway...
0325+  EC0D 3D                              DEC     A 
0326+  EC0E DD 77 F7                        LD      (IX+ym_current_page), A
0327+  EC11 D3 71                           OUT     (IO_MEM_1),A
0328+  EC13             
0329+  EC13 DD 4E F5    _retry_page_ok      LD      C, (IX+ym_soh_saved_len)     ; Restore IY (length)
0330+  EC16 DD 46 F6                        LD      B, (IX+ym_soh_saved_len_h)
0331+  EC19 FD E5                           PUSH    IY
0332+  EC1B E1                              POP     HL
0333+  EC1C 09                              ADD     HL, BC
0334+  EC1D 30 03                           JR      NC, _retry_iy_ok
0335+  EC1F DD 34 F4                        INC     (IX+ym_loaded_high)
0336+  EC22 E5          _retry_iy_ok        PUSH    HL
0337+  EC23 FD E1                           POP     IY
0338+  EC25                                                                     ; TODO: If we've changed the page, that needs to be restored as well
0339+  EC25             
0340+  EC25             
0341+  EC25 CD 67 ED    _retry_drain        CALL   _recieve_safe                ; Drain the incoming stream before sending nak
0342+  EC28 20 FB                           JR      NZ, _retry_drain
0343+  EC2A             
0344+  EC2A 3E 15                           LD      A, _NAK
0345+  EC2C 18 CD                           JR      _send_and_loop
0346+  EC2E             
0347+  EC2E             
0348+  EC2E DD E5       _header_packet      PUSH    IX
0349+  EC30 E1                              POP     HL
0350+  EC31 7E                              LD      A, (HL)                     ; Empty zeroth packet means end of batch send
0351+  EC32 A7                              AND     A
0352+  EC33 20 09                           JR      NZ, _check_filecount
0353+  EC35             
0354+  EC35 3E 06                           LD      A, _ACK 
0355+  EC37 CD 92 ED                        CALL    _send_byte
0356+  EC3A 3E 00                           LD      A, YMODEM_SUCCESS   
0357+  EC3C A7                              AND     A
0358+  EC3D C9                              RET
0359+  EC3E             
0360+  EC3E DD 7E F0    _check_filecount    LD      A, (IX+ym_file_count)
0361+  EC41 A7                              AND     A
0362+  EC42 28 04                           JR      Z, _next_filechar
0363+  EC44             
0364+  EC44 3E 08                           LD      A, YMODEM_MULTI_FILES
0365+  EC46 A7                              AND     A
0366+  EC47 C9                              RET
0367+  EC48             
0368+  EC48 7E          _next_filechar      LD      A, (HL)
0369+  EC49 23                              INC     HL
0370+  EC4A A7          _check_char         AND     A
0371+  EC4B 28 71                           JR      Z, _read_length
0372+  EC4D FE 5F                           CP      '_'                     ; Check for special transfer modes
0373+  EC4F 20 F7                           JR      NZ, _next_filechar
0374+  EC51 7E                              LD      A, (HL)
0375+  EC52 4F                              LD      C, A                    ; Remember the prefix char in C
0376+  EC53 23                              INC     HL
0377+  EC54 FE 6D                           CP      _DEST_PREFIX
0378+  EC56 20 07                           JR      NZ, _check_flash
0379+  EC58 06 04                           LD      B, 4
0380+  EC5A 11 00 00                        LD      DE, 0
0381+  EC5D 18 09                           JR      _parse_dest
0382+  EC5F             
0383+  EC5F FE 70       _check_flash        CP      _PAGE_PREFIX
0384+  EC61 20 E7                           JR      NZ, _check_char
0385+  EC63 06 02                           LD      B, 2
0386+  EC65 11 00 00                        LD      DE, 0
0387+  EC68             
0388+  EC68 7E          _parse_dest         LD      A, (HL)
0389+  EC69 23                              INC     HL
0390+  EC6A D6 30                           SUB     '0'
0391+  EC6C 38 48                           JR      C, _invalid_dest
0392+  EC6E FE 0A                           CP      10
0393+  EC70 38 08                           JR      C, _digit_checked
0394+  EC72 D6 07                           SUB     7
0395+  EC74 38 40                           JR      C, _invalid_dest
0396+  EC76 FE 10                           CP      16
0397+  EC78 30 3C                           JR      NC, _invalid_dest
0398+  EC7A             
0399+  EC7A E5          _digit_checked      PUSH    HL                          ; Shift existing dest left 4 bits and merge new hex digit
0400+  EC7B 62                              LD      H, D
0401+  EC7C 6B                              LD      L, E
0402+  EC7D 29                              ADD     HL, HL
0403+  EC7E 29                              ADD     HL, HL
0404+  EC7F 29                              ADD     HL, HL
0405+  EC80 29                              ADD     HL, HL
0406+  EC81 B5                              OR      L
0407+  EC82 54                              LD      D, H
0408+  EC83 5F                              LD      E, A
0409+  EC84 E1                              POP     HL
0410+  EC85 10 E1                           DJNZ    _parse_dest
0411+  EC87             
0412+  EC87 79                              LD      A, C                        ; Which char did we start with?
0413+  EC88 FE 70                           CP      _PAGE_PREFIX
0414+  EC8A 20 12                           JR      NZ, _memory_dest
0415+  EC8C             
0416+  EC8C DD 7E F7                        LD      A, (IX+ym_current_page)        ; Page prefix. Use original value if set when ymodem was called
0417+  EC8F FE FF                           CP      0FFh
0418+  EC91 20 B5                           JR      NZ, _next_filechar
0419+  EC93             
0420+  EC93 DD 73 EF                        LD      (IX+ym_file_mode), E           ; Otherwise use the file specified value and load from 4000h
0421+  EC96 DD 73 F7                        LD      (IX+ym_current_page), E
0422+  EC99 11 00 40                        LD      DE,04000h    
0423+  EC9C 18 10                           JR      _store_dest
0424+  EC9E             
0425+  EC9E 3E FF       _memory_dest        LD      A, 0FFh                     ; Only set the dest from the filename if 
0426+  ECA0 DD BE F8                        CP      (IX+ym_dest_low)               ; the routine was called with a destination of 0FFFFh
0427+  ECA3 20 A3                           JR      NZ, _next_filechar
0428+  ECA5 DD BE F9                        CP      (IX+ym_dest_high)
0429+  ECA8 20 9E                           JR      NZ, _next_filechar
0430+  ECAA             
0431+  ECAA DD 36 EF FE                     LD      (IX+ym_file_mode), YM_DEST_FROM_FILE
0432+  ECAE             
0433+  ECAE DD 73 F8    _store_dest         LD      (IX+ym_dest_low), E
0434+  ECB1 DD 72 F9                        LD      (IX+ym_dest_high), D
0435+  ECB4             
0436+  ECB4 18 92                           JR      _next_filechar
0437+  ECB6             
0438+  ECB6 DD 5E F8    _invalid_dest       LD      E, (IX+ym_dest_low)            ; We silently skip invalid destination values
0439+  ECB9 DD 56 F9                        LD      D, (IX+ym_dest_high)
0440+  ECBC 18 8A                           JR      _next_filechar
0441+  ECBE             
0442+  ECBE 3E FF       _read_length        LD      A, 0FFh                     ; At this point we should have a valid destination
0443+  ECC0 DD BE F8                        CP      (IX+ym_dest_low)               
0444+  ECC3 20 09                           JR      NZ, _dest_ok
0445+  ECC5 DD BE F9                        CP      (IX+ym_dest_high)
0446+  ECC8 20 04                           JR      NZ, _dest_ok
0447+  ECCA             
0448+  ECCA 3E 06                           LD      A, YMODEM_NO_DEST
0449+  ECCC A7                              AND     A
0450+  ECCD C9                              RET
0451+  ECCE             
0452+  ECCE 3E FF       _dest_ok            LD      A, 0FFh
0453+  ECD0 DD 77 F1                        LD      (IX+ym_length_low), A       ; Reset the length counter///
0454+  ECD3 DD 77 F2                        LD      (IX+ym_length_mid), A
0455+  ECD6 DD 77 F3                        LD      (IX+ym_length_high), A         
0456+  ECD9 DD 77 F4                        LD      (IX+ym_loaded_high), A
0457+  ECDC FD 21 FF FF                     LD      IY, 0FFFFh 
0458+  ECE0 44                              LD      B, H
0459+  ECE1 4D                              LD      C, L               
0460+  ECE2 21 00 00                        LD      HL, 0
0461+  ECE5 0A                              LD      A, (BC)                     ; Length is optional
0462+  ECE6 A7                              AND     A
0463+  ECE7 CA F9 EB                        JP      Z, _send_ack
0464+  ECEA             
0465+  ECEA 0A          _parse_length       LD      A, (BC)
0466+  ECEB 03                              INC     BC
0467+  ECEC A7                              AND     A
0468+  ECED 28 2F                           JR      Z, _length_end
0469+  ECEF FE 20                           CP      ' '
0470+  ECF1 28 2B                           JR      Z, _length_end
0471+  ECF3 D6 30                           SUB     '0'
0472+  ECF5 38 39                           JR      C, _invalid_length
0473+  ECF7 FE 0A                           CP      10
0474+  ECF9 30 35                           JR      NC, _invalid_length
0475+  ECFB             
0476+  ECFB C5                              PUSH    BC
0477+  ECFC D5                              PUSH    DE
0478+  ECFD F5                              PUSH    AF
0479+  ECFE             
0480+  ECFE EB                              EX      DE, HL              ; HL into DE 
0481+  ECFF 3E 0A                           LD      A, 10
0482+  ED01             
0483+  ED01                                 ; DE x A  -> AHL  (from http://z80-heaven.wikidot.com/advanced-math#toc12)
0484+  ED01                                 ; preserves DE
0485+  ED01 01 00 08                        LD      BC, 0800h
0486+  ED04 61                              LD      H, C
0487+  ED05 69                              LD      L, C
0488+  ED06 29          _pl_loop            ADD     HL, HL
0489+  ED07 17                              RLA
0490+  ED08 30 02                           JR      NC, _pl_skip
0491+  ED0A 19                              ADD     HL, DE
0492+  ED0B 89                              ADC     A, C
0493+  ED0C 10 F8       _pl_skip            DJNZ    _pl_loop
0494+  ED0E             
0495+  ED0E DD 77 F3                        LD      (IX+ym_length_high), A     ; Note we only handle overflow for one digit.. max value 655,359?
0496+  ED11 F1                              POP     AF
0497+  ED12 5F                              LD      E, A
0498+  ED13 51                              LD      D, C
0499+  ED14 19                              ADD     HL, DE
0500+  ED15 30 03                           JR      NC, _pl_length_ok
0501+  ED17 DD 34 F3                        INC     (IX+ym_length_high)
0502+  ED1A             
0503+  ED1A D1          _pl_length_ok       POP     DE
0504+  ED1B C1                              POP     BC
0505+  ED1C 18 CC                           JR      _parse_length
0506+  ED1E             
0507+  ED1E E5          _length_end         PUSH    HL
0508+  ED1F FD E1                           POP     IY
0509+  ED21 DD 75 F1                        LD      (IX+ym_length_low), L
0510+  ED24 DD 74 F2                        LD      (IX+ym_length_mid), H
0511+  ED27 DD 7E F3                        LD      A, (IX+ym_length_high)
0512+  ED2A DD 77 F4                        LD      (IX+ym_loaded_high), A
0513+  ED2D C3 F9 EB                        JP      _send_ack
0514+  ED30             
0515+  ED30 3E 05       _invalid_length     LD      A, YMODEM_LENGTH_ERROR      ; Hard fail on invalid length data
0516+  ED32 A7                              AND     A
0517+  ED33 C9                              RET
0518+  ED34             
0519+  ED34             ;-----
0520+  ED34             ; Calculate the checksum from A
0521+  ED34 E5          _calc_checksum      PUSH    HL
0522+  ED35 C5                              PUSH    BC
0523+  ED36             
0524+  ED36 06 01                           LD      B, 1
0525+  ED38 4F                              LD      C, A
0526+  ED39 DD 66 FF                        LD      H, (IX+ym_crc_high)
0527+  ED3C DD 6E FE                        LD      L, (IX+ym_crc_low)
0528+  ED3F             
0529+  ED3F 29          _crc_loop           ADD     HL, HL
0530+  ED40 F5                              PUSH    AF
0531+  ED41             
0532+  ED41 CB 21                           SLA     C
0533+  ED43 CB 10                           RL      B
0534+  ED45 30 02                           JR      NC, _no_in_overflow
0535+  ED47 CB C1                           SET     0, C
0536+  ED49             _no_in_overflow
0537+  ED49 CB 40                           BIT     0, B
0538+  ED4B 28 01                           JR      Z, _no_in_bit
0539+  ED4D 23                              INC     HL
0540+  ED4E             _no_in_bit                    
0541+  ED4E F1                              POP     AF
0542+  ED4F 30 08                           JR      NC, _no_crc_overflow
0543+  ED51 3E 21                           LD      A, 021h
0544+  ED53 AD                              XOR     L 
0545+  ED54 6F                              LD      L,A
0546+  ED55 3E 10                           LD      A, 010h
0547+  ED57 AC                              XOR     H 
0548+  ED58 67                              LD      H, A
0549+  ED59             _no_crc_overflow
0550+  ED59 CB 41                           BIT     0, C
0551+  ED5B 28 E2                           JR      Z, _crc_loop    
0552+  ED5D             
0553+  ED5D DD 74 FF                        LD      (IX+ym_crc_high), H
0554+  ED60 DD 75 FE                        LD      (IX+ym_crc_low), L
0555+  ED63 C1                              POP     BC
0556+  ED64 E1                              POP     HL
0557+  ED65 C9                              RET
0558+  ED66             
0559+  ED66 00          _dev_null           .DB     0
0560+  ED67             
0561+  ED67             ;
0562+  ED67             ; Recieve a byte with timeout, without exiting ymodem
0563+  ED67             ; If success, A contains byte, non-zero flag set
0564+  ED67             ; Otherwise A is zero, Zero flag is set
0565+  ED67             ;
0566+  ED67 21 70 ED    _recieve_safe       LD      HL, _back_safe
0567+  ED6A E5                              PUSH    HL
0568+  ED6B CD 72 ED                        CALL    _receive_byte
0569+  ED6E E1                              POP     HL
0570+  ED6F C9                              RET
0571+  ED70 AF          _back_safe          XOR     A
0572+  ED71 C9                              RET     
0573+  ED72             
0574+  ED72             ;
0575+  ED72             ; Receive a byte with timeout
0576+  ED72             ; If success: A contains byte, non-zero flag set
0577+  ED72             ; Otherwise : Pops the return address off the stack and returns to the original caller with A containing YMODEM_TIMEOUT
0578+  ED72             ;
0579+  ED72 C5          _receive_byte       PUSH    BC
0580+  ED73 01 50 C3                        LD      BC, _TIMEOUT_COUNT
0581+  ED76 DB 25       _receive_loop       IN      A, (UART_LINE_STATUS)
0582+  ED78 CB 47                           BIT     0, A
0583+  ED7A 20 12                           JR      NZ, _receive_ready
0584+  ED7C 78                              LD      A, B
0585+  ED7D 06 0A                           LD      B, 10
0586+  ED7F A7          _rx_delay           AND     A
0587+  ED80 10 FD                           DJNZ    _rx_delay
0588+  ED82 47                              LD      B, A
0589+  ED83 0B                              DEC     BC
0590+  ED84 78                              LD      A, B
0591+  ED85 B1                              OR      C
0592+  ED86 20 EE                           JR      NZ, _receive_loop
0593+  ED88 C1                              POP     BC
0594+  ED89 C1                              POP     BC
0595+  ED8A 3E 01                           LD      A, YMODEM_TIMEOUT
0596+  ED8C A7                              AND     A
0597+  ED8D C9                              RET
0598+  ED8E             
0599+  ED8E DB 20       _receive_ready      IN      A, (UART_TX_RX)
0600+  ED90 C1                              POP     BC
0601+  ED91 C9                              RET
0602+  ED92             
0603+  ED92             ;
0604+  ED92             ; Send a byte with timeout
0605+  ED92             ; If success: returns normally, no registers affected
0606+  ED92             ; Otherwise : Pops the return address off the stack and returns to the original caller with A containing YMODEM_SEND_TIMEOUT
0607+  ED92             ;
0608+  ED92 C5          _send_byte          PUSH    BC
0609+  ED93 F5                              PUSH    AF
0610+  ED94 01 50 C3                        LD      BC, _TIMEOUT_COUNT
0611+  ED97 DB 25       _send_loop          IN      A, (UART_LINE_STATUS)
0612+  ED99 CB 6F                           BIT     5, A
0613+  ED9B C2 AB ED                        JP      NZ, _send_ready             ; Bit 5 is set when the UART is ready
0614+  ED9E 0B                              DEC     BC
0615+  ED9F 78                              LD      A, B
0616+  EDA0 B1                              OR      C
0617+  EDA1 C2 97 ED                        JP      NZ, _send_loop
0618+  EDA4             
0619+  EDA4 F1                              POP     AF
0620+  EDA5 C1                              POP     BC
0621+  EDA6 C1                              POP     BC
0622+  EDA7             
0623+  EDA7 3E 07                           LD      A, YMODEM_SEND_TIMEOUT
0624+  EDA9 A7                              AND     A
0625+  EDAA C9                              RET
0626+  EDAB             
0627+  EDAB F1          _send_ready         POP     AF
0628+  EDAC C1                              POP     BC
0629+  EDAD D3 20                           OUT     (UART_TX_RX), A
0630+  EDAF C9                              RET
0631+  EDB0             
0632+  EDB0                                 .MODULE main1117   EDB0             
1118   EDB0~            .IF $ >= BIOS_START
1119   EDB0~                .ECHO "End of Monitor is too high ("
1120   EDB0~                .ECHO $
1121   EDB0~                .ECHO " > "
1122   EDB0~                .ECHO BIOS_START
1123   EDB0~                .ECHO ") \n\n"
1124   EDB0~                .STOP
1125   EDB0             .ENDIF
1126   EDB0             
1127   EDB0             .ECHO "Spare after monitor "
1128   EDB0             .ECHO BIOS_START-$
1129   EDB0             .ECHO "\n\n"
1130   EDB0             
1131   EDB0 FF FF FF FF                     .FILL  BIOS_START-$
1131   EDB4 FF FF FF FF 
1131   EDB8 FF FF FF FF 
1131   EDBC FF FF FF FF 
1131   EDC0 FF FF FF FF 
1131   EDC4 FF FF FF FF 
1131   EDC8 FF FF FF FF 
1131   EDCC FF FF FF FF 
1131   EDD0 FF FF FF FF 
1131   EDD4 FF FF FF FF 
1131   EDD8 FF FF FF FF 
1131   EDDC FF FF FF FF 
1131   EDE0 FF FF FF FF 
1131   EDE4 FF FF FF FF 
1131   EDE8 FF FF FF FF 
1131   EDEC FF FF FF FF 
1131   EDF0 FF FF FF FF 
1131   EDF4 FF FF FF FF 
1131   EDF8 FF FF FF FF 
1131   EDFC FF FF FF FF 
1132   EE00             
1133   EE00                                 .INCLUDE "bios.asm"
0001+  EE00             ;
0002+  EE00             ; Simple-ish CP/M compatible BIOS
0003+  EE00             ;
0004+  EE00             ; References - http://www.gaby.de/cpm/manuals/archive/cpm22htm/axb.htm - CPM Manual 'Simple skeletal BIOS'
0005+  EE00             ;
0006+  EE00             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0007+  EE00             ;
0008+  EE00             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0009+  EE00             ;
0010+  EE00             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0011+  EE00             ; of this software and associated documentation files (the "Software"), to deal
0012+  EE00             ; in the Software without restriction, including without limitation the rights
0013+  EE00             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0014+  EE00             ; copies of the Software, and to permit persons to whom the Software is
0015+  EE00             ; furnished to do so, subject to the following conditions:
0016+  EE00             ; 
0017+  EE00             ; The above copyright notice and this permission notice shall be included in all
0018+  EE00             ; copies or substantial portions of the Software.
0019+  EE00             ; 
0020+  EE00             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0021+  EE00             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0022+  EE00             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0023+  EE00             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0024+  EE00             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0025+  EE00             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0026+  EE00             ; SOFTWARE.
0027+  EE00             ;
0028+  EE00                                 .MODULE  main
0029+  EE00             
0030+  EE00             BIOS_START          .EQU    0EE00h
0031+  EE00             BIOS_TOP            .EQU    0FDFDh
0032+  EE00             
0033+  EE00             CCP                 .EQU    BIOS_START - 01600h
0034+  EE00             BDOS                .EQU    CCP + 0806h
0035+  EE00             
0036+  EE00             CCP_SECTOR_COUNT    .EQU    (BIOS_START-CCP)/128
0037+  EE00             
0038+  EE00~            .IF (CCP_SECTOR_COUNT * 128) < (BIOS_START-CCP)
0039+  EE00~                .ECHO "CCP isn't an exact multiple of 128 byte sectors\n"
0040+  EE00~                .ECHO "  Got "
0041+  EE00~                .ECHO (BIOS_START-CCP)
0042+  EE00~                .ECHO "\n"
0043+  EE00~                .STOP
0044+  EE00             .ENDIF
0045+  EE00             
0046+  EE00             iobyte              .EQU    03h     ; Location of Intel standard I/O definition byte
0047+  EE00             usrdrv              .EQU    04h     ; Location of Current user number and drive
0048+  EE00             tpabuf              .EQU    0080h   ; Default I/O buffer and command line storage
0049+  EE00             
0050+  EE00             IO_BAT              .EQU    02h     ; CONsole IO defined by RDR for input, LST for output
0051+  EE00             
0052+  EE00             bios_start          .ORG    BIOS_START
0053+  EE00             
0054+  EE00 C3 F1 EE                        JP      bios_boot     ;  0 Initialize
0055+  EE03 C3 08 EF    wboote              JP      bios_wboot    ;  1 Warm boot
0056+  EE06 C3 71 EF                        JP      bios_conist   ;  2 Console status - Return A = 0FFH if character ready, 00H if not
0057+  EE09 C3 9A EF                        JP      bios_conin    ;  3 Console input  - Wait for input, returning character in A
0058+  EE0C C3 00 F0                        JP      bios_conout   ;  4 Console OUTput - Write character in C to console
0059+  EE0F C3 C3 F2                        JP      bios_list     ;  5 List OUTput
0060+  EE12 C3 C5 F2                        JP      bios_punch    ;  6 punch OUTput
0061+  EE15 C3 C7 F2                        JP      bios_reader   ;  7 Reader input
0062+  EE18 C3 E1 F2                        JP      bios_home     ;  8 Home disk
0063+  EE1B C3 C8 F2                        JP      bios_seldsk   ;  9 Select disk
0064+  EE1E C3 E3 F2                        JP      bios_settrk   ; 10 Select track
0065+  EE21 C3 E8 F2                        JP      bios_setsec   ; 11 Select sector
0066+  EE24 C3 ED F2                        JP      bios_setdma   ; 12 Set DMA ADDress
0067+  EE27 C3 F2 F2                        JP      bios_read     ; 13 Read 128 bytes
0068+  EE2A C3 29 F3                        JP      bios_write    ; 14 Write 128 bytes
0069+  EE2D C3 96 F3                        JP      bios_listst   ; 15 List status
0070+  EE30 C3 98 F3                        JP      bios_sectrn   ; 16 Sector translate
0071+  EE33             
0072+  EE33             MEMDISK_SECTORS     .EQU    26
0073+  EE33             MEMDISK_TRACKS      .EQU    79
0074+  EE33             
0075+  EE33             BIOS_BOOT_TRACKS    .EQU    2
0076+  EE33             BIOS_SECTOR_ADDRESS .EQU    tpabuf
0077+  EE33             
0078+  EE33             DRIVE_A_PAGE        .EQU    04h     ; Page 4 of ROM - offset 010000h
0079+  EE33             DRIVE_B_PAGE        .EQU    24h     ; Page 4 of RAM
0080+  EE33             
0081+  EE33             ; Disk Parameter Headers -------------------------------------------------------
0082+  EE33             ; These are 256K discs, equivalent to this disc format (for cpmtools)
0083+  EE33             ; 
0084+  EE33             ; References : https://www.idealine.info/sharpmz/dpb.htm - Explanation of values
0085+  EE33             ;              https://jeelabs.org/article/1715b/        - Bootstrapping CP/M
0086+  EE33             ;
0087+  EE33             ; diskdef memotech-type50
0088+  EE33             ;  seclen 128
0089+  EE33             ;  tracks 79
0090+  EE33             ;  sectrk 26
0091+  EE33             ;  blocksize 1024
0092+  EE33             ;  maxdir 64
0093+  EE33             ;  skew 1
0094+  EE33             ;  boottrk 2
0095+  EE33             ;  os 2.2
0096+  EE33             ; end
0097+  EE33             ;
0098+  EE33             MAX_DRIVES          .EQU    2
0099+  EE33             
0100+  EE33 00 00 00 00 dpbase              .DW     0,0,0,0,dirbuf,dpb0,0,sys_alv0      ; Disk 0 is Flash
0100+  EE37 00 00 00 00 
0100+  EE3B 71 EE 53 EE 
0100+  EE3F 00 00 41 FF 
0101+  EE43 00 00 00 00                     .DW     0,0,0,0,dirbuf,dpb1,0,sys_alv1      ; Disk 1 is RAM
0101+  EE47 00 00 00 00 
0101+  EE4B 71 EE 62 EE 
0101+  EE4F 00 00 61 FF 
0102+  EE53             
0103+  EE53 1A 00       dpb0                .DW     MEMDISK_SECTORS     ; SPT - sectors per track
0104+  EE55 03                              .DB     3                   ; BSH - block shift factor  BSH+BLM together mean 1024 byte blocksize
0105+  EE56 07                              .DB     7                   ; BLM - block mask
0106+  EE57 00                              .DB     0                   ; EXM - Extent mask
0107+  EE58 F8 00                           .DW     248                 ; DSM - Storage size (blocks - 1)
0108+  EE5A 3F 00                           .DW     63                  ; DRM - Number of directory entries - 1
0109+  EE5C C0                              .DB     192                 ; AL0 - 1 bit set per directory block
0110+  EE5D 00                              .DB     0                   ; AL1 - ... 8 more bits
0111+  EE5E 00 00                           .DW     0                   ; CKS - DIR check vector size (DRM+1)/4 (0=fixed disk)
0112+  EE60 02 00                           .DW     BIOS_BOOT_TRACKS    ; OFF - Reserved tracks
0113+  EE62             
0114+  EE62 1A 00       dpb1                .DW     MEMDISK_SECTORS     ; SPT - sectors per track
0115+  EE64 03                              .DB     3                   ; BSH - block shift factor  BSH+BLM together mean 1024 byte blocksize
0116+  EE65 07                              .DB     7                   ; BLM - block mask
0117+  EE66 00                              .DB     0                   ; EXM - Extent mask
0118+  EE67 F8 00                           .DW     248                 ; DSM - Storage size (blocks - 1)
0119+  EE69 3F 00                           .DW     63                  ; DRM - Number of directory entries - 1
0120+  EE6B C0                              .DB     192                 ; AL0 - 1 bit set per directory block
0121+  EE6C 00                              .DB     0                   ; AL1 - ... 8 more bits
0122+  EE6D 00 00                           .DW     0                   ; CKS - DIR check vector size (DRM+1)/4 (0=fixed disk)
0123+  EE6F 02 00                           .DW     BIOS_BOOT_TRACKS    ; OFF - Reserved tracks
0124+  EE71             
0125+  EE71 00 00 00 00 dirbuf              .FILL   128, 0 ; disk directory scratch area
0125+  EE75 00 00 00 00 
0125+  EE79 00 00 00 00 
0125+  EE7D 00 00 00 00 
0125+  EE81 00 00 00 00 
0125+  EE85 00 00 00 00 
0125+  EE89 00 00 00 00 
0125+  EE8D 00 00 00 00 
0125+  EE91 00 00 00 00 
0125+  EE95 00 00 00 00 
0125+  EE99 00 00 00 00 
0125+  EE9D 00 00 00 00 
0125+  EEA1 00 00 00 00 
0125+  EEA5 00 00 00 00 
0125+  EEA9 00 00 00 00 
0125+  EEAD 00 00 00 00 
0125+  EEB1 00 00 00 00 
0125+  EEB5 00 00 00 00 
0125+  EEB9 00 00 00 00 
0125+  EEBD 00 00 00 00 
0125+  EEC1 00 00 00 00 
0125+  EEC5 00 00 00 00 
0125+  EEC9 00 00 00 00 
0125+  EECD 00 00 00 00 
0125+  EED1 00 00 00 00 
0125+  EED5 00 00 00 00 
0125+  EED9 00 00 00 00 
0125+  EEDD 00 00 00 00 
0125+  EEE1 00 00 00 00 
0125+  EEE5 00 00 00 00 
0125+  EEE9 00 00 00 00 
0125+  EEED 00 00 00 00 
0126+  EEF1             
0127+  EEF1             ; BIOS Entry points ---------------------------------------------------------------
0128+  EEF1             
0129+  EEF1             bios_boot     ;  0 Initialize - This is called on first boot when CCP and BIOS have all been read into memory. Initialise hardware and start CCP
0130+  EEF1 F3                              DI
0131+  EEF2 31 00 00                        LD      SP,000h
0132+  EEF5 21 00 EE                        LD      HL,BIOS_START        ; Why are we doing this?
0133+  EEF8 22 FE FF                        LD      (0FFFEh),HL
0134+  EEFB CD B3 F3                        CALL    configure_hardware
0135+  EEFE AF                              XOR     A
0136+  EEFF 32 04 00                        LD      (usrdrv),A
0137+  EF02 3C                              INC     A
0138+  EF03 32 03 00                        LD      (iobyte),A           ; Input on keyboard, output on display
0139+  EF06 18 07                           JR      start_cpm
0140+  EF08             
0141+  EF08             ;------------------------------------------------------                    
0142+  EF08             bios_wboot    ;  1 Warm boot - Hardware is intialised, but CCP should be reloaded before being run
0143+  EF08 F3                              DI
0144+  EF09 31 00 00                        LD      SP,000h
0145+  EF0C                                 ;CALL    setup_screen
0146+  EF0C CD 31 EF                        CALL    load_ccp
0147+  EF0F             
0148+  EF0F FB          start_cpm           EI                           ; Make sure interrupts are enabled
0149+  EF10 21 80 00                        LD      HL,tpabuf            ; Address of BIOS DMA buffer
0150+  EF13 22 3C FF                        LD      (sys_dmaaddr),hl
0151+  EF16 3E C3                           LD      A, 0C3h              ; Opcode for 'JP'
0152+  EF18 32 00 00                        LD      (00h),A              ; Load at start of RAM
0153+  EF1B 21 03 EE                        LD      HL,wboote            ; Address of jump for a warm boot
0154+  EF1E 22 01 00                        LD      (01h),HL
0155+  EF21 32 05 00                        LD      (05h),a              ; Opcode for 'JP'
0156+  EF24 21 06 E0                        LD      HL,BDOS              ; Address of jump for the BDOS
0157+  EF27 22 06 00                        LD      (06h),HL
0158+  EF2A 3A 04 00                        LD      A,(usrdrv)           ; Save new drive number (0)  ; TODO: Ugh? Where is this set, what does it mean???
0159+  EF2D 4F                              LD      C, A                 ; Pass drive number in C
0160+  EF2E C3 00 D8                        JP      CCP                  ; Start CP/M by jumping to the CCP
0161+  EF31             
0162+  EF31                                 ; Load CCP - Note we're doing this through BIOS calls, so if we move the OS to a different
0163+  EF31                                 ;       drive, the code should still function...
0164+  EF31 0E 00       load_ccp            LD      C, 0
0165+  EF33 CD C8 F2                        CALL    bios_seldsk
0166+  EF36 CD E1 F2                        CALL    bios_home            ; Go to track 0
0167+  EF39             
0168+  EF39 06 2C                           LD      B, CCP_SECTOR_COUNT
0169+  EF3B 0E 00                           LD      C, 0                 ; Track number
0170+  EF3D 16 00                           LD      D, 0                 ; Sector to read - start with sector 0 (TODO: Check sectors are 0 based)
0171+  EF3F 21 00 D8                        LD      HL, CCP
0172+  EF42 C5          _read_ccp           PUSH    BC
0173+  EF43 D5                              PUSH    DE
0174+  EF44 E5                              PUSH    HL
0175+  EF45 4A                              LD      C, D                 ; Set the sector to read
0176+  EF46 CD E8 F2                        CALL    bios_setsec
0177+  EF49 C1                              POP     BC
0178+  EF4A C5                              PUSH    BC
0179+  EF4B CD ED F2                        CALL    bios_setdma
0180+  EF4E CD F2 F2                        CALL    bios_read
0181+  EF51 A7                              AND     A                    ; Reboot if error 
0182+  EF52 20 B4                           JR      NZ, bios_wboot
0183+  EF54             
0184+  EF54 E1                              POP     HL                   ; Calculate next address to read
0185+  EF55 11 80 00                        LD      DE, 128
0186+  EF58 19                              ADD     HL, DE
0187+  EF59 D1                              POP     DE                   ; Count down the sectors
0188+  EF5A C1                              POP     BC
0189+  EF5B 05                              DEC     B
0190+  EF5C C8                              RET     Z                    ; And return if we've read 'em all
0191+  EF5D             
0192+  EF5D 14                              INC     D                    ; Otherwise, increment sector   
0193+  EF5E 7A                              LD      A, D
0194+  EF5F FE 1B                           CP      27
0195+  EF61 38 DF                           JR      C, _read_ccp
0196+  EF63             
0197+  EF63 16 01                           LD      D, 1                 ; Or, set sector back to 1 and increment track 
0198+  EF65 0C                              INC     C
0199+  EF66             
0200+  EF66 C5                              PUSH    BC
0201+  EF67 D5                              PUSH    DE
0202+  EF68 E5                              PUSH    HL
0203+  EF69 CD E3 F2                        CALL    bios_settrk
0204+  EF6C E1                              POP     HL
0205+  EF6D D1                              POP     DE
0206+  EF6E C1                              POP     BC
0207+  EF6F 18 D1                           JR      _read_ccp
0208+  EF71             
0209+  EF71             
0210+  EF71                                 
0211+  EF71             ;------------------------------------------------------  
0212+  EF71             bios_conist   ; CONSOLE STATUS, - Return A = 0FFH if character ready, 00H if not
0213+  EF71 3A 03 00                        LD      A, (iobyte)                ; Check input on CON
0214+  EF74 E6 03                           AND     03h
0215+  EF76 28 12                           JR      Z, _coninst_tty
0216+  EF78 FE 02                           CP      IO_BAT
0217+  EF7A 28 15                           JR      Z, _coninst_rdr
0218+  EF7C             
0219+  EF7C 3A 36 FF    _coninst_kbd        LD      A, (console_identify)
0220+  EF7F A7                              AND     A
0221+  EF80 20 05                           JR      NZ, _coninst_has_char
0222+  EF82             
0223+  EF82 3A 28 FF                        LD      A, (input_size)
0224+  EF85 A7                              AND     A
0225+  EF86 C8                              RET     Z
0226+  EF87 3E FF       _coninst_has_char   LD      A, 0FFh
0227+  EF89 C9                              RET
0228+  EF8A              
0229+  EF8A AF          _coninst_tty        XOR     A
0230+  EF8B CD 49 F8                        CALL    uart_ready
0231+  EF8E D0                              RET     NC
0232+  EF8F 3D                              DEC     A
0233+  EF90 C9                              RET     
0234+  EF91 3A 03 00    _coninst_rdr        LD      A, (iobyte)                 ; Input is determined by RDR
0235+  EF94 E6 0C                           AND     0Ch
0236+  EF96 28 F2                           JR      Z, _coninst_tty
0237+  EF98 18 E2                           JR      _coninst_kbd
0238+  EF9A             
0239+  EF9A             ;------------------------------------------------------  
0240+  EF9A             bios_conin    ;  3 Console input - Wait for input, returning character in A
0241+  EF9A 3A 03 00                        LD      A, (iobyte)
0242+  EF9D E6 03                           AND     03h
0243+  EF9F 28 17                           JR      Z, _conin_tty
0244+  EFA1 FE 02                           CP      02h
0245+  EFA3 28 19                           JR      Z, _conin_rdr
0246+  EFA5                                 
0247+  EFA5 3A 36 FF    _conin_kbd          LD      A, (console_identify)           ; If the terminal has been sent an identity request escape sequence, return the response
0248+  EFA8 3D                              DEC     A
0249+  EFA9 FA C7 EF                        JP      M, _conin_read_char
0250+  EFAC 32 36 FF                        LD      (console_identify), A
0251+  EFAF 21 FD EF                        LD      HL, _indentity_sequence
0252+  EFB2 4F                              LD      C, A
0253+  EFB3 06 00                           LD      B, 0
0254+  EFB5 09                              ADD     HL, BC
0255+  EFB6 7E                              LD      A, (HL) 
0256+  EFB7 C9                              RET        
0257+  EFB8             
0258+  EFB8 CD 58 F8    _conin_tty          CALL    uart_receive
0259+  EFBB D8                              RET     C
0260+  EFBC 18 FA                           JR      _conin_tty
0261+  EFBE                  
0262+  EFBE 3A 03 00    _conin_rdr          LD      A, (iobyte)
0263+  EFC1 E6 0C                           AND     0ch
0264+  EFC3 28 F3                           JR      Z, _conin_tty
0265+  EFC5 18 DE                           JR      _conin_kbd
0266+  EFC7             
0267+  EFC7 3A 28 FF    _conin_read_char    LD      A, (input_size)                 ; Don't blink cursor if there is a character already waiting..
0268+  EFCA A7                              AND     A
0269+  EFCB 28 03                           JR      Z, _conin_wait
0270+  EFCD C3 1C F7                        JP      get_key
0271+  EFD0             
0272+  EFD0 3A 32 FF    _conin_wait         LD      A, (console_flags)              ; Turn the cursor on..
0273+  EFD3 F6 01                           OR      CFLAGS_SHOW_CURSOR
0274+  EFD5 32 32 FF                        LD      (console_flags), A
0275+  EFD8 F3                              DI
0276+  EFD9 ED 5B 2D FF                     LD      DE, (cursor_row)
0277+  EFDD 7A                              LD      A, D                            ; Force cursor update...
0278+  EFDE 3D                              DEC     A
0279+  EFDF 32 2E FF                        LD      (cursor_col),A
0280+  EFE2 CD 04 F1                        CALL    _conout_csr_update
0281+  EFE5 FB                              EI
0282+  EFE6 CD 1C F7                        CALL    get_key
0283+  EFE9 47                              LD      B, A
0284+  EFEA 3A 32 FF                        LD      A, (console_flags)
0285+  EFED E6 FE                           AND     ~CFLAGS_SHOW_CURSOR
0286+  EFEF 32 32 FF                        LD      (console_flags), A
0287+  EFF2                                 ;
0288+  EFF2 C5                              PUSH    BC
0289+  EFF3 1E 00                           LD      E, 0
0290+  EFF5 F3                              DI
0291+  EFF6 CD 67 F5                        CALL    update_cursor
0292+  EFF9 FB                              EI
0293+  EFFA C1                              POP     BC
0294+  EFFB 78                              LD      A, B
0295+  EFFC C9                              RET
0296+  EFFD                  
0297+  EFFD 4B 2F 1B    _indentity_sequence .DB     'K', '/', ESCAPE_CHAR           ; RETURNED BY VT-52 emulation - note sequence is reversed
0298+  F000             IDENTITY_LENGTH     .EQU    3
0299+  F000             
0300+  F000             ;------------------------------------------------------  
0301+  F000             bios_conout   ;  4 Console OUTput  - Write character in C to console
0302+  F000 3A 03 00                        LD      A, (iobyte)
0303+  F003 E6 03                           AND     03h
0304+  F005 FE 02                           CP      IO_BAT
0305+  F007 20 0B                           JR      NZ, _conout_disp_tty
0306+  F009             
0307+  F009 3A 03 00                        LD      A, (iobyte)
0308+  F00C E6 C0                           AND     0C0h
0309+  F00E 20 08                           JR      NZ, _conout_disp 
0310+  F010 79                              LD      A, C
0311+  F011 C3 2C F8                        JP      uart_send
0312+  F014             
0313+  F014 79          _conout_disp_tty    LD      A, C
0314+  F015 CD 2C F8                        CALL    uart_send
0315+  F018             
0316+  F018 3A 34 FF    _conout_disp        LD      A, (console_escape)             ; Test to see if handling an escape sequence and expect more parameters
0317+  F01B B7                              OR      A
0318+  F01C C2 B5 F0                        JP      NZ, _conout_escape_seq
0319+  F01F             
0320+  F01F 3A 32 FF                        LD      A, (console_flags)              ; Test to see if we're expecting an escape character
0321+  F022 E6 08                           AND     CFLAGS_ESCAPE
0322+  F024 28 7C                           JR      Z, _conout_check_esc
0323+  F026             
0324+  F026                                                                         ; If so, this is the first character after we got an escape...
0325+  F026 ED 5B 2D FF                     LD      DE, (cursor_row)                ; Get cursor position in DE
0326+  F02A 3A 32 FF                        LD      A,(console_flags)               ; Reset the escape flag
0327+  F02D E6 F7                           AND     ~CFLAGS_ESCAPE
0328+  F02F 32 32 FF                        LD      (console_flags),A
0329+  F032             
0330+  F032 79                              LD      A, C
0331+  F033             
0332+  F033 FE 41                           CP      'A'
0333+  F035 20 04                           JR      NZ, _conout_not_up
0334+  F037 1D                              DEC     E
0335+  F038 C3 04 F1                        JP      _conout_csr_update
0336+  F03B             
0337+  F03B FE 42       _conout_not_up      CP      'B'
0338+  F03D 20 04                           JR      NZ, _conout_not_down
0339+  F03F 1C                              INC     E
0340+  F040 C3 04 F1                        JP      _conout_csr_update
0341+  F043             
0342+  F043 FE 43       _conout_not_down    CP      'C'
0343+  F045 20 09                           JR      NZ, _conout_not_right
0344+  F047 3A 30 FF                        LD      A, (console_width)
0345+  F04A BA                              CP      D
0346+  F04B C8                              RET     Z                           
0347+  F04C 14                              INC     D
0348+  F04D C3 04 F1                        JP      _conout_csr_update
0349+  F050             
0350+  F050 FE 44       _conout_not_right   CP      'D'
0351+  F052 20 05                           JR      NZ, _conout_not_left
0352+  F054 15                              DEC     D
0353+  F055 C8                              RET     Z
0354+  F056 C3 04 F1                        JP      _conout_csr_update
0355+  F059             
0356+  F059 FE 46       _conout_not_left    CP      'F'                         ; Enter graphics mode.. not supported
0357+  F05B C8                              RET     Z
0358+  F05C             
0359+  F05C FE 47                           CP      'G'                         ; Exit graphics mode
0360+  F05E C8                              RET     Z
0361+  F05F             
0362+  F05F FE 48                           CP      'H'
0363+  F061 20 06                           JR      NZ, _conout_not_home
0364+  F063 11 01 01                        LD      DE, 0101h
0365+  F066 C3 04 F1                        JP      _conout_csr_update
0366+  F069             
0367+  F069 FE 49       _conout_not_home    CP      'I'                         ; Reverse line feed. Insert line above and move cursor up. Not supported
0368+  F06B C8                              RET     Z                    
0369+  F06C             
0370+  F06C FE 4A                           CP      'J'
0371+  F06E 20 01                           JR      NZ, _conout_not_clr_sc
0372+  F070             
0373+  F070                                 ; TODO... Clear to end of screen
0374+  F070 C9                              RET
0375+  F071             
0376+  F071 FE 4B       _conout_not_clr_sc  CP      'K'
0377+  F073 20 0E                           JR      NZ, _conout_not_clr_ln
0378+  F075             
0379+  F075 ED 4B 2D FF                     LD      BC, (cursor_row)
0380+  F079 05                              DEC     B
0381+  F07A 79                              LD      A, C
0382+  F07B 3D                              DEC     A
0383+  F07C 48                              LD      C, B
0384+  F07D CD A0 F2                        CALL   clear_screen_row
0385+  F080 C3 8E F1                        JP     _redraw_buffer
0386+  F083             
0387+  F083 FE 59       _conout_not_clr_ln  CP      'Y'
0388+  F085 20 08                           JR      NZ, _conout_not_pos
0389+  F087             
0390+  F087 32 34 FF    _conout_start_esc   LD      (console_escape), A         ; Start an escape sequence
0391+  F08A AF                              XOR     A
0392+  F08B 32 35 FF                        LD      (console_param1), A
0393+  F08E C9                              RET
0394+  F08F             
0395+  F08F FE 5A       _conout_not_pos     CP      'Z'
0396+  F091 20 06                           JR      NZ, _conout_not_ident
0397+  F093 3E 03                           LD      A, IDENTITY_LENGTH
0398+  F095 32 36 FF                        LD      (console_identify), A
0399+  F098 C9                              RET
0400+  F099             
0401+  F099 FE 62       _conout_not_ident   CP      'b'
0402+  F09B 28 EA                           JR      Z, _conout_start_esc
0403+  F09D FE 63                           CP      'c'
0404+  F09F 28 E6                           JR      Z, _conout_start_esc
0405+  F0A1             
0406+  F0A1                                 ; TODO: Any addtional escape sequences here...
0407+  F0A1 C9                              RET
0408+  F0A2             
0409+  F0A2 79          _conout_check_esc   LD      A, C                    
0410+  F0A3 FE 1B                           CP      ESCAPE_CHAR
0411+  F0A5 C2 4A F2                        JP      NZ, _conout_character
0412+  F0A8             
0413+  F0A8 3A 32 FF                        LD      A, (console_flags)
0414+  F0AB F6 08                           OR      CFLAGS_ESCAPE
0415+  F0AD 32 32 FF                        LD      (console_flags), A
0416+  F0B0 AF                              XOR     A
0417+  F0B1 32 34 FF                        LD      (console_escape),A
0418+  F0B4 C9                              RET
0419+  F0B5             
0420+  F0B5 3A 34 FF    _conout_escape_seq  LD      A,(console_escape)
0421+  F0B8 FE 59                           CP      'Y'
0422+  F0BA 28 0D                           JR      Z, _conout_esc_pos
0423+  F0BC FE 62                           CP      'b'
0424+  F0BE 28 20                           JR      Z, _conout_esc_foreg
0425+  F0C0 FE 63                           CP      'c'
0426+  F0C2 28 2D                           JR      Z, _conout_esc_backg
0427+  F0C4             
0428+  F0C4                                 ; All unknown sequences reset the escape sequence
0429+  F0C4 AF          _conout_reset_seq   XOR     A
0430+  F0C5 32 34 FF                        LD      (console_escape),A
0431+  F0C8 C9                              RET
0432+  F0C9             
0433+  F0C9 3A 35 FF    _conout_esc_pos     LD      A, (console_param1)
0434+  F0CC A7                              AND     A
0435+  F0CD 20 05                           JR      NZ, _conout_pos_param
0436+  F0CF 79                              LD      A, C
0437+  F0D0 32 35 FF                        LD      (console_param1),A
0438+  F0D3 C9                              RET
0439+  F0D4             
0440+  F0D4 D6 1F       _conout_pos_param   SUB     31
0441+  F0D6 5F                              LD      E, A
0442+  F0D7 79                              LD      A, C
0443+  F0D8 D6 1F                           SUB     31
0444+  F0DA 57                              LD      D, A
0445+  F0DB CD C4 F0                        CALL    _conout_reset_seq
0446+  F0DE 18 24                           JR      _conout_csr_update
0447+  F0E0             
0448+  F0E0 3A 31 FF    _conout_esc_foreg   LD      A, (console_colour)
0449+  F0E3 E6 F0                           AND     0F0h
0450+  F0E5 47                              LD      B, A
0451+  F0E6 79                              LD      A, C
0452+  F0E7 D6 1F                           SUB     31
0453+  F0E9 E6 0F                           AND     0Fh
0454+  F0EB B0          _conout_set_colour  OR      B
0455+  F0EC 32 31 FF                        LD      (console_colour), A
0456+  F0EF 18 D3                           JR      _conout_reset_seq
0457+  F0F1             
0458+  F0F1 3A 31 FF    _conout_esc_backg   LD      A, (console_colour)
0459+  F0F4 E6 0F                           AND     0Fh
0460+  F0F6 47                              LD      B, A
0461+  F0F7 79                              LD      A, C
0462+  F0F8 D6 1F                           SUB     31
0463+  F0FA CB 27                           SLA     A
0464+  F0FC CB 27                           SLA     A
0465+  F0FE CB 27                           SLA     A
0466+  F100 CB 27                           SLA     A
0467+  F102 18 E7                           JR      _conout_set_colour
0468+  F104             
0469+  F104             ; Cursor position has changed, check if we need to update the whole display.
0470+  F104             ; This is entered with DE as D = new cursor column, E = new cursor row
0471+  F104             ;         Writes new cursor poition to (cursor_row, cursor_column)
0472+  F104             ;         Returns HL = updated display column, row to track the cursor position..
0473+  F104             ; Assume column is always within range, row may be before start/after end of visible screen
0474+  F104             ;
0475+  F104 2A 2B FF    _conout_csr_update  LD      HL, (display_row)           ; HL = current display column, row..
0476+  F107 ED 4B 2D FF                     LD      BC, (cursor_row)            ; BC = old values of cursor column, row
0477+  F10B 7B                              LD      A, E                        
0478+  F10C B9                              CP      C
0479+  F10D 32 2D FF                        LD      (cursor_row), A
0480+  F110 20 09                           JR      NZ, _conout_check_row       ; If cursor row has changed, we must update display_row and optionally screen_offset
0481+  F112             
0482+  F112 7A          _conout_track_col   LD      A, D
0483+  F113 B8                              CP      B
0484+  F114 32 2E FF                        LD      (cursor_col), A
0485+  F117 20 19                           JR      NZ, _conout_check_col       ; If only column has changed, we may update display_col..
0486+  F119 18 73                           JR      _redraw_buffer              ; Otherwise, nothing has changed. Make sure display is up to date
0487+  F11B             
0488+  F11B A7          _conout_check_row   AND     A                           
0489+  F11C 20 05                           JR      NZ, _conout_chk_bottom         
0490+  F11E 3C                              INC     A                           ; We're above the screen, fix the cursor_row but set L (display row) to -1 
0491+  F11F 32 2D FF                        LD      (cursor_row), A
0492+  F122             
0493+  F122 AF                              XOR     A
0494+  F123             
0495+  F123 3D          _conout_chk_bottom  DEC     A
0496+  F124 6F                              LD      L, A                        ; Update the display row in HL which will force refresh
0497+  F125 3A 2F FF                        LD      A, (console_height)
0498+  F128 BD                              CP      L
0499+  F129 20 03                           JR      NZ, _conout_not_bottom
0500+  F12B             
0501+  F12B 32 2D FF                        LD      (cursor_row), A
0502+  F12E             
0503+  F12E 7A          _conout_not_bottom  LD      A, D                        ; Write col here since it wasn't previously set...
0504+  F12F 32 2E FF                        LD      (cursor_col), A
0505+  F132             
0506+  F132 7C          _conout_check_col   LD      A, H                        ; Current display col
0507+  F133 3C                              INC     A
0508+  F134 92                              SUB     D                           ; Subtract new cursor col
0509+  F135 30 18                           JR      NC, _conout_scroll_l        ; Cursor col is before beginning of screen
0510+  F137             
0511+  F137 3A 32 FF                        LD      A, (console_flags)
0512+  F13A E6 01                           AND     CFLAGS_SHOW_CURSOR
0513+  F13C 3E 01                           LD      A, 1
0514+  F13E 28 01                           JR      Z, _conout_keep_left
0515+  F140 3D                              DEC     A
0516+  F141 C6 18       _conout_keep_left   ADD     A, DISPLAY_WIDTH          
0517+  F143 47                              LD      B, A
0518+  F144 84                              ADD     A, H                        ; Right hand edge of display...
0519+  F145 BA                              CP      D
0520+  F146 30 0A                           JR      NC, _conout_refresh
0521+  F148             
0522+  F148 7A                              LD      A, D                        ; Cursor col is after end of screen
0523+  F149 90                              SUB     B
0524+  F14A 30 05                           JR      NC, _conout_scroll_done
0525+  F14C AF                              XOR     A
0526+  F14D 18 02                           JR      _conout_scroll_done
0527+  F14F             
0528+  F14F 7A          _conout_scroll_l    LD      A, D
0529+  F150 3D                              DEC     A
0530+  F151 67          _conout_scroll_done LD      H, A
0531+  F152             
0532+  F152             
0533+  F152             ; We enter with HL = new display column, row
0534+  F152             ; At this point one or both of display row or column may changed, so update the whole display...   
0535+  F152             ; If row is -1, we're before the beginning of the screen - need to scroll up
0536+  F152             ; And if row > console_height, we need to scroll down.. Display row stays constant, but screen_offset changes..
0537+  F152             
0538+  F152             ; Do scroll first, then only change display row/col if console_flags is set to track cursor..
0539+  F152             ; If display row/col have changed, compare screen buffer with display buffer and update whichever characters/brightnesses have changed..
0540+  F152             ;
0541+  F152             ; 
0542+  F152             _conout_refresh     
0543+  F152 7D                              LD      A, L
0544+  F153 B7                              OR      A
0545+  F154 F2 6B F1                        JP      P, _conout_row_postv
0546+  F157             
0547+  F157                                 ; Display row negative
0548+  F157 AF                              XOR     A
0549+  F158 6F                              LD      L, A                        ; Reset display row to zero
0550+  F159 3A 2A FF                        LD      A, (screen_offset)
0551+  F15C 3D                              DEC     A
0552+  F15D E6 3F                           AND     03Fh
0553+  F15F 32 2A FF                        LD      (screen_offset), A
0554+  F162 E5                              PUSH    HL
0555+  F163 0E 00                           LD      C, 0
0556+  F165 CD A0 F2                        CALL    clear_screen_row
0557+  F168 E1                              POP     HL
0558+  F169 18 19                           JR      _conout_update_display
0559+  F16B             
0560+  F16B 3A 2F FF    _conout_row_postv   LD      A, (console_height)
0561+  F16E 4F                              LD      C, A                        ; Remember for later on
0562+  F16F BD                              CP      L
0563+  F170 20 12                           JR      NZ, _conout_update_display
0564+  F172             
0565+  F172                                 ; display row below screen
0566+  F172 3A 2A FF                        LD      A, (screen_offset)
0567+  F175 3C                              INC     A
0568+  F176 E6 3F                           AND     03Fh
0569+  F178 32 2A FF                        LD      (screen_offset), A
0570+  F17B 79                              LD      A, C
0571+  F17C E5                              PUSH    HL
0572+  F17D 0E 00                           LD      C, 0
0573+  F17F CD A0 F2                        CALL    clear_screen_row
0574+  F182 E1                              POP     HL 
0575+  F183 2D                              DEC     L
0576+  F184             
0577+  F184             _conout_update_display
0578+  F184                                 ; We've scrolled if necessary, update the display row if required..
0579+  F184 3A 32 FF                        LD      A, (console_flags)
0580+  F187 E6 02                           AND     CFLAGS_TRACK_CURSOR         
0581+  F189 28 03                           JR      Z, _redraw_buffer
0582+  F18B 22 2B FF                        LD      (display_row), HL           ; Only move display row if we're tracking the cursor
0583+  F18E             
0584+  F18E F3          _redraw_buffer      DI
0585+  F18F CD 94 F1                        CALL    unsafe_redraw
0586+  F192 FB                              EI
0587+  F193 C9                              RET
0588+  F194             
0589+  F194             ;----------------------------------------------------------------------------------------------------
0590+  F194             ; Note that this uses Mem Page 1
0591+  F194             ;
0592+  F194 2A 2B FF    unsafe_redraw       LD      HL, (display_row)       ; Calculate our screen source in DE
0593+  F197 3A 2A FF                        LD      A, (screen_offset)      
0594+  F19A 85                              ADD     A, L
0595+  F19B             
0596+  F19B E6 3F                           AND     03Fh
0597+  F19D F6 40                           OR      040h                    ; We're going to use page 1 for the screen buffer
0598+  F19F 57                              LD      D, A
0599+  F1A0 7C                              LD      A, H
0600+  F1A1 CB 27                           SLA     A
0601+  F1A3 5F                              LD      E, A
0602+  F1A4             
0603+  F1A4 21 81 FF                        LD      HL, display_buffer
0604+  F1A7 06 18                           LD      B, DISPLAY_WIDTH
0605+  F1A9 0E 00                           LD      C, 0
0606+  F1AB             
0607+  F1AB 3A 32 FF                        LD      A, (console_flags)      ; Don't draw last character if we've moved
0608+  F1AE E6 04                           AND     CFLAGS_SHOW_MOVED
0609+  F1B0 28 01                           JR      Z, _full_redraw
0610+  F1B2 05                              DEC     B
0611+  F1B3             
0612+  F1B3 3A 29 FF    _full_redraw        LD      A, (screen_page)
0613+  F1B6 D3 71                           OUT     (IO_MEM_1), A
0614+  F1B8             
0615+  F1B8 1A          _redraw_loop        LD      A, (DE)
0616+  F1B9 BE                              CP      (HL)
0617+  F1BA 28 0A                           JR      Z, _redraw_skip_char
0618+  F1BC 77                              LD      (HL), A
0619+  F1BD C5                              PUSH    BC
0620+  F1BE E5                              PUSH    HL
0621+  F1BF D5                              PUSH    DE
0622+  F1C0 CD D3 FA                        CALL    disp_character
0623+  F1C3 D1                              POP     DE
0624+  F1C4 E1                              POP     HL
0625+  F1C5 C1                              POP     BC
0626+  F1C6             
0627+  F1C6 23          _redraw_skip_char   INC     HL
0628+  F1C7 13                              INC     DE
0629+  F1C8             
0630+  F1C8 3A 32 FF                        LD      A, (console_flags)
0631+  F1CB E6 04                           AND     CFLAGS_SHOW_MOVED
0632+  F1CD 1A                              LD      A, (DE)  
0633+  F1CE 28 05                           JR      Z, _redraw_normal
0634+  F1D0             
0635+  F1D0 CB 3F                           SRL     A
0636+  F1D2 CB 3F                           SRL     A
0637+  F1D4 3C                              INC     A
0638+  F1D5             
0639+  F1D5 BE          _redraw_normal      CP      (HL)
0640+  F1D6 28 12                           JR      Z, _redraw_skip_bri
0641+  F1D8 77                              LD      (HL), A
0642+  F1D9 C5                              PUSH    BC
0643+  F1DA E5                              PUSH    HL
0644+  F1DB D5                              PUSH    DE
0645+  F1DC 79                              LD      A, C                    ; Ugh... disp_char_bright has parameters in other order..
0646+  F1DD 4E                              LD      C, (HL)
0647+  F1DE CB 21                           SLA     C
0648+  F1E0 CB 21                           SLA     C
0649+  F1E2 CB 21                           SLA     C
0650+  F1E4 CD 95 FA                        CALL    disp_char_bright    ; Column A, brightness C
0651+  F1E7 D1                              POP     DE
0652+  F1E8 E1                              POP     HL
0653+  F1E9 C1                              POP     BC
0654+  F1EA             
0655+  F1EA 23          _redraw_skip_bri    INC     HL
0656+  F1EB 13                              INC     DE
0657+  F1EC 0C                              INC     C
0658+  F1ED 10 C9                           DJNZ    _redraw_loop
0659+  F1EF             
0660+  F1EF 3A 32 FF                        LD      A, (console_flags)
0661+  F1F2 4F                              LD      C, A
0662+  F1F3 E6 04                           AND     CFLAGS_SHOW_MOVED
0663+  F1F5 28 49                           JR      Z, _redraw_done
0664+  F1F7             
0665+  F1F7                                 ; We've moved the cursor, so draw the last character as our location bitmap..
0666+  F1F7 36 00       _redraw_moved       LD      (HL), 0
0667+  F1F9 23                              INC     HL
0668+  F1FA 36 80                           LD      (HL), DISP_DEFAULT_BRIGHTNESS
0669+  F1FC 79                              LD      A, C
0670+  F1FD E6 02                           AND     CFLAGS_TRACK_CURSOR
0671+  F1FF 20 44                           JR      NZ, _redraw_tracking
0672+  F201             
0673+  F201 21 00 00                        LD      HL, 0
0674+  F204 ED 4B 2D FF                     LD      BC, (cursor_row)
0675+  F208 0D                              DEC     C
0676+  F209                                 
0677+  F209 ED 5B 2B FF                     LD      DE, (display_row)
0678+  F20D 7B                              LD      A, E
0679+  F20E A7                              AND     A
0680+  F20F 20 05                           JR      NZ, _redraw_not_top
0681+  F211 21 01 00                        LD      HL, MOVE_TOP_BITMAP
0682+  F214 18 0A                           JR      _redraw_not_bottom
0683+  F216             
0684+  F216 3A 2F FF    _redraw_not_top     LD      A, (console_height)
0685+  F219 3D                              DEC     A
0686+  F21A BB                              CP      E
0687+  F21B 20 03                           JR      NZ, _redraw_not_bottom
0688+  F21D 21 08 00                        LD      HL, MOVE_BOTTOM_BITMAP
0689+  F220             
0690+  F220 7B          _redraw_not_bottom  LD      A, E
0691+  F221 B9                              CP      C
0692+  F222 01 00 00                        LD      BC, 0
0693+  F225 20 04                           JR      NZ, _redraw_not_row
0694+  F227 0E C0                           LD      C, MOVE_ROW_BITMAP_L
0695+  F229 18 08                           JR      _redraw_map
0696+  F22B             
0697+  F22B 06 28       _redraw_not_row     LD      B, MOVE_BELOW_BITMAP_H
0698+  F22D 38 02                           JR      C, _redraw_not_above
0699+  F22F 18 02                           JR      _redraw_map
0700+  F231             
0701+  F231 06 05       _redraw_not_above   LD      B, MOVE_ABOVE_BITMAP_H
0702+  F233             
0703+  F233 09          _redraw_map         ADD     HL, BC
0704+  F234 3E 17       _redraw_map2        LD      A, DISPLAY_WIDTH-1
0705+  F236 CD F4 FA                        CALL    disp_bitmask
0706+  F239             
0707+  F239 3E 17                           LD      A, DISPLAY_WIDTH-1
0708+  F23B 0E 80                           LD      C, DISP_DEFAULT_BRIGHTNESS
0709+  F23D CD 95 FA                        CALL    disp_char_bright
0710+  F240             
0711+  F240 3E 21       _redraw_done        LD      A, RAM_PAGE_1
0712+  F242 D3 71                           OUT     (IO_MEM_1), A
0713+  F244 C9                              RET
0714+  F245             
0715+  F245 21 3F 2D    _redraw_tracking    LD      HL, 2d3fh          ; Tracking symbol
0716+  F248 18 EA                           JR      _redraw_map2
0717+  F24A             
0718+  F24A             MOVE_TOP_BITMAP     .EQU    0001h
0719+  F24A             MOVE_BOTTOM_BITMAP  .EQU    0008h
0720+  F24A             MOVE_ROW_BITMAP_L   .EQU    0c0h
0721+  F24A             MOVE_ABOVE_BITMAP_H .EQU    05h
0722+  F24A             MOVE_BELOW_BITMAP_H .EQU    28h
0723+  F24A             
0724+  F24A             ;---------------------------------------- Simple character output.. 
0725+  F24A ED 5B 2D FF _conout_character   LD      DE, (cursor_row)
0726+  F24E FE 0D                           CP      CARRIAGE_RETURN
0727+  F250 20 05                           JR      NZ, _conout_not_cr
0728+  F252                
0729+  F252 16 01                           LD      D, 1
0730+  F254 C3 04 F1                        JP      _conout_csr_update
0731+  F257             
0732+  F257 FE 0A       _conout_not_cr      CP      NEWLINE
0733+  F259 20 04                           JR      NZ, _conout_not_lf
0734+  F25B             
0735+  F25B 1C                              INC     E
0736+  F25C C3 04 F1                        JP      _conout_csr_update
0737+  F25F             
0738+  F25F FE 08       _conout_not_lf      CP      BACKSPACE_CHAR
0739+  F261 20 05                           JR      NZ, _conout_visible
0740+  F263             
0741+  F263 15                              DEC     D
0742+  F264 C2 04 F1                        JP      NZ, _conout_csr_update
0743+  F267 C9                              RET
0744+  F268             
0745+  F268                                 ; Now, C is character to write,
0746+  F268 ED 5B 2D FF _conout_visible     LD      DE, (cursor_row)
0747+  F26C 15                              DEC     D                       ; 1 based col
0748+  F26D 1D                              DEC     E                       ; 1 based row
0749+  F26E             
0750+  F26E 3A 2A FF                        LD      A, (screen_offset)      ; Write the character and colour into our screen buffer
0751+  F271 83                              ADD     A, E
0752+  F272             
0753+  F272 E6 3F                           AND     03Fh
0754+  F274 F6 40                           OR      040h                    ; We're going to use page 1 for the screen buffer
0755+  F276 67                              LD      H, A
0756+  F277 7A                              LD      A, D
0757+  F278 CB 27                           SLA     A
0758+  F27A 6F                              LD      L, A
0759+  F27B 3A 29 FF                        LD      A, (screen_page)
0760+  F27E D3 71                           OUT     (IO_MEM_1), A
0761+  F280 71                              LD      (HL), C
0762+  F281 3A 31 FF                        LD      A, (console_colour)
0763+  F284 23                              INC     HL
0764+  F285 77                              LD      (HL), A
0765+  F286 3E 21                           LD      A, RAM_PAGE_1
0766+  F288 D3 71                           OUT     (IO_MEM_1), A
0767+  F28A             
0768+  F28A ED 5B 2D FF                     LD      DE, (cursor_row)
0769+  F28E 3A 30 FF                        LD      A, (console_width)
0770+  F291 6F                              LD      L, A
0771+  F292 7A                              LD      A, D
0772+  F293 BD                              CP      L
0773+  F294 28 04                           JR      Z, _conout_wrap
0774+  F296 14                              INC     D
0775+  F297 C3 04 F1                        JP      _conout_csr_update
0776+  F29A             
0777+  F29A 16 01       _conout_wrap        LD      D, 1
0778+  F29C 1C                              INC     E
0779+  F29D C3 04 F1                        JP      _conout_csr_update          ; If we've wrapped, use the new wrap position..
0780+  F2A0             ;
0781+  F2A0             ;
0782+  F2A0             ; Fill the row of the screen buffer with space chars..
0783+  F2A0             ; Enter with A -> row of screen buffer, C -> start column
0784+  F2A0             ;          Uses HL, C
0785+  F2A0             ;
0786+  F2A0 67          clear_screen_row    LD      H, A
0787+  F2A1 3A 2A FF                        LD      A, (screen_offset)
0788+  F2A4 84                              ADD     A, H
0789+  F2A5             
0790+  F2A5 E6 3F                           AND    03Fh
0791+  F2A7 F6 40                           OR     040h
0792+  F2A9 67                              LD     H, A
0793+  F2AA 79                              LD     A, C
0794+  F2AB 81                              ADD    A, C
0795+  F2AC 6F                              LD     L, A
0796+  F2AD             
0797+  F2AD 3A 31 FF                        LD      A, (console_colour)
0798+  F2B0 4F                              LD      C, A
0799+  F2B1             
0800+  F2B1 3A 29 FF                        LD      A, (screen_page)
0801+  F2B4 D3 71                           OUT     (IO_MEM_1), A
0802+  F2B6             
0803+  F2B6 3E 20                           LD      A, ' '
0804+  F2B8 77          _clear_loop         LD      (HL), A
0805+  F2B9 2C                              INC     L
0806+  F2BA 71                              LD      (HL), C
0807+  F2BB 2C                              INC     L
0808+  F2BC 20 FA                           JR      NZ, _clear_loop
0809+  F2BE             
0810+  F2BE 3E 21                           LD      A, RAM_PAGE_1
0811+  F2C0 D3 71                           OUT     (IO_MEM_1), A
0812+  F2C2 C9                              RET
0813+  F2C3             ;------------------------------------------------------  
0814+  F2C3             bios_list     ;  5 List OUTput
0815+  F2C3 AF                              XOR     A
0816+  F2C4 C9                              RET
0817+  F2C5                                 
0818+  F2C5             ;------------------------------------------------------  
0819+  F2C5             bios_punch    ;  6 punch OUTput
0820+  F2C5 AF                              XOR     A
0821+  F2C6 C9                              RET
0822+  F2C7                                 
0823+  F2C7             ;------------------------------------------------------  
0824+  F2C7             bios_reader   ;  7 Reader input
0825+  F2C7 C9                              RET
0826+  F2C8                                 
0827+  F2C8             
0828+  F2C8                                 
0829+  F2C8             ;------------------------------------------------------  
0830+  F2C8             bios_seldsk   ;  9 Select disk - Select disc in C, returns HL =  address of DPH, or 0 if error
0831+  F2C8                                 ; Store C in A, Check drive is in range
0832+  F2C8 79                              LD      A, C
0833+  F2C9 21 00 00                        LD      HL, 0
0834+  F2CC FE 02                           CP      MAX_DRIVES
0835+  F2CE D0                              RET     NC
0836+  F2CF             
0837+  F2CF 06 00                           LD      B, 0
0838+  F2D1 CB 21                           SLA     C
0839+  F2D3 CB 21                           SLA     C
0840+  F2D5 CB 21                           SLA     C
0841+  F2D7 CB 21                           SLA     C
0842+  F2D9 21 33 EE                        LD      HL, dpbase
0843+  F2DC 09                              ADD     HL, BC
0844+  F2DD 32 40 FF                        LD      (sys_seldsk), A
0845+  F2E0 C9                              RET
0846+  F2E1             
0847+  F2E1             ;------------------------------------------------------  
0848+  F2E1             bios_home     ;  8 Home disk
0849+  F2E1 0E 00                           LD      C, 0            
0850+  F2E3             ;------------------------------------------------------  
0851+  F2E3             bios_settrk   ; 10 Select track - Move drive to track stored in C - 0 based (0-76)
0852+  F2E3 79                              LD      A, C
0853+  F2E4 32 39 FF                        LD      (sys_track), A
0854+  F2E7 C9                              RET
0855+  F2E8                                 
0856+  F2E8             ;------------------------------------------------------  
0857+  F2E8             bios_setsec   ; 11 Select sector - Move drive to sector stored in BC - 1 based (1-26) - TODO: Confirm this, not sure if true..
0858+  F2E8 ED 43 3A FF                     LD      (sys_sector), BC
0859+  F2EC C9                              RET
0860+  F2ED                                 
0861+  F2ED             ;------------------------------------------------------  
0862+  F2ED             bios_setdma   ; 12 Set DMA ADDress - Set the DMA address to BC - source or destination for disk read/write
0863+  F2ED                           ; Note: CP/M 2.2 appears to only set this to the DIRBUF address defined in the DPF, or the USER DMA address (0x80h)
0864+  F2ED ED 43 3C FF                     LD      (sys_dmaaddr), BC
0865+  F2F1 C9                              RET
0866+  F2F2                                 
0867+  F2F2             ;------------------------------------------------------  
0868+  F2F2             ;
0869+  F2F2             ; Uses Mem Page 1, 2
0870+  F2F2             ;
0871+  F2F2             bios_read     ; 13 Read 128 bytes
0872+  F2F2 CD 5C F3                        CALL    _get_memdisc_addr
0873+  F2F5 F3                              DI
0874+  F2F6 D3 71                           OUT     (IO_MEM_1), A
0875+  F2F8 CB F0                           SET     6, B            ; Point B into page 1
0876+  F2FA C5                              PUSH    BC
0877+  F2FB E1                              POP     HL
0878+  F2FC 0E 80                           LD      C, 128
0879+  F2FE             
0880+  F2FE ED 5B 3C FF                     LD      DE, (sys_dmaaddr)
0881+  F302 7A                              LD      A, D
0882+  F303 07                              RLCA
0883+  F304 07                              RLCA
0884+  F305 E6 03                           AND     03h             ; Bottom two bits
0885+  F307 F6 20                           OR      RAM_PAGE_0
0886+  F309 47                              LD      B, A            ; B is destination page
0887+  F30A D3 72       _read_page          OUT     (IO_MEM_2), A
0888+  F30C             
0889+  F30C CB FA                           SET     7, D            ; Point D to second page
0890+  F30E CB B2                           RES     6, D
0891+  F310             
0892+  F310 ED A0       _read_next          LDI
0893+  F312 79                              LD      A, C
0894+  F313 B7                              OR      A
0895+  F314 28 08                           JR      Z, _read_write_done
0896+  F316             
0897+  F316 CB 72                           BIT     6, D
0898+  F318 28 F6                           JR      Z, _read_next
0899+  F31A             
0900+  F31A 04                              INC     B
0901+  F31B 78                              LD      A, B
0902+  F31C 18 EC                           JR      _read_page
0903+  F31E             
0904+  F31E 3E 21       _read_write_done    LD      A, RAM_PAGE_1   ; Return page map to normal
0905+  F320 D3 71                           OUT     (IO_MEM_1), A
0906+  F322 3E 22                           LD      A, RAM_PAGE_2
0907+  F324 D3 72                           OUT     (IO_MEM_2), A
0908+  F326 FB                              EI
0909+  F327 AF                              XOR     A               ; No errors
0910+  F328 C9                              RET
0911+  F329                                 
0912+  F329             ;------------------------------------------------------  
0913+  F329             ;
0914+  F329             ; Uses Mem Page 1, 2
0915+  F329             ;
0916+  F329             bios_write    ; 14 Write 128 bytes
0917+  F329 3A 40 FF                        LD      A, (sys_seldsk)
0918+  F32C B7                              OR      A
0919+  F32D 20 02                           JR      NZ, _write_ok
0920+  F32F 3C                              INC     A
0921+  F330 C9                              RET
0922+  F331             
0923+  F331 CD 5C F3    _write_ok           CALL    _get_memdisc_addr
0924+  F334 F3                              DI
0925+  F335 D3 71                           OUT     (IO_MEM_1), A
0926+  F337 CB F0                           SET     6, B
0927+  F339 C5                              PUSH    BC
0928+  F33A D1                              POP     DE
0929+  F33B 0E 80                           LD      C, 128
0930+  F33D             
0931+  F33D 2A 3C FF                        LD      HL, (sys_dmaaddr)
0932+  F340 7C                              LD      A, H
0933+  F341 07                              RLCA
0934+  F342 07                              RLCA
0935+  F343 E6 03                           AND     03h              ; Bottom two bits
0936+  F345 F6 20                           OR      RAM_PAGE_0
0937+  F347 47                              LD      B, A             ; B is source page
0938+  F348 D3 72       _write_page         OUT     (IO_MEM_2), A
0939+  F34A             
0940+  F34A CB FC                           SET     7, H
0941+  F34C CB B4                           RES     6, H
0942+  F34E             
0943+  F34E ED A0       _write_next         LDI
0944+  F350 79                              LD      A, C
0945+  F351 B7                              OR      A
0946+  F352 28 CA                           JR      Z, _read_write_done
0947+  F354             
0948+  F354 CB 74                           BIT     6, H
0949+  F356 28 F6                           JR      Z, _write_next
0950+  F358             
0951+  F358 04                              INC     B
0952+  F359 78                              LD      A, B
0953+  F35A 18 EC                           JR      _write_page
0954+  F35C                                 
0955+  F35C             ; IN THIS CASE, WE HAVE SAVED THE DISK NUMBER IN 'DISKNO' (0, 1)
0956+  F35C             ;           THE TRACK NUMBER IN 'TRACK' (0-76)
0957+  F35C             ;           THE SECTOR NUMBER IN 'SECTOR' (1-26)
0958+  F35C             ;           THE DMA ADDRESS IN 'DMAAD' (0-65535)
0959+  F35C             ;
0960+  F35C             ; Returns BC = address in page for sector
0961+  F35C             ;          A = page number (ROM/RAM)
0962+  F35C             ;
0963+  F35C             ; Note: BC is always aligned to page boundaries, so a sector will never overlap the end of a page.
0964+  F35C             ;
0965+  F35C 21 00 00    _get_memdisc_addr   LD      HL, 0
0966+  F35F ED 4B 39 FF                     LD      BC, (sys_track)     ; C is track, B is sector (up to 256!)
0967+  F363 68                              LD      L, B
0968+  F364 44                              LD      B, H 
0969+  F365 CB 21                           SLA     C                   ; x 2
0970+  F367 CB 10                           RL      B
0971+  F369 09                              ADD     HL, BC
0972+  F36A CB 21                           SLA     C                   ; x 4
0973+  F36C CB 10                           RL      B
0974+  F36E CB 21                           SLA     C                   ; x 8
0975+  F370 CB 10                           RL      B
0976+  F372 09                              ADD     HL, BC
0977+  F373 CB 21                           SLA     C                   ; x 16
0978+  F375 CB 10                           RL      B
0979+  F377 09                              ADD     HL, BC              ; HL = Sector + BC * (2 + 8 + 16) = sector + track * 26
0980+  F378             
0981+  F378 7D                              LD      A, L
0982+  F379 E6 7F                           AND     07Fh
0983+  F37B 47                              LD      B, A
0984+  F37C 0E 00                           LD      C, 0
0985+  F37E CB 38                           SRL     B
0986+  F380 CB 19                           RR      C                   ; BC = Address in page of sector
0987+  F382             
0988+  F382 CB 25                           SLA     L
0989+  F384 CB 14                           RL      H                   ; H is now page number 
0990+  F386             
0991+  F386 3A 40 FF                        LD      A, (sys_seldsk)
0992+  F389 B7                              OR      A
0993+  F38A 28 05                           JR      Z, _get_memdisk_a
0994+  F38C 3A 38 FF                        LD      A, (drive_b_mem_page)
0995+  F38F 84                              ADD     A, H
0996+  F390 C9                              RET
0997+  F391 3A 37 FF    _get_memdisk_a      LD      A, (drive_a_mem_page)
0998+  F394 84                              ADD     A, H
0999+  F395 C9                              RET
1000+  F396             
1001+  F396             
1002+  F396             ;------------------------------------------------------  
1003+  F396             bios_listst   ; 15 List status
1004+  F396 AF                              XOR     A
1005+  F397 C9                              RET
1006+  F398                                 
1007+  F398             ;------------------------------------------------------  
1008+  F398             bios_sectrn   ; 16 Sector translate - BC = logical sector number (zero based), DE = address of translation table. Return HL as physical sector number
1009+  F398 69                              LD      L, C                ; No skewing needed, just return BC in HL
1010+  F399 60                              LD      H, B
1011+  F39A C9                              RET
1012+  F39B                                 
1013+  F39B             ;------------------------------------------------------
1014+  F39B             ; Inline print. Preserves HL, DE, BC
1015+  F39B             ;
1016+  F39B E3          m_print_inline      EX      (SP), HL
1017+  F39C 7E          _inline_loop        LD      A, (HL)
1018+  F39D 23                              INC     HL
1019+  F39E A7                              AND     A
1020+  F39F 28 05                           JR      Z, _inline_done
1021+  F3A1 CD A8 F3                        CALL    m_print_a_safe
1022+  F3A4 18 F6                           JR      _inline_loop
1023+  F3A6             
1024+  F3A6 E3          _inline_done        EX      (SP), HL
1025+  F3A7 C9                              RET
1026+  F3A8             
1027+  F3A8             ;------------------------------------------------------
1028+  F3A8             ; Print character in A. Preserves HL, DE, BC
1029+  F3A8             ;
1030+  F3A8 E5          m_print_a_safe      PUSH    HL
1031+  F3A9 D5                              PUSH    DE
1032+  F3AA C5                              PUSH    BC
1033+  F3AB 4F                              LD      C, A
1034+  F3AC CD 00 F0                        CALL    bios_conout
1035+  F3AF C1                              POP     BC
1036+  F3B0 D1                              POP     DE
1037+  F3B1 E1                              POP     HL
1038+  F3B2 C9                              RET
1039+  F3B3             
1040+  F3B3             ;------------------------------------------------------  
1041+  F3B3             
1042+  F3B3 F3          configure_hardware  DI     
1043+  F3B4 3E 20                           LD      A, RAM_PAGE_0
1044+  F3B6 D3 70                           OUT     (IO_MEM_0), A       ; Page 0 is RAM 0 
1045+  F3B8 3C                              INC     A
1046+  F3B9 D3 71                           OUT     (IO_MEM_1), A       ; Page 1 is RAM 1
1047+  F3BB 3C                              INC      A
1048+  F3BC D3 72                           OUT     (IO_MEM_2), A       ; Page 2 is RAM 2 
1049+  F3BE             
1050+  F3BE 21 00 FE                        LD      HL, 0FE00h          ; Set up the IM 2 table
1051+  F3C1 06 00                           LD      B, 0
1052+  F3C3 36 FD       _fill_vector        LD      (HL), 0FDh
1053+  F3C5 23                              INC     HL
1054+  F3C6 10 FB                           DJNZ    _fill_vector
1055+  F3C8             
1056+  F3C8 CD 91 F5                        CALL    keyboard_init       ; Set up the keyboard status tables
1057+  F3CB             
1058+  F3CB 3E C3                           LD      A, 0C3h             ; JP reset   instruction
1059+  F3CD 32 FD FD                        LD      (0FDFDh), A
1060+  F3D0 21 7E F4                        LD      HL, interrupt_handler
1061+  F3D3 22 FE FD                        LD      (0FDFEh), HL
1062+  F3D6             
1063+  F3D6 3E 02                           LD      A, 2
1064+  F3D8 D3 13                           OUT     (PIO_B_CTRL),A      ; Zero interrupt vector
1065+  F3DA             
1066+  F3DA 3E B7                           LD      A, 0B7h             ; Enable interrupts on any of the following bits
1067+  F3DC D3 13                           OUT     (PIO_B_CTRL),A
1068+  F3DE 00                              NOP
1069+  F3DF 3E CF                           LD      A, 0CFh             ; Just B5 (RTC interrupt) 
1070+  F3E1 D3 13                           OUT     (PIO_B_CTRL),A
1071+  F3E3             
1072+  F3E3 3E FE                           LD      A, 0FEh
1073+  F3E5 ED 47                           LD      I, A
1074+  F3E7 ED 5E                           IM      2
1075+  F3E9             
1076+  F3E9 CD 43 F4                        CALL    setup_screen
1077+  F3EC             
1078+  F3EC 3E 04                           LD      A, DRIVE_A_PAGE
1079+  F3EE 32 37 FF                        LD      (drive_a_mem_page), A
1080+  F3F1             
1081+  F3F1 FB                              EI
1082+  F3F2             
1083+  F3F2 3E 00                           LD      A, 0
1084+  F3F4 CD 00 F8                        CALL    uart_init           ; Reinitialise the UART to make sure we've not missed anything
1085+  F3F7             
1086+  F3F7 CD 22 FC                        CALL    rtc_init            ; Make sure clock is running and reset time if necesary
1087+  F3FA             
1088+  F3FA 06 04       _set_ctrl           LD      B, 4                ; Set RTC Coarse mode and Output Pin to Square wave - gives 64 Hz pulse
1089+  F3FC C5          _set_ctrl_loop      PUSH    BC
1090+  F3FD 26 6F                           LD      H, RTC_ADDRESS      
1091+  F3FF 2E 07                           LD      L, RTC_REG_CTRL
1092+  F401 CD FE F8                        CALL    i2c_write_to
1093+  F404 30 0B                           JR      NC, _rtc_ack_error
1094+  F406 3E 44                           LD      A, RTC_64HZ_ENABLED
1095+  F408 CD 12 F9                        CALL    i2c_write
1096+  F40B 30 04                           JR      NC, _rtc_ack_error
1097+  F40D AF                              XOR     A
1098+  F40E CD 12 F9                        CALL    i2c_write
1099+  F411 CD D4 F8    _rtc_ack_error      CALL    i2c_stop
1100+  F414             
1101+  F414 CD 1F F4                        CALL    _pause
1102+  F417             
1103+  F417 CD 24 F4                        CALL    _check_ctrl
1104+  F41A C1                              POP     BC
1105+  F41B C8                              RET     Z
1106+  F41C 10 DE                           DJNZ    _set_ctrl_loop
1107+  F41E C9                              RET
1108+  F41F             
1109+  F41F 06 00       _pause              LD      B, 0
1110+  F421 10 FE                           DJNZ    $
1111+  F423 C9                              RET
1112+  F424             
1113+  F424             ; Check that the control is set to coarse trim and 0 offset
1114+  F424             ; Returns with Zero flag set if settings are good.
1115+  F424             ;
1116+  F424 26 6F       _check_ctrl         LD      H, RTC_ADDRESS      
1117+  F426 2E 07                           LD      L, RTC_REG_CTRL
1118+  F428 CD DD F8                        CALL    i2c_read_from
1119+  F42B 16 02                           LD      D, 2
1120+  F42D 30 11                           JR      NC, _ctrl_error
1121+  F42F 5F                              LD      E, A
1122+  F430 CD 32 F9                        CALL    i2c_ack
1123+  F433 CD 1F F9                        CALL    i2c_read
1124+  F436 57                              LD      D, A
1125+  F437 CD D4 F8                        CALL    i2c_stop
1126+  F43A 7B                              LD      A, E
1127+  F43B 06 04                           LD      B, 4
1128+  F43D FE 44                           CP      RTC_64HZ_ENABLED
1129+  F43F C0                              RET     NZ
1130+  F440 7A          _ctrl_error         LD      A, D
1131+  F441 A7                              AND     A
1132+  F442 C9                              RET 
1133+  F443             
1134+  F443             ; SHOULD NOT BE CALLED WITH INTERRUPTS ENABLED!
1135+  F443             ;
1136+  F443 11 29 FF    setup_screen        LD      DE, screen_page     ; Copy the startup defaults to the shared_data area
1137+  F446 21 70 F4                        LD      HL, _screen_defaults
1138+  F449 01 0E 00                        LD      BC, _defaults_length
1139+  F44C ED B0                           LDIR
1140+  F44E 3A 29 FF                        LD      A, (screen_page)    ; Clear the screen buffer
1141+  F451 D3 71                           OUT     (IO_MEM_1), A       ; Screen buffer is in PAGE_1
1142+  F453 21 00 40                        LD      HL, PAGE_1_START
1143+  F456 11 02 40                        LD      DE, PAGE_1_START+2
1144+  F459 0E 20                           LD      C, ' '
1145+  F45B 3A 31 FF                        LD      A, (console_colour)
1146+  F45E 47                              LD      B, A
1147+  F45F ED 43 00 40                     LD      (PAGE_1_START), BC
1148+  F463 01 FE 3F                        LD      BC, 16382
1149+  F466 ED B0                           LDIR
1150+  F468             
1151+  F468 CD 54 FB                        CALL    disp_clear          ; Clear the LED screen
1152+  F46B             
1153+  F46B 3E 21       restore_page_return LD      A, RAM_PAGE_1       ; Return Page 1 to normal RAM
1154+  F46D D3 71                           OUT     (IO_MEM_1), A
1155+  F46F C9                              RET
1156+  F470             
1157+  F470 3F          _screen_defaults    .DB     RAM_PAGE_31         ; Screen buffer page
1158+  F471 00                              .DB     0                   ; Row offset in buffer
1159+  F472 00 00                           .DB     0,0                 ; Row, column being shown on LED Display
1160+  F474 01 01                           .DB     1,1                 ; Row, column of cursor
1161+  F476 18 40                           .DB     24,64               ; Console height (rows), width (columns)
1162+  F478 0F                              .DB     00Fh                ; Current colour [7:4] = background, [3:0] = foreground
1163+  F479 02                              .DB     CFLAGS_TRACK_CURSOR ; Flags
1164+  F47A 00                              .DB     0                   ; Timer
1165+  F47B 00 00                           .DB     0, 0                ; Escape char and first parameter
1166+  F47D 00                              .DB     0                   ; Disable identifier sequence
1167+  F47E             _defaults_length    .EQU    $-_screen_defaults
1168+  F47E             
1169+  F47E F3          interrupt_handler   DI
1170+  F47F ED 73 D1 FF                     LD      (intr_stack), SP
1171+  F483 31 D1 FF                        LD      SP, intr_stack
1172+  F486 F5                              PUSH    AF
1173+  F487 D9                              EXX
1174+  F488 CD A7 F5                        CALL    keyboard_poll
1175+  F48B             
1176+  F48B 3A 13 FF                        LD      A,(control_key_pressed)
1177+  F48E A7                              AND     A
1178+  F48F C4 D7 F4                        CALL    NZ, handle_screen_shift
1179+  F492             
1180+  F492 3A 33 FF                        LD      A, (console_timer)
1181+  F495 3D                              DEC     A
1182+  F496 FA A9 F4                        JP      M, _not_moved
1183+  F499 32 33 FF                        LD      (console_timer), A
1184+  F49C 20 0B                           JR      NZ, _not_moved
1185+  F49E             
1186+  F49E 3A 32 FF                        LD      A, (console_flags)
1187+  F4A1 E6 FB                           AND     ~CFLAGS_SHOW_MOVED
1188+  F4A3 32 32 FF                        LD      (console_flags), A
1189+  F4A6 CD 94 F1                        CALL    unsafe_redraw
1190+  F4A9             
1191+  F4A9 2A 04 FF    _not_moved          LD      HL, (timer)
1192+  F4AC 5D                              LD      E, L                ; E is old low byte of timer - used to blink cursor
1193+  F4AD 23                              INC     HL
1194+  F4AE 22 04 FF                        LD      (timer), HL
1195+  F4B1 7C                              LD      A, H
1196+  F4B2 B5                              OR      L
1197+  F4B3 20 07                           JR      NZ, _timer_done
1198+  F4B5 2A 06 FF                        LD      HL, (timer+2)
1199+  F4B8 23                              INC     HL
1200+  F4B9 22 06 FF                        LD      (timer+2),HL   
1201+  F4BC             
1202+  F4BC 3A 32 FF    _timer_done         LD      A, (console_flags)
1203+  F4BF E6 01                           AND     CFLAGS_SHOW_CURSOR
1204+  F4C1 28 0B                           JR      Z, _int_done
1205+  F4C3             
1206+  F4C3 3A 04 FF                        LD      A, (timer)          ; Blink when timer bit changes
1207+  F4C6 AB                              XOR     E
1208+  F4C7 E6 20                           AND     020h
1209+  F4C9 28 03                           JR      Z, _int_done
1210+  F4CB CD 67 F5                        CALL    update_cursor
1211+  F4CE             
1212+  F4CE D9          _int_done           EXX
1213+  F4CF F1                              POP     AF
1214+  F4D0 ED 7B D1 FF                     LD      SP, (intr_stack)
1215+  F4D4 FB                              EI
1216+  F4D5 ED 4D                           RETI
1217+  F4D7             
1218+  F4D7             ; Enter with A containing a special control character
1219+  F4D7             ;
1220+  F4D7             ;
1221+  F4D7 FE 90       handle_screen_shift CP      KEY_CTRL_UP
1222+  F4D9 20 25                           JR      NZ, _not_ctrl_up
1223+  F4DB             
1224+  F4DB 3A 2B FF                        LD      A, (display_row)
1225+  F4DE 3D                              DEC     A
1226+  F4DF FA 62 F5                        JP      M, _shift_done
1227+  F4E2 F5          _shift_row          PUSH    AF
1228+  F4E3 1E 00                           LD      E, 0
1229+  F4E5 CD 67 F5                        CALL    update_cursor
1230+  F4E8 F1                              POP     AF
1231+  F4E9 32 2B FF                        LD      (display_row), A
1232+  F4EC             
1233+  F4EC 3A 32 FF    _shift_complete     LD      A, (console_flags)
1234+  F4EF E6 FD                           AND     ~CFLAGS_TRACK_CURSOR
1235+  F4F1 F6 04       _flags_and_redraw   OR      CFLAGS_SHOW_MOVED
1236+  F4F3 32 32 FF                        LD      (console_flags), A
1237+  F4F6 3E 3C                           LD      A, SHOW_MOVE_DELAY
1238+  F4F8 32 33 FF                        LD      (console_timer),A
1239+  F4FB CD 94 F1                        CALL    unsafe_redraw
1240+  F4FE 18 62                           JR      _shift_done
1241+  F500             
1242+  F500 FE 91       _not_ctrl_up        CP      KEY_CTRL_DOWN
1243+  F502 20 0D                           JR      NZ, _not_ctrl_down
1244+  F504             
1245+  F504 3A 2F FF    _shift_down         LD      A, (console_height)
1246+  F507 4F                              LD      C, A
1247+  F508 3A 2B FF                        LD      A, (display_row)
1248+  F50B 3C                              INC     A
1249+  F50C B9                              CP      C
1250+  F50D 28 53                           JR      Z, _shift_done
1251+  F50F 18 D1                           JR      _shift_row
1252+  F511             
1253+  F511 FE 93       _not_ctrl_down      CP      KEY_CTRL_RIGHT
1254+  F513 20 0F                           JR      NZ, _not_ctrl_right
1255+  F515             
1256+  F515 3A 30 FF                        LD      A, (console_width)
1257+  F518 D6 17                           SUB     DISPLAY_WIDTH-1
1258+  F51A 4F                              LD      C, A
1259+  F51B 3A 2C FF                        LD      A, (display_col)
1260+  F51E 3C                              INC     A
1261+  F51F B9                              CP      C
1262+  F520 28 40                           JR      Z, _shift_done
1263+  F522 18 0B                           JR      _shift_col
1264+  F524             
1265+  F524 FE 92       _not_ctrl_right     CP      KEY_CTRL_LEFT
1266+  F526 20 13                           JR      NZ, _not_ctrl_left
1267+  F528             
1268+  F528 3A 2C FF                        LD      A, (display_col)
1269+  F52B 3D                              DEC     A
1270+  F52C FA 62 F5                        JP      M, _shift_done
1271+  F52F F5          _shift_col          PUSH    AF
1272+  F530 1E 00                           LD      E, 0
1273+  F532 CD 67 F5                        CALL    update_cursor
1274+  F535 F1                              POP     AF
1275+  F536 32 2C FF                        LD      (display_col), A
1276+  F539 18 B1                           JR      _shift_complete
1277+  F53B             
1278+  F53B FE 94       _not_ctrl_left      CP      KEY_CTRL_ENTER
1279+  F53D 20 19                           JR      NZ, _not_ctrl_enter
1280+  F53F 3A 2D FF                        LD      A, (cursor_row)
1281+  F542 3D                              DEC     A
1282+  F543 32 2B FF                        LD      (display_row), A
1283+  F546 3A 2E FF                        LD      A, (cursor_col)
1284+  F549 D6 16                           SUB     DISPLAY_WIDTH-2
1285+  F54B 30 01                           JR      NC, _col_ok
1286+  F54D AF                              XOR     A
1287+  F54E             
1288+  F54E 32 2C FF    _col_ok             LD      (display_col), A
1289+  F551 3A 32 FF                        LD      A, (console_flags)
1290+  F554 F6 02                           OR      CFLAGS_TRACK_CURSOR
1291+  F556 18 99                           JR      _flags_and_redraw
1292+  F558             
1293+  F558 FE 95       _not_ctrl_enter     CP      KEY_CTRL_SPACE
1294+  F55A 20 06                           JR      NZ, _shift_done
1295+  F55C AF                              XOR     A
1296+  F55D 32 2C FF                        LD      (display_col), A
1297+  F560 18 A2                           JR      _shift_down
1298+  F562             
1299+  F562 AF          _shift_done         XOR     A
1300+  F563 32 13 FF                        LD      (control_key_pressed),A
1301+  F566 C9                              RET
1302+  F567             
1303+  F567             ;
1304+  F567             ; Blinks the cursor 
1305+  F567             ;  Enter with E = timer low byte. 
1306+  F567             ;  If CURSOR_BIT is 1, show the cursor at the line, otherwise restore the existing character
1307+  F567             ;
1308+  F567 3A 2B FF    update_cursor       LD      A, (display_row)    ; Are we on the same row as the cursor?
1309+  F56A 47                              LD      B, A
1310+  F56B 3A 2D FF                        LD      A, (cursor_row)
1311+  F56E 3D                              DEC     A
1312+  F56F B8                              CP      B
1313+  F570 C0                              RET     NZ
1314+  F571             
1315+  F571 3A 2C FF                        LD      A, (display_col)    ; Check the cursor column is within the display window
1316+  F574 47                              LD      B, A
1317+  F575 3A 2E FF                        LD      A, (cursor_col)
1318+  F578 3D                              DEC     A
1319+  F579 90                              SUB     B
1320+  F57A F8                              RET     M
1321+  F57B             
1322+  F57B FE 18                           CP      DISPLAY_WIDTH
1323+  F57D D0                              RET     NC
1324+  F57E             
1325+  F57E                                 ; At this point, A holds the current display column for the cursor..
1326+  F57E 4F                              LD      C, A
1327+  F57F 06 00                           LD      B, 0
1328+  F581 21 81 FF                        LD      HL, display_buffer
1329+  F584 09                              ADD     HL, BC
1330+  F585 09                              ADD     HL, BC
1331+  F586 7B                              LD      A, E
1332+  F587 E6 20                           AND     20h
1333+  F589 7E                              LD      A, (HL)
1334+  F58A 28 02                           JR      Z, _unblink
1335+  F58C 3E 5F                           LD      A, '_'
1336+  F58E C3 D3 FA    _unblink            JP    disp_character
1337+  F591             
1338+  F591                                 .INCLUDE "../ports.asm"
0001++ F591             ;
0002++ F591             ; Port definintions
0003++ F591             ;
0004++ F591             ;
0005++ F591             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0006++ F591             ;
0007++ F591             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0008++ F591             ;
0009++ F591             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0010++ F591             ; of this software and associated documentation files (the "Software"), to deal
0011++ F591             ; in the Software without restriction, including without limitation the rights
0012++ F591             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0013++ F591             ; copies of the Software, and to permit persons to whom the Software is
0014++ F591             ; furnished to do so, subject to the following conditions:
0015++ F591             ; 
0016++ F591             ; The above copyright notice and this permission notice shall be included in all
0017++ F591             ; copies or substantial portions of the Software.
0018++ F591             ; 
0019++ F591             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0020++ F591             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0021++ F591             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0022++ F591             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0023++ F591             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0024++ F591             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0025++ F591             ; SOFTWARE.
0026++ F591             ;
0027++ F591             
0028++ F591             BACKSPACE_CHAR      .EQU  08h
0029++ F591             CARRIAGE_RETURN     .EQU  0Dh
0030++ F591             NEWLINE             .EQU  0Ah
0031++ F591             ESCAPE_CHAR         .EQU  1Bh
0032++ F591             CPM_NUM             .EQU  1Fh
0033++ F591             
0034++ F591             ;=================================== UART ============================================
0035++ F591             UART_TX_RX          .EQU    020h    ; Read: receiver buffer, Write: transmitter buffer
0036++ F591             UART_INT_ENABLE     .EQU    021h    ; Interrupt enable register
0037++ F591             UART_INT_ID         .EQU    022h    ; Read: Interrupt identification register
0038++ F591             UART_FIFO_CTRL      .EQU    022h    ; Write: FIFO Control register
0039++ F591             UART_LINE_CTRL      .EQU    023h    ; Line control register
0040++ F591             UART_MODEM_CTRL     .EQU    024h    ; Modem control
0041++ F591             UART_LINE_STATUS    .EQU    025h    ; Line status
0042++ F591             UART_MODEM_STATUS   .EQU    026h    ; Modem status
0043++ F591             UART_SCRATCH        .EQU    027h    ; Scratch register
0044++ F591             
0045++ F591             ;==================================== PIO ============================================
0046++ F591             PIO_A_DATA          .EQU  010h
0047++ F591             PIO_A_CTRL          .EQU  012h
0048++ F591             
0049++ F591             PIO_B_DATA          .EQU  011h
0050++ F591             PIO_B_CTRL          .EQU  013h
0051++ F591             
0052++ F591             PIO_MODE_0          .EQU  00Fh      ; Mode 0: All outputs
0053++ F591             PIO_MODE_1          .EQU  04fh      ; Mode 1: All inputs
0054++ F591             PIO_MODE_2          .EQU  080h      ; Mode 2 (Port A only): Bi-directional
0055++ F591             PIO_MODE_3          .EQU  0CFh      ; Mode 3: Per-pin I/O on the given port - write an additional word with bits set (1) for input, reset (0) for output on the matching pin.
0056++ F591             
0057++ F591             PIO_SET_INTERRUPT   .EQU  007h      ; Set interrupt control world. By itself, this wil disable interrupts on the given port. OR with the following constants to change this
0058++ F591             PIO_ENABLE_INT      .EQU  080h      ; Enable interrupts on the given port, when OR'd with the PIO_SET_INTERRUPT control word.
0059++ F591             PIO_INT_MASK        .EQU  010h      ; When OR'd with the PIO_SET_INTERRUPT control word, the following word will enable interrupts for pins where the matching bit is zero
0060++ F591             
0061++ F591             ;================================== AUDIO ============================================
0062++ F591             ; Constants for Audio output
0063++ F591             AUDIO_PIO           .EQU  1         ; Audio on PIO (rev. 0.1 boards)
0064++ F591             AUDIO_UART          .EQU  2         ; Audio on UART (rev. 0.2 boards)
0065++ F591             
0066++ F591             AUDIO_VERSION       .EQU  AUDIO_UART
0067++ F591             
0068++ F591~            #IF AUDIO_VERSION = AUDIO_PIO
0069++ F591~            PORT_B_IOMASK       .EQU  0EFh      ; All inputs, apart from bit 4 (audio out)
0070++ F591~            AUDIO_MASK          .EQU  010h      ; Bitmask for audio output on Port B. The bit is set for the output pin.
0071++ F591~            AUDIO_PORT          .EQU  PIO_B_DATA
0072++ F591~            
0073++ F591             #ELSE
0074++ F591             PORT_B_IOMASK       .EQU  0FFh      ; All inputs
0075++ F591             AUDIO_MASK          .EQU  008h      ; Bitmask for audio output on UART Out 2. The bit is set for the output pin
0076++ F591             AUDIO_PORT          .EQU  UART_MODEM_CTRL
0077++ F591             
0078++ F591             #ENDIF
0079++ F591             
0080++ F591             
0081++ F591             ;=================================== MEMORY PAGING ===================================
0082++ F591             IO_MEM_0            .EQU    070h      ; Page 0: 0000h - 3fffh
0083++ F591             IO_MEM_1            .EQU    071h      ; Page 1: 4000h - 7fffh
0084++ F591             IO_MEM_2            .EQU    072h      ; Page 2: 8000h - bfffh
0085++ F591             IO_MEM_3            .EQU    073h      ; Page 3: c000h - ffffh
0086++ F591             
0087++ F591             IO_MEM_CTRL         .EQU    074h      ; Paging enable register
0088++ F591             IO_MEM_ENABLE       .EQU    1
0089++ F591             IO_MEM_DISABLE      .EQU    0 
0090++ F591             
0091++ F591             RAM_PAGE_0          .EQU    020h
0092++ F591             RAM_PAGE_1          .EQU    021h
0093++ F591             RAM_PAGE_2          .EQU    022h
0094++ F591             RAM_PAGE_3          .EQU    023h
0095++ F591             
0096++ F591             RAM_PAGE_16         .EQU    030h
0097++ F591             RAM_PAGE_31         .EQU    03Fh
0098++ F591             
0099++ F591             ROM_PAGE_0          .EQU    000h
0100++ F591             ROM_PAGE_16         .EQU    010h
0101++ F591             
0102++ F591             PAGE_1_START        .EQU    4000h
0103++ F591             
0104++ F591             ;====================================== I2C DEVICES ===================================
0105++ F591             I2C_DATA_BIT            .equ    7
0106++ F591             I2C_CLK_BIT             .equ    6
0107++ F591             
0108++ F591             I2C_DATA_MASK           .equ    1 << I2C_DATA_BIT
0109++ F591             I2C_CLK_MASK            .equ    1 << I2C_CLK_BIT
0110++ F591             
0111++ F591             ; Display
0112++ F591             ;==========
0113++ F591             DL_ADDRESS              .EQU    050h     ; Left  Matrix controller I2C address
0114++ F591             DR_ADDRESS              .EQU    053h     ; Right Matrix controller I2C address
0115++ F591             
0116++ F591             DISP_REG_CRWL           .EQU    0FEh     ; Command Register write lock
0117++ F591             DISP_UNLOCK             .EQU    0C5h     ; Unlock command
0118++ F591             
0119++ F591             DISP_DEFAULT_BRIGHTNESS .EQU    080h     ; Default brightness
0120++ F591             DISP_DIMMED             .EQU    018h     ; Dimmed
0121++ F591             
0122++ F591             DISPLAY_WIDTH           .EQU    24       ; 24 characters
0123++ F591             
0124++ F591             ; RTC
0125++ F591             ;==========
0126++ F591             RTC_ADDRESS             .EQU    06fh
0127++ F591             
0128++ F591             RTC_REG_SEC             .EQU    000h    ; Also has oscillator enable bit in B7, 1 = run
0129++ F591             RTC_REG_MIN             .EQU    001h
0130++ F591             RTC_REG_HOUR            .EQU    002h    ; B6: 1 = 12hr/ 0 = 24hr clock (r/w) 
0131++ F591                                                     ;        If 12 hr clock, B5: 1 = PM/ 0 = AM. B4: hour tens. Otherwise B5-4: hour tens, B3-0: hour units
0132++ F591             RTC_REG_WKDAY           .EQU    003h    ; Oscillator status bit in B5, 1 = enabled and running. 
0133++ F591                                                     ;   B4: 1 = power was lost, write 0 to clear (timestamp registers are set)
0134++ F591                                                     ;   B3: 1 = enable external battery supply (VBAT)
0135++ F591                                                     ;   B2-0: Weekday, from 1 to 7 
0136++ F591             RTC_REG_DATE            .EQU    004h    ; BCD Date (1 to 31)
0137++ F591             RTC_REG_MTH             .EQU    005h    ; B5: 1 = Leap year (read only). B4: month tens, B3-0: month units  (Month is 1 to 12)
0138++ F591             RTC_REG_YEAR            .EQU    006h    ; BCD Year
0139++ F591             
0140++ F591             RTC_REG_CTRL            .EQU    007h    ; B7: If Square wave and Alarm 0 and Alarm 1 are disabled, sets Output Pin level
0141++ F591                                                     ;   B6: SQWEN, 1 = Enable square wave on Output Pin, Alarms disabled
0142++ F591                                                     ;   B5, B4: Alarm 1, 0 Enable. 1 = Alarm is enabled
0143++ F591                                                     ;   B3: 1 = Use external oscillator
0144++ F591                                                     ;   B2: CRSTRIM, 1 = Coarse trim mode, Output pin is 64Hz
0145++ F591                                                     ;   B1-0: If SQWEN = 1 & CRSTRIM = 0, sets Output pin freq. 00 -> 1Hz, 01 -> 4.096kHz, 10 -> 8.192kHz, 11 -> 32.768kHz
0146++ F591             RTC_REG_TRIM            .EQU    008h    ; Trim, initially 0. B7: Sign, 1=Add, 0=Subtract clock cycles.  
0147++ F591                                                     ;   B6-0: Trim amount/2. Applied 1 every minute in fine trim, 128 times a second in coarse trim mode. 0 = disable trim
0148++ F591             
0149++ F591             RTC_64HZ_ENABLED        .EQU    044h    ; Value for RTC_REG_CTRL to enable 64Hz interrupt output
0150++ F591             
0151++ F591             RTC_WEEKDAY_RUNNING     .EQU    008h    ; Value for RTC_REG_WKDAY for normall running of clock1339+  F591             
1340+  F591                                 .INCLUDE "../io.asm"
0001++ F591             ;
0002++ F591             ; I/O routines.. specifically keyboard and serial
0003++ F591             ;
0004++ F591             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0005++ F591             ;
0006++ F591             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0007++ F591             ;
0008++ F591             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0009++ F591             ; of this software and associated documentation files (the "Software"), to deal
0010++ F591             ; in the Software without restriction, including without limitation the rights
0011++ F591             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0012++ F591             ; copies of the Software, and to permit persons to whom the Software is
0013++ F591             ; furnished to do so, subject to the following conditions:
0014++ F591             ; 
0015++ F591             ; The above copyright notice and this permission notice shall be included in all
0016++ F591             ; copies or substantial portions of the Software.
0017++ F591             ; 
0018++ F591             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0019++ F591             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0020++ F591             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0021++ F591             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0022++ F591             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0023++ F591             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0024++ F591             ; SOFTWARE.
0025++ F591             ;
0026++ F591             
0027++ F591             
0028++ F591 21 08 FF    keyboard_init       LD      HL, keyboard_state
0029++ F594 06 20                           LD      B, io_data_end - keyboard_state
0030++ F596 AF                              XOR     A
0031++ F597 77          _init_loop          LD      (HL),A
0032++ F598 23                              INC     HL
0033++ F599 05                              DEC     B
0034++ F59A 20 FB                           JR      NZ, _init_loop
0035++ F59C AF                              XOR     A
0036++ F59D 32 28 FF                        LD      (input_size),A
0037++ F5A0 32 27 FF                        LD      (input_free),A
0038++ F5A3 32 26 FF                        LD      (input_pos),A
0039++ F5A6 C9                              RET
0040++ F5A7             
0041++ F5A7             ; Poll the keyboard, adding raw codes to the keyboard_state buffer, and decoded characters to the input_buffer
0042++ F5A7             ;
0043++ F5A7 01 00 FE    keyboard_poll       LD      BC, 0FE00h          ; Keyboard row 0
0044++ F5AA 21 40 F7                        LD      HL, keyboard
0045++ F5AD ED 78       _poll_loop          IN      A, (C)              ; BC -> Keyboard row port..
0046++ F5AF 16 01                           LD      D, 1                ; D -> Current Bit
0047++ F5B1 5F                              LD      E, A                ; E -> Key row bit set
0048++ F5B2 22 10 FF    _next_key           LD      (keyboard_pos), HL
0049++ F5B5 A2                              AND     D
0050++ F5B6 20 56                           JR      NZ, _released
0051++ F5B8                                                             ; Key is pressed... add it to state buffer
0052++ F5B8 C5                              PUSH    BC
0053++ F5B9 7E                              LD      A, (HL)             ; Raw key code in A
0054++ F5BA             
0055++ F5BA 21 08 FF                        LD      HL, keyboard_state
0056++ F5BD 06 08                           LD      B, _key_state_size
0057++ F5BF BE          _check_pressed      CP      (HL)
0058++ F5C0 CA 3C F6                        JP      Z, _do_nothing      ; Key already in state table - nothing to do..
0059++ F5C3 23                              INC     HL
0060++ F5C4 05                              DEC     B
0061++ F5C5 20 F8                           JR      NZ, _check_pressed
0062++ F5C7                                                             ; Key wasn't pressed, so add it to the first free slot
0063++ F5C7 21 08 FF                        LD      HL, keyboard_state
0064++ F5CA 06 08                           LD      B, _key_state_size
0065++ F5CC 4F                              LD      C, A
0066++ F5CD AF                              XOR     A
0067++ F5CE BE          _find_free          CP      (HL)
0068++ F5CF 28 07                           JR      Z, _key_pressed
0069++ F5D1 23                              INC     HL
0070++ F5D2 05                              DEC     B
0071++ F5D3 20 F9                           JR      NZ, _find_free
0072++ F5D5 C3 3C F6                        JP      _do_nothing         ; No free slots, so ignore the key
0073++ F5D8             
0074++ F5D8 71          _key_pressed        LD      (HL), C             ; Found free slot, store the raw key code
0075++ F5D9             
0076++ F5D9                                 ; Reset repeat counter
0077++ F5D9                                                             ; Now find the actual character code and add it to the input buffer
0078++ F5D9 3E 84                           LD      A, KEY_SHIFT        ; Handle modifier keys
0079++ F5DB B9                              CP      C
0080++ F5DC 06 01                           LD      B, KEY_SHIFT_BIT
0081++ F5DE 28 25                           JR      Z, _modifier
0082++ F5E0 3E 86                           LD      A, KEY_CTRL
0083++ F5E2 B9                              CP      C
0084++ F5E3 06 02                           LD      B, KEY_CTRL_BIT
0085++ F5E5 28 1E                           JR      Z, _modifier         
0086++ F5E7             
0087++ F5E7 2A 10 FF                        LD      HL, (keyboard_pos)  ; Get the current keyboard character location
0088++ F5EA 01 30 00                        LD      BC, _keyboard_size
0089++ F5ED 3A 12 FF                        LD      A, (key_shift_state)
0090++ F5F0 A7                              AND     A
0091++ F5F1 28 04                           JR      Z, _got_keycode
0092++ F5F3 09          _modifier_offset    ADD     HL, BC
0093++ F5F4 3D                              DEC     A
0094++ F5F5 20 FC                           JR      NZ, _modifier_offset
0095++ F5F7             
0096++ F5F7 7E          _got_keycode        LD      A, (HL) 
0097++ F5F8 32 14 FF                        LD      (last_keycode), A
0098++ F5FB CD 6C F6                        CALL    _store_key
0099++ F5FE AF                              XOR     A
0100++ F5FF 32 15 FF                        LD      (key_repeat_time), A
0101++ F602             
0102++ F602 C1                              POP     BC
0103++ F603 18 38                           JR      _poll_next
0104++ F605             
0105++ F605             
0106++ F605 3A 12 FF    _modifier           LD      A, (key_shift_state)
0107++ F608 B0                              OR      B
0108++ F609 32 12 FF                        LD      (key_shift_state), A
0109++ F60C 18 2E                           JR      _do_nothing
0110++ F60E             
0111++ F60E                                                             ; Key is not pressed... remove it from the state buffer if it was pressed (key up event)
0112++ F60E                                                             ; TODO: This is rather inefficient...
0113++ F60E C5          _released           PUSH    BC
0114++ F60F 7E                              LD      A, (HL)             ; Raw key code in A
0115++ F610 A7                              AND     A
0116++ F611 28 29                           JR      Z, _do_nothing      ; Ignore character zero
0117++ F613             
0118++ F613 21 08 FF                        LD      HL, keyboard_state
0119++ F616 06 08                           LD      B, _key_state_size
0120++ F618 BE          _check_released     CP      (HL)
0121++ F619 28 06                           JR      Z, _handle_release
0122++ F61B 23                              INC     HL
0123++ F61C 05                              DEC     B
0124++ F61D 20 F9                           JR      NZ, _check_released
0125++ F61F 18 1B                           JR      _do_nothing         ; Code not in state buffer, not released
0126++ F621             
0127++ F621 4F          _handle_release     LD      C, A
0128++ F622 AF                              XOR     A
0129++ F623 77                              LD      (HL), A             ; Remove it from the buffer 
0130++ F624 32 14 FF                        LD      (last_keycode), A
0131++ F627                                                             ; TODO: We should probably tell someone about this...
0132++ F627 3E 84                           LD      A, KEY_SHIFT        ; Handle modifier keys
0133++ F629 B9                              CP      C
0134++ F62A 06 01                           LD      B, KEY_SHIFT_BIT
0135++ F62C 28 07                           JR      Z, _modifier_up
0136++ F62E 3E 86                           LD      A, KEY_CTRL
0137++ F630 B9                              CP      C
0138++ F631 06 02                           LD      B, KEY_CTRL_BIT
0139++ F633 20 07                           JR      NZ, _do_nothing     
0140++ F635             
0141++ F635 3A 12 FF    _modifier_up        LD      A, (key_shift_state)
0142++ F638 A8                              XOR     B
0143++ F639 32 12 FF                        LD      (key_shift_state), A
0144++ F63C             
0145++ F63C C1          _do_nothing         POP     BC
0146++ F63D             
0147++ F63D 2A 10 FF    _poll_next          LD      HL, (keyboard_pos)
0148++ F640 7B                              LD      A, E                ; Get the bitmask back
0149++ F641 23                              INC     HL
0150++ F642 CB 22                           SLA     D
0151++ F644 CB 72                           BIT     6, D
0152++ F646 CA B2 F5                        JP      Z, _next_key
0153++ F649             
0154++ F649 CB 00                           RLC     B                   ; Move to the next key row
0155++ F64B 3E FE                           LD      A, 0FEh
0156++ F64D B8                              CP      B
0157++ F64E C2 AD F5                        JP      NZ, _poll_loop
0158++ F651             
0159++ F651 3A 14 FF                        LD      A, (last_keycode)
0160++ F654 A7                              AND     A
0161++ F655 C8                              RET     Z
0162++ F656 3A 15 FF                        LD      A, (key_repeat_time)
0163++ F659 3C                              INC     A
0164++ F65A 32 15 FF                        LD      (key_repeat_time), A
0165++ F65D FE 28                           CP      KEY_REPEAT_DELAY
0166++ F65F 28 08                           JR      Z, _do_repeat
0167++ F661 FE 2F                           CP      KEY_REPEAT_AFTER
0168++ F663 C0                              RET     NZ
0169++ F664 3E 28                           LD      A, KEY_REPEAT_DELAY
0170++ F666 32 15 FF                        LD      (key_repeat_time),A
0171++ F669 3A 14 FF    _do_repeat          LD      A, (last_keycode)
0172++ F66C             
0173++ F66C             
0174++ F66C             ; Store the decoded keycode in A to the relevant buffer...
0175++ F66C 4F          _store_key          LD      C, A
0176++ F66D E6 F8                           AND     CTRL_KEY_MASK       ; Check for special control characters 
0177++ F66F FE 90                           CP      CTRL_KEY_CHECK
0178++ F671 20 05                           JR      NZ, _get_key
0179++ F673             
0180++ F673 79                              LD      A, C                ; Store them in a separate location
0181++ F674 32 13 FF                        LD      (control_key_pressed), A
0182++ F677 C9                              RET
0183++ F678                                                             ; Write the character to the input buffer
0184++ F678 79          _get_key            LD      A, C                ; Get the actual character...
0185++ F679 A7                              AND     A                   ; Skip blank character codes
0186++ F67A C8                              RET     Z
0187++ F67B             
0188++ F67B 6F                              LD      L, A                ; Store it in L
0189++ F67C             
0190++ F67C 3A 28 FF                        LD      A, (input_size)     ; Now check we have space
0191++ F67F FE 10                           CP      _input_buffer_size
0192++ F681 C8                              RET     Z
0193++ F682             
0194++ F682 3C                              INC     A
0195++ F683 32 28 FF                        LD      (input_size), A
0196++ F686             
0197++ F686 06 00                           LD      B, 0
0198++ F688 3A 27 FF                        LD      A, (input_free)
0199++ F68B 4F                              LD      C, A
0200++ F68C 7D                              LD      A, L                ; Get the character from L
0201++ F68D 21 16 FF                        LD      HL, input_buffer
0202++ F690 09                              ADD     HL, BC
0203++ F691 77                              LD      (HL), A             ; Store the character
0204++ F692             
0205++ F692 0C                              INC     C                   ; Point to next byte in input
0206++ F693 3E 0F                           LD      A, 0Fh
0207++ F695 A1                              AND     C
0208++ F696 32 27 FF                        LD      (input_free), A
0209++ F699 C9                              RET
0210++ F69A             
0211++ F69A             ;
0212++ F69A             ; Reads the next available character in A, returning that or 0 if none are available
0213++ F69A             ; Z flag is set if no character
0214++ F69A             ; Uses HL, BC, A
0215++ F69A 3A 28 FF    read_character      LD      A, (input_size)
0216++ F69D A7                              AND     A
0217++ F69E C8                              RET     Z
0218++ F69F             
0219++ F69F F3                              DI                          ; Make sure we don't get into a race condition..
0220++ F6A0 3A 28 FF                        LD      A, (input_size)
0221++ F6A3 3D                              DEC     A
0222++ F6A4 32 28 FF                        LD      (input_size),A
0223++ F6A7 3A 26 FF                        LD      A, (input_pos)
0224++ F6AA 4F                              LD      C, A
0225++ F6AB 3C                              INC     A
0226++ F6AC E6 0F                           AND     0Fh
0227++ F6AE 32 26 FF                        LD      (input_pos),A
0228++ F6B1 06 00                           LD      B, 0
0229++ F6B3 21 16 FF                        LD      HL, input_buffer
0230++ F6B6 09                              ADD     HL, BC
0231++ F6B7 7E                              LD      A, (HL)
0232++ F6B8 B7                              OR      A
0233++ F6B9 FB                              EI
0234++ F6BA C9                              RET
0235++ F6BB                                 
0236++ F6BB             ;;
0237++ F6BB             ; D = Octave 2-6
0238++ F6BB             ; E = Note 0-11
0239++ F6BB             ; C = 1-15 duration, ~tenths of a second
0240++ F6BB             ;
0241++ F6BB 3E 07       play_note           LD      A, 7
0242++ F6BD 92                              SUB     D
0243++ F6BE 16 00                           LD      D, 0
0244++ F6C0 21 02 F7                        LD      HL, _note_table
0245++ F6C3 19                              ADD     HL, DE
0246++ F6C4 19                              ADD     HL, DE
0247++ F6C5             
0248++ F6C5 5E                              LD      E, (HL)
0249++ F6C6 23                              INC     HL
0250++ F6C7 56                              LD      D, (HL)
0251++ F6C8             
0252++ F6C8 A7          _note_octave        AND     A
0253++ F6C9 28 07                           JR      Z, _note_shifted
0254++ F6CB             
0255++ F6CB CB 3A                           SRL     D
0256++ F6CD CB 1B                           RR      E
0257++ F6CF 3D                              DEC     A
0258++ F6D0 18 F6                           JR      _note_octave
0259++ F6D2             
0260++ F6D2 41          _note_shifted       LD      B, C
0261++ F6D3 4F                              LD      C, A        ; A is zero from previous octave calc
0262++ F6D4 CB 20                           SLA     B    
0263++ F6D6 CB 20                           SLA     B    
0264++ F6D8 CB 20                           SLA     B    
0265++ F6DA CB 20                           SLA     B           ; Now BC = 4096 * C
0266++ F6DC             
0267++ F6DC DB 24                           IN      A, (AUDIO_PORT)
0268++ F6DE 32 EF F6                        LD      (_tone_val+1), A
0269++ F6E1 F3                              DI
0270++ F6E2             
0271++ F6E2             _tone_loop          ; 186 T-states          
0272++ F6E2 19                              ADD     HL, DE              ; 11
0273++ F6E3 1F                              RRA                         ; 4   Carry into bit 7
0274++ F6E4 CB 2F                           SRA     A                   ; 8   Copy to bit 6
0275++ F6E6 CB 2F                           SRA     A                   ; 8   ..5
0276++ F6E8 CB 2F                           SRA     A                   ; 8   ..4
0277++ F6EA CB 2F                           SRA     A                   ; 8   ..3
0278++ F6EC             
0279++ F6EC E6 08                           AND     AUDIO_MASK          ; 7
0280++ F6EE EE 00       _tone_val           XOR     0                   ; 7
0281++ F6F0 32 EF F6                        LD      (_tone_val+1), A    ; 13
0282++ F6F3             
0283++ F6F3 D3 24                           OUT     (AUDIO_PORT),A      ; 12
0284++ F6F5             
0285++ F6F5 78                              LD      A, B                ; 4
0286++ F6F6 06 05                           LD      B, 5                ; 7
0287++ F6F8 10 FE                           DJNZ    $                   ; 4 * 13 + 7 = 59
0288++ F6FA 47                              LD      B, A                ; 4
0289++ F6FB             
0290++ F6FB 0B                              DEC     BC                  ; 6
0291++ F6FC 78                              LD      A, B                ; 4
0292++ F6FD B1                              OR      C                   ; 4
0293++ F6FE 20 E2                           JR      NZ, _tone_loop      ; 12
0294++ F700             
0295++ F700 FB                              EI
0296++ F701 C9                              RET
0297++ F702             
0298++ F702 EB 18       _note_table         .DW 6379
0299++ F704 65 1A                           .DW 6757
0300++ F706 F6 1B                           .DW 7158
0301++ F708 A1 1D                           .DW 7585
0302++ F70A 63 1F                           .DW 8035
0303++ F70C 40 21                           .DW 8512
0304++ F70E 3F 23                           .DW 9023
0305++ F710 51 25                           .DW 9553
0306++ F712 8C 27                           .DW 10124
0307++ F714 EA 29                           .DW 10730
0308++ F716 60 2C                           .DW 11360
0309++ F718 0D 2F                           .DW 12045
0310++ F71A 00 00                           .DW 0
0311++ F71C                                 
0312++ F71C             ;
0313++ F71C             ; Get the next key press
0314++ F71C             ;
0315++ F71C CD 9A F6    get_key             CALL    read_character
0316++ F71F 06 00                           LD      B, 0
0317++ F721 10 FE                           DJNZ    $
0318++ F723 28 F7                           JR      Z, get_key
0319++ F725 C9                              RET
0320++ F726             ;
0321++ F726             ; Wait for a key to be pressed and released
0322++ F726             ;
0323++ F726             ;
0324++ F726 CD 9A F6    wait_for_key        CALL    read_character
0325++ F729 06 00                           LD      B, 0
0326++ F72B 10 FE                           DJNZ    $
0327++ F72D 28 F7                           JR      Z, wait_for_key
0328++ F72F             
0329++ F72F             ;
0330++ F72F             ; wait until there are no keys being pressed
0331++ F72F             ;
0332++ F72F             ;
0333++ F72F CD 9A F6    wait_no_keys        CALL    read_character
0334++ F732 20 FB                           JR      NZ, wait_no_keys
0335++ F734 01 00 00                        LD      BC, 0h              ; Make sure key is released
0336++ F737 ED 78                           IN      A, (C)
0337++ F739 E6 3F                           AND     03Fh
0338++ F73B FE 3F                           CP      03Fh
0339++ F73D 20 F0                           JR      NZ, wait_no_keys
0340++ F73F C9                              RET
0341++ F740             
0342++ F740             ; Non-printing key codes
0343++ F740             ;
0344++ F740             KEY_ENTER       .EQU    13
0345++ F740             KEY_DELETE      .EQU    127
0346++ F740             KEY_CTRL_C      .EQU    03h
0347++ F740             KEY_CTRL_E      .EQU    05h
0348++ F740             
0349++ F740             KEY_CTRL_P      .EQU    10h
0350++ F740             KEY_CTRL_R      .EQU    12h
0351++ F740             KEY_CTRL_S      .EQU    13h
0352++ F740             KEY_CTRL_U      .EQU    15h
0353++ F740             KEY_CTRL_X      .EQU    18h
0354++ F740             KEY_CTRL_Z      .EQU    1Ah
0355++ F740             
0356++ F740             KEY_BACKSPACE   .EQU    08h
0357++ F740             
0358++ F740             ; Modifier and special keys have key codes with the top bit set..
0359++ F740             ;
0360++ F740             KEY_UP          .EQU    128
0361++ F740             KEY_DOWN        .EQU    129
0362++ F740             KEY_LEFT        .EQU    130
0363++ F740             KEY_RIGHT       .EQU    131
0364++ F740             KEY_SHIFT       .EQU    132
0365++ F740             KEY_CTRL        .EQU    134
0366++ F740             
0367++ F740             ; 144 = 90h
0368++ F740             ;
0369++ F740             CTRL_KEY_MASK   .EQU    0F8h
0370++ F740             CTRL_KEY_CHECK  .EQU    090h
0371++ F740             
0372++ F740             KEY_CTRL_UP     .EQU    144             ; These characters start on an exact multiple of 8 so they 
0373++ F740             KEY_CTRL_DOWN   .EQU    145             ; Can easily be detected
0374++ F740             KEY_CTRL_LEFT   .EQU    146
0375++ F740             KEY_CTRL_RIGHT  .EQU    147
0376++ F740             KEY_CTRL_ENTER  .EQU    148
0377++ F740             KEY_CTRL_SPACE  .EQU    149 
0378++ F740             
0379++ F740             _keyboard_size  .EQU    48
0380++ F740             
0381++ F740             KEY_SHIFT_BIT   .EQU    1
0382++ F740             KEY_CTRL_BIT    .EQU    2
0383++ F740             
0384++ F740             KEY_REPEAT_DELAY .EQU   40
0385++ F740             KEY_REPEAT_AFTER .EQU   KEY_REPEAT_DELAY+7
0386++ F740             
0387++ F740 76 63 78 7A keyboard        .DB    "vcxz", KEY_CTRL, 0
0387++ F744 86 00 
0388++ F746 67 66 64 73                 .DB    "gfdsa", KEY_SHIFT
0388++ F74A 61 84 
0389++ F74C 74 72 65 77                 .DB    "trewq", KEY_DOWN
0389++ F750 71 81 
0390++ F752 35 34 33 32                 .DB    "54321", KEY_UP  
0390++ F756 31 80 
0391++ F758 36 37 38 39                 .DB    "67890", KEY_BACKSPACE
0391++ F75C 30 08 
0392++ F75E 79 75 69 6F                 .DB    "yuiop:"
0392++ F762 70 3A 
0393++ F764 68 6A 6B 6C                 .DB    "hjkl.", KEY_ENTER
0393++ F768 2E 0D 
0394++ F76A 62 6E 6D 20                 .DB    "bnm ", KEY_LEFT, KEY_RIGHT
0394++ F76E 82 83 
0395++ F770             
0396++ F770 56 43 58 5A _shifted        .DB     "VCXZ", 0, 0
0396++ F774 00 00 
0397++ F776 47 46 44 53                 .DB     "GFDSA", 0
0397++ F77A 41 00 
0398++ F77C 54 52 45 57                 .DB     "TREWQ", 0              ; Shift + down?
0398++ F780 51 00 
0399++ F782 25 24 23 22                 .DB     "%$", 35, 34, "!", 0    ; Shift + up
0399++ F786 21 00 
0400++ F788 5E 26 2A 28                 .DB     "^&*()", 0              ; Shift + delete
0400++ F78C 29 00 
0401++ F78E 59 55 49 4F                 .DB     "YUIOP;"
0401++ F792 50 3B 
0402++ F794 48 4A 4B 4C                 .DB     "HJKL,", 0              ; Shift + enter
0402++ F798 2C 00 
0403++ F79A 42 4E 4D 00                 .DB     "BNM", 0,0,0            ; Shift left + right
0403++ F79E 00 00 
0404++ F7A0             
0405++ F7A0 00 03 18 1A _ctrl           .DB    0,KEY_CTRL_C,KEY_CTRL_X,KEY_CTRL_Z,0,0
0405++ F7A4 00 00 
0406++ F7A6 00 00 00 13                 .DB    0,0,0,KEY_CTRL_S,0,0
0406++ F7AA 00 00 
0407++ F7AC 00 12 05 00                 .DB    0,KEY_CTRL_R,KEY_CTRL_E,0,0,KEY_CTRL_DOWN
0407++ F7B0 00 91 
0408++ F7B2 00 00 00 00                 .DB    0,0,0,0,0,KEY_CTRL_UP
0408++ F7B6 00 90 
0409++ F7B8 00 00 00 00                 .DB    0,0,0,0,0,KEY_DELETE
0409++ F7BC 00 7F 
0410++ F7BE 00 15 2B 3D                 .DB    0,KEY_CTRL_U, "+=-", 0
0410++ F7C2 2D 00 
0411++ F7C4 00 3C 40 3E                 .DB    0, "<@>_", KEY_CTRL_ENTER
0411++ F7C8 5F 94 
0412++ F7CA 5C 3F 2F 95                 .DB    "\\?/", KEY_CTRL_SPACE,KEY_CTRL_LEFT,KEY_CTRL_RIGHT
0412++ F7CE 92 93 
0413++ F7D0             
0414++ F7D0 00 00 00 00 _shift_ctrl     .DB    0,0,0,0,0,0
0414++ F7D4 00 00 
0415++ F7D6 00 00 00 00                 .DB    0,0,0,0,0,0
0415++ F7DA 00 00 
0416++ F7DC 00 00 00 00                 .DB    0,0,0,0,0,0
0416++ F7E0 00 00 
0417++ F7E2 00 00 00 00                 .DB    0,0,0,0,0,0
0417++ F7E6 00 00 
0418++ F7E8 00 00 00 00                 .DB    0,0,0,0,0,0
0418++ F7EC 00 00 
0419++ F7EE 00 00 00 00                 .DB    0,0,0,0,KEY_CTRL_P,0
0419++ F7F2 10 00 
0420++ F7F4 00 00 00 00                 .DB    0,0,0,0,0,0
0420++ F7F8 00 00 
0421++ F7FA 00 00 00 00                 .DB    0,0,0,0,0,0
0421++ F7FE 00 00 
1341+  F800                                 .INCLUDE "../uart.asm"
0001++ F800             ;
0002++ F800             ; UART routines..
0003++ F800             ;
0004++ F800             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0005++ F800             ;
0006++ F800             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0007++ F800             ;
0008++ F800             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0009++ F800             ; of this software and associated documentation files (the "Software"), to deal
0010++ F800             ; in the Software without restriction, including without limitation the rights
0011++ F800             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0012++ F800             ; copies of the Software, and to permit persons to whom the Software is
0013++ F800             ; furnished to do so, subject to the following conditions:
0014++ F800             ; 
0015++ F800             ; The above copyright notice and this permission notice shall be included in all
0016++ F800             ; copies or substantial portions of the Software.
0017++ F800             ; 
0018++ F800             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0019++ F800             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0020++ F800             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0021++ F800             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0022++ F800             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0023++ F800             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0024++ F800             ; SOFTWARE.
0025++ F800             ;
0026++ F800                                 .MODULE     uart
0027++ F800             
0028++ F800             ;
0029++ F800             ; Baud rates, assuming 1.8432Mhz crystal
0030++ F800             ;
0031++ F800             UART_9600           .EQU    12
0032++ F800             UART_19200          .EQU    6
0033++ F800             UART_38400          .EQU    3
0034++ F800             
0035++ F800             UART_MODE_AUTO      .EQU    022h   ; Auto flow mode
0036++ F800             UART_MODE_NO_FLOW   .EQU    000h   ; Auto RTS and CTS disabled
0037++ F800             UART_MODE_DIAG      .EQU    030h   ; Loopback mode
0038++ F800             
0039++ F800             ;
0040++ F800             ; Various constants
0041++ F800             ;
0042++ F800             UART_8N1            .EQU    003h
0043++ F800             UART_TIMEOUT        .EQU    50000
0044++ F800             
0045++ F800             _CTS_STATUS_MASK    .EQU    010h
0046++ F800             
0047++ F800             ;
0048++ F800             ; Set up the UART. Assume it has had time to settle after reset...
0049++ F800             ;
0050++ F800             ;
0051++ F800 01 06 00    uart_init           LD      BC, UART_19200              ; B is flow control, 0 -> No auto flow control
0052++ F803             
0053++ F803 DB 26                           IN      A,(UART_MODEM_STATUS)       ; If CTS is enabled, assume we can use flow control
0054++ F805 E6 10                           AND     _CTS_STATUS_MASK
0055++ F807 28 02                           JR      Z, _no_listener
0056++ F809             
0057++ F809 06 22                           LD      B, UART_MODE_AUTO
0058++ F80B                                     
0059++ F80B 3E 80       _no_listener        LD      A, 80h                      ; Divisor Latch Setting Mode
0060++ F80D D3 23                           OUT     (UART_LINE_CTRL), A         ;  - entered by writing 1 to bit 7 of LCR
0061++ F80F 00                              NOP
0062++ F810 00                              NOP
0063++ F811 79                              LD      A, C
0064++ F812 D3 20                           OUT     (UART_TX_RX), A
0065++ F814 00                              NOP
0066++ F815 00                              NOP
0067++ F816 AF                              XOR     A
0068++ F817 D3 21                           OUT     (UART_INT_ENABLE), A
0069++ F819 00                              NOP
0070++ F81A 00                              NOP
0071++ F81B             
0072++ F81B 3E 03                           LD      A, UART_8N1                 ; Set 8N1 and exit divisor latch setting mode
0073++ F81D D3 23                           OUT     (UART_LINE_CTRL), A
0074++ F81F             
0075++ F81F 3E 07                           LD      A, 07h                      ; Enable and clear FIFO registers
0076++ F821 D3 22                           OUT     (UART_FIFO_CTRL), A
0077++ F823             
0078++ F823 78                              LD      A, B
0079++ F824 A7                              AND     A
0080++ F825 28 02                           JR      Z, _no_flowcontrol
0081++ F827             
0082++ F827 D3 24                           OUT     (UART_MODEM_CTRL), A
0083++ F829             
0084++ F829 00          _no_flowcontrol     NOP
0085++ F82A 00                              NOP
0086++ F82B C9                              RET
0087++ F82C             
0088++ F82C             ;
0089++ F82C             ; Send character in A to UART
0090++ F82C             ; Preserves all registers
0091++ F82C             ;
0092++ F82C             ; Carry flag is set on return if the UART send succeeded, clear if it timed out
0093++ F82C             ;
0094++ F82C C5          uart_send           PUSH    BC
0095++ F82D F5                              PUSH    AF
0096++ F82E 01 50 C3                        LD      BC, UART_TIMEOUT
0097++ F831 DB 25       _check_ready        IN      A, (UART_LINE_STATUS)
0098++ F833 CB 6F                           BIT     5, A
0099++ F835 C2 43 F8                        JP      NZ, _uart_ready             ; Bit 5 is set when the UART is ready
0100++ F838 0B                              DEC     BC
0101++ F839 78                              LD      A, B
0102++ F83A B1                              OR      C
0103++ F83B C2 31 F8                        JP      NZ, _check_ready
0104++ F83E             
0105++ F83E F1                              POP     AF
0106++ F83F C1                              POP     BC
0107++ F840 37                              SCF
0108++ F841 3F                              CCF
0109++ F842 C9                              RET
0110++ F843             
0111++ F843 F1          _uart_ready         POP     AF
0112++ F844 C1                              POP     BC
0113++ F845 D3 20                           OUT     (UART_TX_RX), A
0114++ F847 37                              SCF
0115++ F848 C9                              RET
0116++ F849             
0117++ F849             ;
0118++ F849             ; Check to see if there are any characters to receive
0119++ F849             ; Preserves all registers
0120++ F849             ;
0121++ F849             ; Returns with carry set if there are characters ready, clear if not
0122++ F849             ;
0123++ F849 F5          uart_ready          PUSH    AF
0124++ F84A DB 25                           IN      A, (UART_LINE_STATUS)
0125++ F84C CB 47                           BIT     0, A
0126++ F84E CA 54 F8                        JP      Z, _not_ready
0127++ F851 F1                              POP     AF
0128++ F852 37                              SCF
0129++ F853 C9                              RET
0130++ F854             
0131++ F854 F1          _not_ready          POP     AF
0132++ F855 37                              SCF
0133++ F856 3F                              CCF
0134++ F857 C9                              RET
0135++ F858             
0136++ F858             ;
0137++ F858             ; Receive a character from the UART in A
0138++ F858             ; 
0139++ F858             ; Returns with a character in A and the carry flag set. If no characters
0140++ F858             ; are available, returns with the carry flag clear.
0141++ F858             ;
0142++ F858 DB 25       uart_receive        IN      A, (UART_LINE_STATUS)
0143++ F85A CB 47                           BIT     0, A
0144++ F85C CA 63 F8                        JP      Z, _no_character
0145++ F85F DB 20                           IN      A, (UART_TX_RX)
0146++ F861 37                              SCF
0147++ F862 C9                              RET
0148++ F863             
0149++ F863 37          _no_character       SCF
0150++ F864 3F                              CCF
0151++ F865 C9                              RET
0152++ F866             
0153++ F866             ;
0154++ F866             ; Write A as a hex byte
0155++ F866             ; Overwrites A...
0156++ F866             ;
0157++ F866 F5          uart_hex            PUSH    AF
0158++ F867 CB 2F                           SRA     A
0159++ F869 CB 2F                           SRA     A
0160++ F86B CB 2F                           SRA     A
0161++ F86D CB 2F                           SRA     A
0162++ F86F CD 7C F8                        CALL    to_hex
0163++ F872 CD 2C F8                        CALL    uart_send
0164++ F875 F1                              POP     AF
0165++ F876 CD 7C F8                        CALL    to_hex
0166++ F879 C3 2C F8                        JP      uart_send
0167++ F87C             ;
0168++ F87C             ; Returns the low nibble of A as a hex digit
0169++ F87C             ;
0170++ F87C E6 0F       to_hex              AND $0F      ;LOW NIBBLE ONLY
0171++ F87E C6 90                           ADD A,$90
0172++ F880 27                              DAA 
0173++ F881 CE 40                           ADC A,$40
0174++ F883 27                              DAA 
0175++ F884 C9                              RET 
0176++ F885             ;
0177++ F885             ; Inline send. Sends the zero terminated string immediately following the call to this function to the UART.
0178++ F885             ;  e.g.             CALL    uart_inline
0179++ F885             ;                   .DB     "My text to send", 0
0180++ F885             ;                   <code continues after message...>
0181++ F885             ; Returns with Carry set if the string was successfully sent, otherwise, carry is clear.
0182++ F885             ;
0183++ F885             ; Uses A 
0184++ F885             ;
0185++ F885 E3          uart_inline         EX      (SP), HL
0186++ F886 CD 94 F8                        CALL    uart_string
0187++ F889 DA 92 F8                        JP      C, _inline_end      
0188++ F88C 7E          _find_end           LD      A, (HL)             ; Get the current character  (Carry preserved)
0189++ F88D 23                              INC     HL                  ; Point to next character    (Carry preserved)
0190++ F88E A7                              AND     A                   ; Test if the current character was zero (Clears carry)
0191++ F88F C2 8C F8                        JP      NZ, _find_end       ; If it was, we're done, otherwise repeat
0192++ F892 E3          _inline_end         EX      (SP), HL
0193++ F893 C9                              RET
0194++ F894             ;
0195++ F894             ; Send a zero terminated string pointed to by HL to the UART
0196++ F894             ;
0197++ F894             ; Returns with Carry Set if the string was sent sucessfully, clear otherwise
0198++ F894             ;                    
0199++ F894 7E          uart_string         LD      A,(HL)
0200++ F895 23                              INC     HL
0201++ F896 A7                              AND     A
0202++ F897 CA A1 F8                        JP      Z, _string_end
0203++ F89A CD 2C F8                        CALL    uart_send
0204++ F89D DA 94 F8                        JP      C, uart_string
0205++ F8A0 C9                              RET
0206++ F8A1 37          _string_end         SCF
0207++ F8A2 C9                              RET
0208++ F8A3             
0209++ F8A3                                 .MODULE main1342+  F8A3                                 .INCLUDE "../i2c.asm"
0001++ F8A3             ; ============================================ I2C Routines =================================================
0002++ F8A3             ; Software driven I2C for Z80 PIO
0003++ F8A3             ;
0004++ F8A3             ; Assume I2C clock is on Port B bit 6
0005++ F8A3             ;            data is on Port B bit 7
0006++ F8A3             ;
0007++ F8A3             ;
0008++ F8A3             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0009++ F8A3             ;
0010++ F8A3             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0011++ F8A3             ;
0012++ F8A3             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0013++ F8A3             ; of this software and associated documentation files (the "Software"), to deal
0014++ F8A3             ; in the Software without restriction, including without limitation the rights
0015++ F8A3             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0016++ F8A3             ; copies of the Software, and to permit persons to whom the Software is
0017++ F8A3             ; furnished to do so, subject to the following conditions:
0018++ F8A3             ; 
0019++ F8A3             ; The above copyright notice and this permission notice shall be included in all
0020++ F8A3             ; copies or substantial portions of the Software.
0021++ F8A3             ; 
0022++ F8A3             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0023++ F8A3             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0024++ F8A3             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0025++ F8A3             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0026++ F8A3             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0027++ F8A3             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0028++ F8A3             ; SOFTWARE.
0029++ F8A3             ;
0030++ F8A3                                 .MODULE i2c
0031++ F8A3             
0032++ F8A3 3E CF       init_portb          LD      A, PIO_MODE_3           ; Port B mode 3
0033++ F8A5 32 00 FF                        LD      (port_b_mode), A
0034++ F8A8 D3 13                           OUT     (PIO_B_CTRL), A
0035++ F8AA             
0036++ F8AA 3E FF                           LD      A, PORT_B_IOMASK        ;
0037++ F8AC 32 01 FF                        LD      (port_b_dir), A
0038++ F8AF D3 13                           OUT     (PIO_B_CTRL), A
0039++ F8B1             
0040++ F8B1 3E 3F                           LD      A, 03Fh                 ; All bits high apart from D7, D6
0041++ F8B3 32 02 FF                        LD      (port_b_data),A
0042++ F8B6 D3 11                           OUT     (PIO_B_DATA), A         ; Changing D7 or D6 to an output will drive the lines low
0043++ F8B8 C9                              RET
0044++ F8B9             
0045++ F8B9             ; Reset the bus
0046++ F8B9             ;
0047++ F8B9             ; Uses A, B, D
0048++ F8B9 06 0A       i2c_bus_reset       LD      B, 0ah          ; ten cycles
0049++ F8BB CD C6 F9    _loop_b             CALL    i2c_scl_cycle
0050++ F8BE 10 FB                           DJNZ    _loop_b
0051++ F8C0 CD B6 F9                        CALL    i2c_scl_high
0052++ F8C3 06 F0                           LD      B, 0F0h
0053++ F8C5 10 FE                           DJNZ    $
0054++ F8C7 C9                              RET
0055++ F8C8             
0056++ F8C8             ;
0057++ F8C8             ; Uses A
0058++ F8C8 CD 96 F9    i2c_start           CALL    i2c_sda_high
0059++ F8CB CD B6 F9                        CALL    i2c_scl_high
0060++ F8CE CD A6 F9                        CALL    i2c_sda_low     ; Drive data low
0061++ F8D1 C3 86 F9                        JP      i2c_scl_low     ; Drive clock low
0062++ F8D4             
0063++ F8D4             ;
0064++ F8D4             ; Uses A
0065++ F8D4 CD A6 F9    i2c_stop            CALL    i2c_sda_low     ; Drive data low
0066++ F8D7 CD B6 F9                        CALL    i2c_scl_high
0067++ F8DA C3 96 F9                        JP      i2c_sda_high
0068++ F8DD             
0069++ F8DD             ;
0070++ F8DD             ; Read a byte from Device address H, Register L
0071++ F8DD             ; Calls i2c_start, but does NOT call i2c_stop
0072++ F8DD             ; Returns With Carry SET and A containing the register value, or Carry CLEAR if no acknowledge
0073++ F8DD             ; Uses A, B, C, D, H, L
0074++ F8DD             ; Preserves H, L
0075++ F8DD CD C8 F8    i2c_read_from       CALL    i2c_start
0076++ F8E0 7C                              LD      A, H
0077++ F8E1 CD 10 F9                        CALL    i2c_address_w
0078++ F8E4 30 17                           JR      NC, _read_end
0079++ F8E6 7D                              LD      A, L
0080++ F8E7 CD 12 F9                        CALL    i2c_write
0081++ F8EA 30 11                           JR      NC, _read_end
0082++ F8EC 06 32                           LD      B, 50
0083++ F8EE 10 FE       _read_pause         DJNZ    _read_pause
0084++ F8F0 CD C8 F8                        CALL    i2c_start
0085++ F8F3 7C                              LD      A, H
0086++ F8F4 CD 0A F9                        CALL    i2c_address_r
0087++ F8F7 30 04                           JR      NC, _read_end
0088++ F8F9 CD 1F F9                        CALL    i2c_read
0089++ F8FC 37                              SCF
0090++ F8FD C9          _read_end           RET
0091++ F8FE             
0092++ F8FE             ;
0093++ F8FE             ; Prepare to write to Device address H, Register L
0094++ F8FE             ; Calls i2c_start, but does NOT call i2c_stop
0095++ F8FE             ; Returns with Carry SET if OK, CLEAR if no acknowledgement
0096++ F8FE             ;
0097++ F8FE             ; Preserves H, L
0098++ F8FE CD C8 F8    i2c_write_to        CALL    i2c_start
0099++ F901 7C                              LD      A, H
0100++ F902 CD 10 F9                        CALL    i2c_address_w
0101++ F905 D0                              RET     NC
0102++ F906 7D                              LD      A, L
0103++ F907 C3 12 F9                        JP      i2c_write
0104++ F90A             
0105++ F90A             ; Start reading from device address held in A
0106++ F90A             ;
0107++ F90A             ; Uses A, B, C, D
0108++ F90A CB 27       i2c_address_r       SLA     A
0109++ F90C F6 01                           OR      1
0110++ F90E 18 02                           JR      i2c_write
0111++ F910             
0112++ F910             ; Start writing to device address held in A
0113++ F910             ;
0114++ F910             ; Uses A, B, C, D
0115++ F910 CB 27       i2c_address_w       SLA     A
0116++ F912             
0117++ F912             ; Write A as a byte to i2c bus
0118++ F912             ; Returns Carry CLEAR if no acknowledge
0119++ F912             ;
0120++ F912             ; Uses A, B, C, D
0121++ F912 CD 3A F9    i2c_write           CALL    i2c_send_byte
0122++ F915 CB 7A                           BIT     I2C_DATA_BIT, D     ; D contains acknowledge bit
0123++ F917 37                              SCF
0124++ F918 C8                              RET     Z               ; Return with carry set if acknowledge bit is low
0125++ F919             
0126++ F919 CD D4 F8                        CALL    i2c_stop        ; Stop bus if error
0127++ F91C 37                              SCF
0128++ F91D 3F                              CCF
0129++ F91E C9                              RET                     ; Clear carry if acknowledge is high
0130++ F91F             
0131++ F91F             ; Read byte from i2C into A, without ACK
0132++ F91F             ;
0133++ F91F             ; Uses A, B, C, D
0134++ F91F 06 08       i2c_read            LD      B, 8h
0135++ F921 DB 11       _loop_r             IN      A, (PIO_B_DATA)
0136++ F923 37                              SCF
0137++ F924 CB 7F                           BIT     I2C_DATA_BIT, A
0138++ F926 20 01                           JR      NZ, _data_high
0139++ F928 3F                              CCF
0140++ F929 CB 11       _data_high          RL      C
0141++ F92B CD C6 F9                        CALL    i2c_scl_cycle
0142++ F92E 10 F1                           DJNZ    _loop_r
0143++ F930                                 ; CALL    i2c_scl_cycle
0144++ F930             
0145++ F930 79                              LD      A, C
0146++ F931 C9                              RET
0147++ F932             
0148++ F932             ;
0149++ F932             ; Send an ACK..
0150++ F932             ;
0151++ F932 CD A6 F9    i2c_ack             CALL    i2c_sda_low
0152++ F935 CD C6 F9                        CALL    i2c_scl_cycle
0153++ F938 18 5C                           JR      i2c_sda_high
0154++ F93A             
0155++ F93A             ;
0156++ F93A             ; Send a byte in A, returning the ACK state in D
0157++ F93A             ; Uses A, B, C,
0158++ F93A             ;
0159++ F93A E5          i2c_send_byte       PUSH    HL
0160++ F93B D5                              PUSH    DE
0161++ F93C 2A 00 FF                        LD      HL, (port_b_mode)           ; L = port_b_mode, H = port_b_dir
0162++ F93F 57                              LD      D, A
0163++ F940                                 
0164++ F940 3E 3F                           LD      A, ~(I2C_DATA_MASK|I2C_CLK_MASK)           ; Set SDA and SCL (port_b_dir bit) LOW
0165++ F942 A4                              AND     H
0166++ F943 CB 27                           SLA     A
0167++ F945 67                              LD      H, A
0168++ F946             
0169++ F946 0E 13                           LD      C, PIO_B_CTRL
0170++ F948 06 08                           LD      B, 8
0171++ F94A             
0172++ F94A 1E 40                           LD      E, I2C_CLK_MASK
0173++ F94C             
0174++ F94C 7C          _fast_loop          LD      A, H
0175++ F94D CB 22                           SLA     D
0176++ F94F CB 1F                           RR      A
0177++ F951 ED 69                           OUT     (C),L
0178++ F953 D3 13                           OUT     (PIO_B_CTRL), A
0179++ F955             
0180++ F955 B3                              OR      E
0181++ F956 ED 69                           OUT     (C), L
0182++ F958 D3 13                           OUT     (PIO_B_CTRL), A                 ; Clock high
0183++ F95A             
0184++ F95A AB                              XOR     E
0185++ F95B ED 69                           OUT     (C), L
0186++ F95D D3 13                           OUT     (PIO_B_CTRL),A                  ; Clock low
0187++ F95F 10 EB                           DJNZ    _fast_loop
0188++ F961             
0189++ F961 7C                              LD      A, H
0190++ F962 37                              SCF
0191++ F963 CB 1F                           RR      A
0192++ F965 ED 69                           OUT     (C),L                           ; Release SDA
0193++ F967 D3 13                           OUT     (PIO_B_CTRL), A
0194++ F969             
0195++ F969 B3                              OR      E
0196++ F96A ED 69                           OUT     (C), L
0197++ F96C D3 13                           OUT     (PIO_B_CTRL), A                 ; Clock high
0198++ F96E             
0199++ F96E ED 69                           OUT     (C), L
0200++ F970 AB                              XOR     E
0201++ F971 6F                              LD      L, A
0202++ F972 32 01 FF                        LD      (port_b_dir), A
0203++ F975             
0204++ F975 DB 11                           IN      A, (PIO_B_DATA)                 ; Read ACK
0205++ F977 ED 69                           OUT     (C),L                           ; Clock low
0206++ F979             
0207++ F979 D1                              POP     DE
0208++ F97A E1                              POP     HL
0209++ F97B 57                              LD      D, A
0210++ F97C C9                              RET
0211++ F97D             
0212++ F97D             ; Cycle SCL, returning SDA,SCL in D
0213++ F97D             ;
0214++ F97D             ; Uses A, D
0215++ F97D CD 86 F9    i2c_scl_cycle2      CALL    i2c_scl_low
0216++ F980 CD B6 F9                        CALL    i2c_scl_high
0217++ F983 DB 11                           IN      A, (PIO_B_DATA)
0218++ F985 57                              LD      D, A
0219++ F986                                 ; Fall into scl_low...
0220++ F986             
0221++ F986             ; SCL/SDA toggle routines
0222++ F986             ;
0223++ F986             ; All use A
0224++ F986 3A 00 FF    i2c_scl_low         LD      A, (port_b_mode)
0225++ F989 D3 13                           OUT     (PIO_B_CTRL), A
0226++ F98B             
0227++ F98B 3A 01 FF                        LD      A, (port_b_dir)
0228++ F98E CB B7                           RES     I2C_CLK_BIT, A
0229++ F990 D3 13                           OUT     (PIO_B_CTRL), A
0230++ F992 32 01 FF                        LD      (port_b_dir), A
0231++ F995 C9                              RET
0232++ F996             
0233++ F996 3A 00 FF    i2c_sda_high        LD      A, (port_b_mode)
0234++ F999 D3 13                           OUT     (PIO_B_CTRL), A
0235++ F99B             
0236++ F99B 3A 01 FF                        LD      A, (port_b_dir)
0237++ F99E CB FF                           SET     I2C_DATA_BIT, A
0238++ F9A0 D3 13                           OUT     (PIO_B_CTRL), A
0239++ F9A2 32 01 FF                        LD      (port_b_dir), A
0240++ F9A5 C9                              RET
0241++ F9A6             
0242++ F9A6 3A 00 FF    i2c_sda_low         LD      A, (port_b_mode)
0243++ F9A9 D3 13                           OUT     (PIO_B_CTRL), A
0244++ F9AB             
0245++ F9AB 3A 01 FF                        LD      A, (port_b_dir)
0246++ F9AE CB BF                           RES     I2C_DATA_BIT, A
0247++ F9B0 D3 13                           OUT     (PIO_B_CTRL), A
0248++ F9B2 32 01 FF                        LD      (port_b_dir), A
0249++ F9B5 C9                              RET
0250++ F9B6             
0251++ F9B6 3A 00 FF    i2c_scl_high        LD      A, (port_b_mode)
0252++ F9B9 D3 13                           OUT     (PIO_B_CTRL), A
0253++ F9BB             
0254++ F9BB 3A 01 FF                        LD      A, (port_b_dir)
0255++ F9BE CB F7                           SET     I2C_CLK_BIT, A
0256++ F9C0 D3 13                           OUT     (PIO_B_CTRL), A
0257++ F9C2 32 01 FF                        LD      (port_b_dir), A
0258++ F9C5 C9                              RET
0259++ F9C6             
0260++ F9C6 C5          i2c_scl_cycle       PUSH   BC
0261++ F9C7 01 13 00                        LD     BC, PIO_B_CTRL
0262++ F9CA 3A 00 FF                        LD     A, (port_b_mode)
0263++ F9CD 57                              LD     D, A
0264++ F9CE 3A 01 FF                        LD     A, (port_b_dir)
0265++ F9D1             
0266++ F9D1 CB B7                           RES    I2C_CLK_BIT, A
0267++ F9D3 32 01 FF                        LD     (port_b_dir), A
0268++ F9D6 ED 51                           OUT    (C), D
0269++ F9D8 D3 13                           OUT    (PIO_B_CTRL), A
0270++ F9DA                                 
0271++ F9DA CB F7                           SET    I2C_CLK_BIT, A
0272++ F9DC ED 51                           OUT    (C), D
0273++ F9DE D3 13                           OUT    (PIO_B_CTRL), A
0274++ F9E0                                 
0275++ F9E0 DB 11                           IN     A, (PIO_B_DATA)
0276++ F9E2 ED 51                           OUT    (C), D
0277++ F9E4 57                              LD     D, A
0278++ F9E5 3A 01 FF                        LD     A, (port_b_dir)
0279++ F9E8 D3 13                           OUT    (PIO_B_CTRL), A
0280++ F9EA C1                              POP    BC
0281++ F9EB C9                              RET
0282++ F9EC             
0283++ F9EC                                 .MODULE main
1343+  F9EC             
1344+  F9EC                                 .INCLUDE "../disp.asm"
0001++ F9EC             ; ========================================== Display Routines ===============================================
0002++ F9EC             ;
0003++ F9EC             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0004++ F9EC             ;
0005++ F9EC             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0006++ F9EC             ;
0007++ F9EC             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0008++ F9EC             ; of this software and associated documentation files (the "Software"), to deal
0009++ F9EC             ; in the Software without restriction, including without limitation the rights
0010++ F9EC             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0011++ F9EC             ; copies of the Software, and to permit persons to whom the Software is
0012++ F9EC             ; furnished to do so, subject to the following conditions:
0013++ F9EC             ; 
0014++ F9EC             ; The above copyright notice and this permission notice shall be included in all
0015++ F9EC             ; copies or substantial portions of the Software.
0016++ F9EC             ; 
0017++ F9EC             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0018++ F9EC             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0019++ F9EC             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0020++ F9EC             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0021++ F9EC             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0022++ F9EC             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0023++ F9EC             ; SOFTWARE.
0024++ F9EC             ;
0025++ F9EC                                 .MODULE disp
0026++ F9EC             
0027++ F9EC             CONFIG_PAGE         .EQU    3
0028++ F9EC             BRIGHT_PAGE         .EQU    1
0029++ F9EC             LED_PAGE            .EQU    0 
0030++ F9EC             
0031++ F9EC CD 54 FB    display_init        CALL    disp_clear
0032++ F9EF 1E 80                           LD      E, DISP_DEFAULT_BRIGHTNESS
0033++ F9F1 CD 2C FA                        CALL    disp_brightness
0034++ F9F4             
0035++ F9F4 CD 00 FA                        CALL    disp_select_l
0036++ F9F7 CD 0C FA                        CALL    disp_config
0037++ F9FA             
0038++ F9FA CD 06 FA                        CALL    disp_select_r
0039++ F9FD CD 0C FA                        CALL    disp_config
0040++ FA00             
0041++ FA00 3E 50       disp_select_l       LD      A, DL_ADDRESS
0042++ FA02 32 03 FF                        LD      (display_address), A
0043++ FA05 C9                              RET
0044++ FA06             
0045++ FA06 3E 53       disp_select_r       LD      A, DR_ADDRESS
0046++ FA08 32 03 FF                        LD      (display_address), A
0047++ FA0B C9                              RET
0048++ FA0C             
0049++ FA0C 2E 03       disp_config         LD      L, CONFIG_PAGE
0050++ FA0E CD 67 FA                        CALL    disp_page
0051++ FA11 CD C8 F8                        CALL    i2c_start
0052++ FA14 3A 03 FF                        LD      A, (display_address)
0053++ FA17 CD 10 F9                        CALL    i2c_address_w
0054++ FA1A 3E 00                           LD      A, 000h
0055++ FA1C CD 12 F9                        CALL    i2c_write
0056++ FA1F 3E 01                           LD      A, 001h         ; Turn display on
0057++ FA21 CD 12 F9                        CALL    i2c_write
0058++ FA24 3E 78                           LD      A, 078h         ; 0.020mA
0059++ FA26 CD 12 F9                        CALL    i2c_write
0060++ FA29 C3 D4 F8                        JP      i2c_stop
0061++ FA2C             
0062++ FA2C             ;
0063++ FA2C             ; Sets the brightness for the display
0064++ FA2C             ; Enter with E set to the desired brightness for all segments
0065++ FA2C             ;
0066++ FA2C CD 00 FA    disp_brightness     CALL    disp_select_l
0067++ FA2F CD 35 FA                        CALL    _set_bright
0068++ FA32 CD 06 FA                        CALL    disp_select_r
0069++ FA35 2E 01       _set_bright         LD      L, BRIGHT_PAGE
0070++ FA37 CD 67 FA                        CALL    disp_page
0071++ FA3A 2E 0C                           LD      L, 12
0072++ FA3C CD C8 F8    _bright_loop        CALL    i2c_start
0073++ FA3F 3A 03 FF                        LD      A, (display_address)
0074++ FA42 CD 10 F9                        CALL    i2c_address_w
0075++ FA45 7D                              LD      A, L
0076++ FA46 3D                              DEC     A
0077++ FA47 CB 27                           SLA     A
0078++ FA49 CB 27                           SLA     A
0079++ FA4B CB 27                           SLA     A
0080++ FA4D CB 27                           SLA     A
0081++ FA4F CD 12 F9                        CALL    i2c_write
0082++ FA52 26 10                           LD      H, 010h
0083++ FA54 7B          _bright_byte        LD      A, E
0084++ FA55 CD 12 F9                        CALL    i2c_write
0085++ FA58 25                              DEC     H
0086++ FA59 20 F9                           JR      NZ, _bright_byte
0087++ FA5B CD D4 F8                        CALL    i2c_stop
0088++ FA5E 2D                              DEC     L
0089++ FA5F 20 DB                           JR      NZ, _bright_loop
0090++ FA61 2E 00                           LD      L, LED_PAGE
0091++ FA63 CD 67 FA                        CALL    disp_page
0092++ FA66 C9                              RET
0093++ FA67             
0094++ FA67             ; Set the Page number
0095++ FA67             ; Call with page number in L
0096++ FA67             ;
0097++ FA67             ; Uses A, B, C, D
0098++ FA67 CD 7F FA    disp_page           CALL    disp_unlock
0099++ FA6A CD C8 F8                        CALL    i2c_start
0100++ FA6D 3A 03 FF                        LD      A, (display_address)
0101++ FA70 CD 10 F9                        CALL    i2c_address_w
0102++ FA73 3E FD                           LD      A, 0FDh
0103++ FA75 CD 12 F9                        CALL    i2c_write
0104++ FA78 7D                              LD      A, L
0105++ FA79 CD 12 F9                        CALL    i2c_write
0106++ FA7C C3 D4 F8                        JP      i2c_stop
0107++ FA7F             
0108++ FA7F CD C8 F8    disp_unlock         CALL    i2c_start           ; Must be called before switching pages
0109++ FA82 3A 03 FF                        LD      A, (display_address)
0110++ FA85 CD 10 F9                        CALL    i2c_address_w
0111++ FA88 3E FE                           LD      A, DISP_REG_CRWL
0112++ FA8A CD 12 F9                        CALL    i2c_write
0113++ FA8D 3E C5                           LD      A, DISP_UNLOCK
0114++ FA8F CD 12 F9                        CALL    i2c_write
0115++ FA92 C3 D4 F8                        JP      i2c_stop
0116++ FA95             
0117++ FA95             ; Set the character at column A to brightness C
0118++ FA95             ;
0119++ FA95             ;
0120++ FA95 C5          disp_char_bright    PUSH    BC
0121++ FA96 06 50                           LD      B, DL_ADDRESS
0122++ FA98 FE 0C                           CP      12
0123++ FA9A DA A1 FA                        JP      C, _bright_left
0124++ FA9D 06 53                           LD      B, DR_ADDRESS
0125++ FA9F D6 0C                           SUB     12
0126++ FAA1 5F          _bright_left        LD      E, A
0127++ FAA2 78                              LD      A, B
0128++ FAA3 32 03 FF                        LD      (display_address), A
0129++ FAA6 2E 01                           LD      L, BRIGHT_PAGE
0130++ FAA8 CD 67 FA                        CALL    disp_page
0131++ FAAB             
0132++ FAAB CD C8 F8                        CALL    i2c_start
0133++ FAAE 3A 03 FF                        LD      A, (display_address)
0134++ FAB1 CD 10 F9                        CALL    i2c_address_w
0135++ FAB4 7B                              LD      A, E
0136++ FAB5 CB 27                           SLA     A
0137++ FAB7 CB 27                           SLA     A
0138++ FAB9 CB 27                           SLA     A
0139++ FABB CB 27                           SLA     A
0140++ FABD CD 12 F9                        CALL    i2c_write
0141++ FAC0 E1                              POP     HL
0142++ FAC1 26 10                           LD      H, 010h
0143++ FAC3 7D          _bright_char_loop   LD      A, L
0144++ FAC4 CD 12 F9                        CALL    i2c_write
0145++ FAC7 25                              DEC     H
0146++ FAC8 20 F9                           JR      NZ, _bright_char_loop
0147++ FACA CD D4 F8                        CALL    i2c_stop
0148++ FACD             
0149++ FACD 2E 00                           LD      L, LED_PAGE
0150++ FACF CD 67 FA                        CALL    disp_page
0151++ FAD2 C9                              RET
0152++ FAD3                                 
0153++ FAD3             ; Display a single character A at column C
0154++ FAD3             ;
0155++ FAD3             ; Returns with A pointing to next column
0156++ FAD3             ;
0157++ FAD3 FE 20       disp_character      CP      32
0158++ FAD5 F2 DF FA                        JP      P, _not_control
0159++ FAD8             
0160++ FAD8 21 61 48    _invalid_char       LD      HL, INVALID_CHAR_BITMASK
0161++ FADB 79                              LD      A, C
0162++ FADC C3 F4 FA                        JP      disp_bitmask
0163++ FADF             
0164++ FADF CB 7F       _not_control        BIT     7, A
0165++ FAE1 C2 D8 FA                        JP      NZ, _invalid_char
0166++ FAE4 D6 20                           SUB     32
0167++ FAE6             
0168++ FAE6 16 00                           LD      D, 0
0169++ FAE8 5F                              LD      E, A
0170++ FAE9 CB 23                           SLA     E                   ; Don't need to shift into D, since bit 7 is zero
0171++ FAEB 21 62 FB                        LD      HL, font  
0172++ FAEE 19                              ADD     HL, DE
0173++ FAEF 56                              LD      D, (HL)
0174++ FAF0 23                              INC     HL
0175++ FAF1 66                              LD      H, (HL)
0176++ FAF2 6A                              LD      L, D
0177++ FAF3 79                              LD      A, C
0178++ FAF4                                 ; Fall into disp_bitmask
0179++ FAF4             
0180++ FAF4             ; Display a bitmask in HL at column A (0 - 23)
0181++ FAF4             ;
0182++ FAF4             ; Returns with A pointing to next column
0183++ FAF4             ;
0184++ FAF4             ; Uses A, B, C, D, E
0185++ FAF4 F5          disp_bitmask        PUSH    AF
0186++ FAF5 06 50                           LD      B, DL_ADDRESS
0187++ FAF7 FE 0C                           CP      12
0188++ FAF9 DA 00 FB                        JP      C, _disp_left
0189++ FAFC 06 53                           LD      B, DR_ADDRESS
0190++ FAFE D6 0C                           SUB     12
0191++ FB00 5F          _disp_left          LD      E, A
0192++ FB01 CD C8 F8                        CALL    i2c_start
0193++ FB04 78                              LD      A, B
0194++ FB05 CD 10 F9                        CALL    i2c_address_w
0195++ FB08 7B                              LD      A, E
0196++ FB09 CB 27                           SLA     A
0197++ FB0B CD 12 F9                        CALL    i2c_write
0198++ FB0E 7D                              LD      A, L
0199++ FB0F CD 12 F9                        CALL    i2c_write
0200++ FB12 7C                              LD      A, H
0201++ FB13 CD 12 F9                        CALL    i2c_write
0202++ FB16 CD D4 F8                        CALL    i2c_stop
0203++ FB19 F1                              POP     AF
0204++ FB1A 3C                              INC     A
0205++ FB1B C9                              RET
0206++ FB1C             
0207++ FB1C             
0208++ FB1C C3 F4 FA                        JP      disp_bitmask
0209++ FB1F             ;
0210++ FB1F             ; Clear the display and show an inline string from column 0
0211++ FB1F             ;
0212++ FB1F CD 54 FB    disp_clear_inline   CALL    disp_clear
0213++ FB22 AF                              XOR     A
0214++ FB23             ;
0215++ FB23             ; Display an inline string to column A->
0216++ FB23             ;
0217++ FB23 E3          disp_inline         EX      (SP), HL
0218++ FB24 CD 2A FB                        CALL    disp_string
0219++ FB27 23                              INC     HL
0220++ FB28 E3                              EX      (SP), HL
0221++ FB29 C9                              RET
0222++ FB2A             
0223++ FB2A             ; Display a string pointed to by HL to column A->
0224++ FB2A             ; Note string should be zero terminated...
0225++ FB2A             ; Returns with HL pointing to the 0 terminator
0226++ FB2A             ;
0227++ FB2A 5F          disp_string         LD      E, A
0228++ FB2B 7E                              LD      A, (HL)
0229++ FB2C B7                              OR      A
0230++ FB2D C2 31 FB                        JP      NZ, _char_ok
0231++ FB30 C9                              RET
0232++ FB31             
0233++ FB31 D6 20       _char_ok            SUB     32
0234++ FB33 F2 3B FB                        JP      P, _char_ok2
0235++ FB36 21 61 48                        LD      HL, INVALID_CHAR_BITMASK
0236++ FB39 18 10                           JR      _show_char
0237++ FB3B             
0238++ FB3B 06 00       _char_ok2           LD      B, 0
0239++ FB3D 4F                              LD      C, A
0240++ FB3E E5                              PUSH    HL
0241++ FB3F 21 62 FB                        LD      HL, font
0242++ FB42 CB 21                           SLA     C
0243++ FB44 CB 10                           RL      B
0244++ FB46 09                              ADD     HL, BC
0245++ FB47 4E                              LD      C, (HL)
0246++ FB48 23                              INC     HL
0247++ FB49 66                              LD      H, (HL)
0248++ FB4A 69                              LD      L, C
0249++ FB4B 7B          _show_char          LD      A, E
0250++ FB4C CD F4 FA                        CALL    disp_bitmask
0251++ FB4F E1                              POP     HL
0252++ FB50 23                              INC     HL
0253++ FB51 C3 2A FB                        JP      disp_string
0254++ FB54             
0255++ FB54             ; Clear the display
0256++ FB54             ;
0257++ FB54 3E 00       disp_clear          LD      A, 0
0258++ FB56 21 00 00                        LD      HL, 0
0259++ FB59 CD F4 FA    _clear_loop         CALL    disp_bitmask
0260++ FB5C FE 18                           CP      24
0261++ FB5E C2 59 FB                        JP      NZ, _clear_loop
0262++ FB61 C9                              RET
0263++ FB62             
0264++ FB62                                 .MODULE main1345+  FB62                                 .INCLUDE "../font.asm"
0001++ FB62             ;
0002++ FB62             ; Font definition
0003++ FB62             ;
0004++ FB62             ;
0005++ FB62             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0006++ FB62             ;
0007++ FB62             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0008++ FB62             ;
0009++ FB62             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0010++ FB62             ; of this software and associated documentation files (the "Software"), to deal
0011++ FB62             ; in the Software without restriction, including without limitation the rights
0012++ FB62             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0013++ FB62             ; copies of the Software, and to permit persons to whom the Software is
0014++ FB62             ; furnished to do so, subject to the following conditions:
0015++ FB62             ; 
0016++ FB62             ; The above copyright notice and this permission notice shall be included in all
0017++ FB62             ; copies or substantial portions of the Software.
0018++ FB62             ; 
0019++ FB62             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0020++ FB62             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0021++ FB62             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0022++ FB62             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0023++ FB62             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0024++ FB62             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0025++ FB62             ; SOFTWARE.
0026++ FB62             ;
0027++ FB62             
0028++ FB62             INVALID_CHAR_BITMASK    .EQU 04861h
0029++ FB62             
0030++ FB62             font
0031++ FB62 00 00                           .dw     0000h
0032++ FB64 00 49                           .dw     4900h   ; !
0033++ FB66 02 02                           .dw     0202h   ; "
0034++ FB68 CE 12                           .dw     12ceh   ; #
0035++ FB6A ED 12                           .dw     12edh   ; $
0036++ FB6C E4 2D                           .dw     2de4h   ; %
0037++ FB6E 59 0B                           .dw     0b59h   ; &
0038++ FB70 00 02                           .dw     0200h   ; '
0039++ FB72 00 0C                           .dw     0c00h   ; (
0040++ FB74 00 21                           .dw     2100h   ; )
0041++ FB76 C0 3F                           .dw     3fc0h   ; *
0042++ FB78 C0 12                           .dw     12c0h   ; +
0043++ FB7A 00 20                           .dw     2000h   ; ,
0044++ FB7C C0 00                           .dw     00c0h   ; -
0045++ FB7E 00 40                           .dw     4000h   ; .
0046++ FB80 00 24                           .dw     2400h   ; /
0047++ FB82             
0048++ FB82 3F 24                           .dw     243fh   ; 0
0049++ FB84 06 04                           .dw     0406h   ; 1
0050++ FB86 DB 00                           .dw     00dbh   ; 2
0051++ FB88 8F 00                           .dw     008fh   ; 3
0052++ FB8A E6 00                           .dw     00e6h   ; 4
0053++ FB8C 69 08                           .dw     0869h   ; 5
0054++ FB8E FD 00                           .dw     00fdh   ; 6
0055++ FB90 01 14                           .dw     1401h   ; 7
0056++ FB92 FF 00                           .dw     00ffh   ; 8
0057++ FB94 EF 00                           .dw     00efh   ; 9
0058++ FB96 40 00                           .dw     0040h   ; :
0059++ FB98 00 22                           .dw     2200h   ; ;
0060++ FB9A 40 0C                           .dw     0c40h   ; <
0061++ FB9C C8 00                           .dw     00c8h   ; = 
0062++ FB9E 80 21                           .dw     2180h   ; >
0063++ FBA0 83 50                           .dw     5083h   ; ?
0064++ FBA2             
0065++ FBA2 BB 02                           .dw     02bbh   ; @
0066++ FBA4 F7 00                           .dw     00f7h   ; A
0067++ FBA6 8F 12                           .dw     128fh   ; B
0068++ FBA8 39 00                           .dw     0039h   ; C
0069++ FBAA 0F 12                           .dw     120fh   ; D
0070++ FBAC 79 00                           .dw     0079h   ; E
0071++ FBAE 71 00                           .dw     0071h   ; F
0072++ FBB0 BD 00                           .dw     00bdh   ; G
0073++ FBB2 F6 00                           .dw     00f6h   ; H
0074++ FBB4 09 12                           .dw     1209h   ; I
0075++ FBB6 1E 00                           .dw     001eh   ; J
0076++ FBB8 70 0C                           .dw     0c70h   ; K
0077++ FBBA 38 00                           .dw     0038h   ; L
0078++ FBBC 36 05                           .dw     0536h   ; M
0079++ FBBE 36 09                           .dw     0936h   ; N
0080++ FBC0 3F 00                           .dw     003fh   ; O
0081++ FBC2             
0082++ FBC2 F3 00                           .dw     00f3h   ; P
0083++ FBC4 3F 08                           .dw     083fh   ; Q
0084++ FBC6 F3 08                           .dw     08f3h   ; R
0085++ FBC8 ED 00                           .dw     00edh   ; S
0086++ FBCA 01 12                           .dw     1201h   ; T
0087++ FBCC 3E 00                           .dw     003eh   ; U
0088++ FBCE 30 24                           .dw     2430h   ; V
0089++ FBD0 36 28                           .dw     2836h   ; W
0090++ FBD2 00 2D                           .dw     2d00h   ; X
0091++ FBD4 EE 00                           .dw     00eeh   ; Y
0092++ FBD6 09 24                           .dw     2409h   ; Z
0093++ FBD8 39 00                           .dw     0039h   ; [
0094++ FBDA 00 09                           .dw     0900h   ; \
0095++ FBDC 0F 00                           .dw     000fh   ; ]
0096++ FBDE 00 28                           .dw     2800h   ; ^
0097++ FBE0 08 00                           .dw     0008h   ; _
0098++ FBE2             
0099++ FBE2 00 01                           .dw     0100h   ; `
0100++ FBE4 8C 20                           .dw     208ch   ; a
0101++ FBE6 78 08                           .dw     0878h   ; b
0102++ FBE8 D8 00                           .dw     00d8h   ; c
0103++ FBEA 8E 20                           .dw     208eh   ; d 
0104++ FBEC 58 20                           .dw     2058h   ; e 
0105++ FBEE C0 14                           .dw     14c0h   ; f
0106++ FBF0 8E 04                           .dw     048eh   ; g
0107++ FBF2 70 10                           .dw     1070h   ; h
0108++ FBF4 00 10                           .dw     1000h   ; i
0109++ FBF6 10 22                           .dw     2210h   ; j
0110++ FBF8 00 1E                           .dw     1e00h   ; k
0111++ FBFA 30 00                           .dw     0030h   ; l
0112++ FBFC D4 10                           .dw     10d4h   ; m
0113++ FBFE 50 10                           .dw     1050h   ; n
0114++ FC00 DC 00                           .dw     00dch   ; o
0115++ FC02             
0116++ FC02 70 01                           .dw     0170h   ; p
0117++ FC04 86 04                           .dw     0486h   ; q
0118++ FC06 50 00                           .dw     0050h   ; r
0119++ FC08 88 08                           .dw     0888h   ; s
0120++ FC0A 78 00                           .dw     0078h   ; t
0121++ FC0C 1C 00                           .dw     001ch   ; u
0122++ FC0E 10 20                           .dw     2010h   ; v
0123++ FC10 14 28                           .dw     2814h   ; w
0124++ FC12 00 2D                           .dw     2d00h   ; x
0125++ FC14 8E 02                           .dw     028eh   ; y
0126++ FC16 48 20                           .dw     2048h   ; z
0127++ FC18 49 21                           .dw     2149h   ; {
0128++ FC1A 00 12                           .dw     1200h   ; |
0129++ FC1C 89 0C                           .dw     0c89h   ; }
0130++ FC1E C0 24                           .dw     24c0h   ; ~
0131++ FC20 00 00                           .dw     0000h   ; 1346+  FC22                                 .INCLUDE "bios_rtc.asm"
0001++ FC22             ; RTC Routines
0002++ FC22             ;
0003++ FC22             ;
0004++ FC22             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0005++ FC22             ;
0006++ FC22             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0007++ FC22             ;
0008++ FC22             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0009++ FC22             ; of this software and associated documentation files (the "Software"), to deal
0010++ FC22             ; in the Software without restriction, including without limitation the rights
0011++ FC22             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0012++ FC22             ; copies of the Software, and to permit persons to whom the Software is
0013++ FC22             ; furnished to do so, subject to the following conditions:
0014++ FC22             ; 
0015++ FC22             ; The above copyright notice and this permission notice shall be included in all
0016++ FC22             ; copies or substantial portions of the Software.
0017++ FC22             ; 
0018++ FC22             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0019++ FC22             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0020++ FC22             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0021++ FC22             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0022++ FC22             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0023++ FC22             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0024++ FC22             ; SOFTWARE.
0025++ FC22             ;
0026++ FC22             ;
0027++ FC22                                     .MODULE rtc
0028++ FC22             
0029++ FC22             ; Set the initial time and start the clock
0030++ FC22             ;
0031++ FC22             ;
0032++ FC22 CD 9B F3    rtc_init                CALL    m_print_inline
0033++ FC25 0A 0D 43 68                         .DB     "\n\rCheck RTC",0
0033++ FC29 65 63 6B 20 
0033++ FC2D 52 54 43 00 
0034++ FC31             
0035++ FC31 CD A6 FC                            CALL    _read_seconds
0036++ FC34 CD A1 FC                            CALL    _pause
0037++ FC37 CB 7B                               BIT     7, E                ; Check to see if the clock is running
0038++ FC39 C0                                  RET     NZ                  ; Return if it is..
0039++ FC3A             
0040++ FC3A CD 9B F3    _do_reset               CALL    m_print_inline
0041++ FC3D 0A 0D 52 65                         .DB     "\n\rReset RTC",0
0041++ FC41 73 65 74 20 
0041++ FC45 52 54 43 00 
0042++ FC49             
0043++ FC49 26 6F                               LD      H, RTC_ADDRESS      ; Clock isn't running, reset to default time
0044++ FC4B 2E 00                               LD      L, RTC_REG_SEC
0045++ FC4D CD FE F8                            CALL    i2c_write_to
0046++ FC50 D2 B4 FC                            JP      NC, rtc_ack_error
0047++ FC53             
0048++ FC53 21 C7 FC                            LD      HL, time_scratch
0049++ FC56 7E          _reset_loop             LD      A, (HL)
0050++ FC57 23                                  INC     HL
0051++ FC58 FE FF                               CP      0ffh
0052++ FC5A CA 65 FC                            JP      Z, _start_clock
0053++ FC5D CD 12 F9                            CALL    i2c_write
0054++ FC60 D2 B4 FC                            JP      NC, rtc_ack_error
0055++ FC63 18 F1                               JR      _reset_loop
0056++ FC65             
0057++ FC65 CD D4 F8    _start_clock            CALL    i2c_stop            ; Enable VBAT and start the clock
0058++ FC68             
0059++ FC68 26 6F                               LD      H, RTC_ADDRESS      ; Enable VBAT
0060++ FC6A 2E 03                               LD      L, RTC_REG_WKDAY
0061++ FC6C CD DD F8                            CALL    i2c_read_from
0062++ FC6F D2 B4 FC                            JP      NC, rtc_ack_error
0063++ FC72 5F                                  LD      E, A
0064++ FC73 CD D4 F8                            CALL    i2c_stop
0065++ FC76 CB DB                               SET     3, E
0066++ FC78 CD A1 FC                            CALL    _pause
0067++ FC7B             
0068++ FC7B CD FE F8                            CALL    i2c_write_to
0069++ FC7E D2 B4 FC                            JP      NC, rtc_ack_error
0070++ FC81 7B                                  LD      A, E
0071++ FC82 CD 12 F9                            CALL    i2c_write
0072++ FC85 D2 B4 FC                            JP      NC, rtc_ack_error
0073++ FC88 CD D4 F8                            CALL    i2c_stop
0074++ FC8B             
0075++ FC8B CD A6 FC                            CALL    _read_seconds
0076++ FC8E CB FB                               SET     7, E                ; Set bit 7 to enable clock
0077++ FC90                                     
0078++ FC90 CD FE F8                            CALL    i2c_write_to
0079++ FC93 D2 B4 FC                            JP      NC, rtc_ack_error
0080++ FC96 7B                                  LD      A, E
0081++ FC97 CD 12 F9                            CALL    i2c_write
0082++ FC9A D2 B4 FC                            JP      NC, rtc_ack_error
0083++ FC9D CD D4 F8                            CALL    i2c_stop
0084++ FCA0 C9                                  RET
0085++ FCA1             
0086++ FCA1 06 00       _pause                  LD      B, 0
0087++ FCA3 10 FE                               DJNZ    $
0088++ FCA5 C9                                  RET
0089++ FCA6             
0090++ FCA6             ;
0091++ FCA6             ; Read seconds register in E
0092++ FCA6             ;
0093++ FCA6 26 6F       _read_seconds           LD      H, RTC_ADDRESS      
0094++ FCA8 2E 00                               LD      L, RTC_REG_SEC      
0095++ FCAA CD DD F8                            CALL    i2c_read_from
0096++ FCAD D2 B4 FC                            JP      NC, rtc_ack_error
0097++ FCB0 5F                                  LD      E, A
0098++ FCB1 C3 D4 F8                            JP     i2c_stop
0099++ FCB4             
0100++ FCB4 CD D4 F8    rtc_ack_error           CALL    i2c_stop
0101++ FCB7                                     
0102++ FCB7 CD 9B F3                            CALL    m_print_inline
0103++ FCBA 0A 0D 52 54                         .DB     "\n\rRTC Panic",0
0103++ FCBE 43 20 50 61 
0103++ FCC2 6E 69 63 00 
0104++ FCC6 C9                                  RET
0105++ FCC7             
0106++ FCC7                                     ;  Initial time on power up..
0107++ FCC7 23          time_scratch            .db  23h            ; Seconds
0108++ FCC8 59                                  .db  59h            ; Minutes
0109++ FCC9 08                                  .db  08h            ; Hours    (24 hr clock)
0110++ FCCA 06                                  .db  06h            ; Weekday  (1-7. Monday=1)
0111++ FCCB 05                                  .db  05h            ; Date
0112++ FCCC 11                                  .db  11h            ; Month
0113++ FCCD 22                                  .db  22h            ; Year 
0114++ FCCE FF                                  .db  0ffh           ; 0ffh end marker
0115++ FCCF             
0116++ FCCF                                     .MODULE main1347+  FCCF                                 .INCLUDE "../flash.asm"
0001++ FCCF             ;
0002++ FCCF             ; Flash update routines
0003++ FCCF             ;
0004++ FCCF             ; Note that any memory write operations *at all* during flash updates will cancel the current operation.
0005++ FCCF             ; That means no data can be stored to memory, no stack operations (call, push), no interrupts.
0006++ FCCF             ; 
0007++ FCCF             ;
0008++ FCCF             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0009++ FCCF             ;
0010++ FCCF             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0011++ FCCF             ;
0012++ FCCF             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0013++ FCCF             ; of this software and associated documentation files (the "Software"), to deal
0014++ FCCF             ; in the Software without restriction, including without limitation the rights
0015++ FCCF             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0016++ FCCF             ; copies of the Software, and to permit persons to whom the Software is
0017++ FCCF             ; furnished to do so, subject to the following conditions:
0018++ FCCF             ; 
0019++ FCCF             ; The above copyright notice and this permission notice shall be included in all
0020++ FCCF             ; copies or substantial portions of the Software.
0021++ FCCF             ; 
0022++ FCCF             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0023++ FCCF             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0024++ FCCF             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0025++ FCCF             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0026++ FCCF             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0027++ FCCF             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0028++ FCCF             ; SOFTWARE.
0029++ FCCF             ;
0030++ FCCF                                 .MODULE     flash
0031++ FCCF             
0032++ FCCF             _cmd_1_addr         .EQU  05555h
0033++ FCCF             _cmd_2_addr         .EQU  02AAAh
0034++ FCCF             
0035++ FCCF             _bank_mask          .EQU  03FFFh                ; One memory bank is 14 bits -> 16Kb
0036++ FCCF             _sector_mask        .EQU  00FFFh                ; A sector is 12 bits -> 4Kb
0037++ FCCF             
0038++ FCCF             _cmd_1_addr_bank    .EQU  _cmd_1_addr >> 14
0039++ FCCF             _cmd_2_addr_bank    .EQU  _cmd_2_addr >> 14
0040++ FCCF             _cmd_3_addr_bank    .EQU  _cmd_1_addr_bank
0041++ FCCF             _cmd_4_addr_bank    .EQU  _cmd_1_addr_bank
0042++ FCCF             _cmd_5_addr_bank    .EQU  _cmd_2_addr_bank
0043++ FCCF             
0044++ FCCF             _cmd_1_logical_addr .EQU  _cmd_1_addr & _bank_mask
0045++ FCCF             _cmd_2_logical_addr .EQU  _cmd_2_addr & _bank_mask
0046++ FCCF             _cmd_3_logical_addr .EQU  _cmd_1_logical_addr
0047++ FCCF             _cmd_4_logical_addr .EQU  _cmd_1_logical_addr
0048++ FCCF             _cmd_5_logical_addr .EQU  _cmd_2_logical_addr
0049++ FCCF             
0050++ FCCF             _cmd_1_data         .EQU  0AAh
0051++ FCCF             _cmd_2_data         .EQU  055h
0052++ FCCF             _cmd_3_data_write   .EQU  0A0h
0053++ FCCF             _cmd_3_data_erase   .EQU  080h
0054++ FCCF             _cmd_4_data         .EQU  0AAh
0055++ FCCF             _cmd_5_data         .EQU  055h
0056++ FCCF             
0057++ FCCF             _cmd_6_data_erase   .EQU  030h
0058++ FCCF             
0059++ FCCF             ;
0060++ FCCF             ; Enter with A -> 7 bit index of 4K sector to be erased.
0061++ FCCF             ;
0062++ FCCF             ; Preserves BC, DE, HL
0063++ FCCF             ;
0064++ FCCF             ; Note this uses bank 0, and leaves it configured for the page containing the erased sector
0065++ FCCF             ;
0066++ FCCF             ; Typical time to erase sector ~18ms
0067++ FCCF             ;
0068++ FCCF F3          flash_sector_erase  DI                          ; Disable interrupts
0069++ FCD0 E5                              PUSH    HL
0070++ FCD1 C5                              PUSH    BC
0071++ FCD2 D5                              PUSH    DE
0072++ FCD3             
0073++ FCD3 E6 7F                           AND     07fh
0074++ FCD5 57                              LD      D, A
0075++ FCD6 CB 3A                           SRL     D
0076++ FCD8 CB 3A                           SRL     D                   ; D is now the bank number
0077++ FCDA             
0078++ FCDA CB 27                           SLA     A
0079++ FCDC CB 27                           SLA     A
0080++ FCDE CB 27                           SLA     A
0081++ FCE0 CB 27                           SLA     A
0082++ FCE2 E6 30                           AND     030h
0083++ FCE4 5F                              LD      E, A                ; E is the sector within the bank shifted into bits 13 & 12
0084++ FCE5             
0085++ FCE5 0E 70                           LD      C, IO_MEM_0         ; Use bank 0 to write to
0086++ FCE7 3E 01                           LD      A, _cmd_1_addr_bank
0087++ FCE9 ED 79                           OUT     (C), A
0088++ FCEB 21 55 15                        LD      HL, _cmd_1_logical_addr
0089++ FCEE 36 AA                           LD      (HL), _cmd_1_data
0090++ FCF0             
0091++ FCF0 3E 00                           LD      A, _cmd_2_addr_bank
0092++ FCF2 ED 79                           OUT     (C), A
0093++ FCF4 21 AA 2A                        LD      HL, _cmd_2_logical_addr
0094++ FCF7 36 55                           LD      (HL), _cmd_2_data
0095++ FCF9             
0096++ FCF9 3E 01                           LD      A, _cmd_3_addr_bank
0097++ FCFB ED 79                           OUT     (C), A
0098++ FCFD 21 55 15                        LD      HL, _cmd_3_logical_addr
0099++ FD00 36 80                           LD      (HL), _cmd_3_data_erase
0100++ FD02             
0101++ FD02 3E 01                           LD      A, _cmd_4_addr_bank
0102++ FD04 ED 79                           OUT     (C), A
0103++ FD06 21 55 15                        LD      HL, _cmd_4_logical_addr
0104++ FD09 36 AA                           LD      (HL), _cmd_4_data
0105++ FD0B             
0106++ FD0B 3E 00                           LD      A, _cmd_5_addr_bank
0107++ FD0D ED 79                           OUT     (C), A
0108++ FD0F 21 AA 2A                        LD      HL, _cmd_5_logical_addr
0109++ FD12 36 55                           LD      (HL), _cmd_5_data
0110++ FD14             
0111++ FD14 ED 51                           OUT     (C), D                  ; Switch to the bank containing our sector
0112++ FD16 63                              LD      H, E                    ; And write the sector bits as an address (bits 0-11 are ignored)
0113++ FD17 36 30                           LD      (HL), _cmd_6_data_erase
0114++ FD19             
0115++ FD19 7E          _wait_erase         LD      A,(HL)
0116++ FD1A CB 07                           RLC     A
0117++ FD1C 30 FB                           JR      NC, _wait_erase
0118++ FD1E             
0119++ FD1E D1                              POP     DE
0120++ FD1F C1                              POP     BC
0121++ FD20 E1                              POP     HL
0122++ FD21 FB                              EI
0123++ FD22 C9                              RET
0124++ FD23             
0125++ FD23             ;
0126++ FD23             ; Enter with A -> Byte to write
0127++ FD23             ;            D -> 7 bit index of 4K sector being written
0128++ FD23             ;            HL -> 12 bit address of byte within sector
0129++ FD23             ;
0130++ FD23             ; Preserves D, HL
0131++ FD23             ; Uses A, BC, E
0132++ FD23             ;
0133++ FD23             ; Typical time to erase byte ~14us
0134++ FD23             ;
0135++ FD23 F3          flash_write_byte    DI
0136++ FD24 5F                              LD      E, A                ; Preserve our byte
0137++ FD25                                 
0138++ FD25 7C                              LD      A, H                ; Make sure HL is within our sector
0139++ FD26 E6 0F                           AND     _sector_mask >> 8
0140++ FD28 67                              LD      H, A
0141++ FD29             
0142++ FD29 7A                              LD      A, D                ; Make sure D is a valid sector index
0143++ FD2A E6 7F                           AND     07fh
0144++ FD2C 57                              LD      D, A
0145++ FD2D 47                              LD      B, A
0146++ FD2E             
0147++ FD2E 7A                              LD      A, D                ; Get the bottom 2 bits of our sector index..
0148++ FD2F E6 03                           AND     03h
0149++ FD31 CB 27                           SLA     A
0150++ FD33 CB 27                           SLA     A
0151++ FD35 CB 27                           SLA     A
0152++ FD37 CB 27                           SLA     A
0153++ FD39 B4                              OR      H
0154++ FD3A 67                              LD      H, A                ; ..and OR them into H to get a 14 bit address within our bank
0155++ FD3B             
0156++ FD3B CB 3A                           SRL     D
0157++ FD3D CB 3A                           SRL     D                   ; D is now our bank number
0158++ FD3F             
0159++ FD3F E5                              PUSH    HL
0160++ FD40             
0161++ FD40 0E 70                           LD      C, IO_MEM_0         ; Use bank 0 to write to
0162++ FD42 3E 01                           LD      A, _cmd_1_addr_bank
0163++ FD44 ED 79                           OUT     (C), A
0164++ FD46 21 55 15                        LD      HL, _cmd_1_logical_addr
0165++ FD49 36 AA                           LD      (HL), _cmd_1_data
0166++ FD4B             
0167++ FD4B 3E 00                           LD      A, _cmd_2_addr_bank
0168++ FD4D ED 79                           OUT     (C), A
0169++ FD4F 21 AA 2A                        LD      HL, _cmd_2_logical_addr
0170++ FD52 36 55                           LD      (HL), _cmd_2_data
0171++ FD54             
0172++ FD54 3E 01                           LD      A, _cmd_3_addr_bank
0173++ FD56 ED 79                           OUT     (C), A
0174++ FD58 21 55 15                        LD      HL, _cmd_3_logical_addr
0175++ FD5B 36 A0                           LD      (HL), _cmd_3_data_write
0176++ FD5D             
0177++ FD5D ED 51                           OUT     (C), D
0178++ FD5F E1                              POP     HL
0179++ FD60 73                              LD      (HL), E
0180++ FD61             
0181++ FD61 7E          _wait_byte          LD      A, (HL)
0182++ FD62 AB                              XOR     E
0183++ FD63 CB 07                           RLC     A
0184++ FD65 30 FA                           JR      NC, _wait_byte
0185++ FD67             
0186++ FD67 7C                              LD      A, H                ; Clear bits 13 & 12 to restore HL to sector address..
0187++ FD68 E6 0F                           AND     _sector_mask >> 8
0188++ FD6A 67                              LD      H, A
0189++ FD6B                            
0190++ FD6B 50                              LD      D, B                ; And restore D
0191++ FD6C FB                              EI
0192++ FD6D C9                              RET
0193++ FD6E             
0194++ FD6E             ;
0195++ FD6E             ; Write a flash data block. This uses Page 0 to write the data, so the source must be above 4000h
0196++ FD6E             ;
0197++ FD6E             ;       D -> 7 bit index of 4K sector being written
0198++ FD6E             ;       HL -> Address of source data
0199++ FD6E             ;       BC -> bytes to write
0200++ FD6E             ;
0201++ FD6E             ; Returns D pointing to last sector written
0202++ FD6E             ; Note: This means if BC is an exact multiple of sector size, D is returned as the previous sector
0203++ FD6E             
0204++ FD6E DD E5       flash_write         PUSH    IX
0205++ FD70 E5                              PUSH    HL
0206++ FD71 DD E1                           POP     IX
0207++ FD73 21 00 00                        LD      HL, 0           ; Address in sector..
0208++ FD76             
0209++ FD76             _erase_sector       ; Lower 12 bits of HL are zero, erase sector before writing bytes
0210++ FD76 7A                              LD      A, D
0211++ FD77 CD CF FC                        CALL    flash_sector_erase
0212++ FD7A DD 7E 00    _write_loop         LD      A, (IX+0)
0213++ FD7D C5                              PUSH    BC
0214++ FD7E CD 23 FD                        CALL    flash_write_byte
0215++ FD81 C1                              POP     BC
0216++ FD82             
0217++ FD82 DD 23                           INC     IX
0218++ FD84 0B                              DEC     BC
0219++ FD85 78                              LD      A, B
0220++ FD86 B1                              OR      C
0221++ FD87 28 0E                           JR      Z, _success
0222++ FD89             
0223++ FD89 23                              INC     HL
0224++ FD8A 7D                              LD      A, L
0225++ FD8B A7                              AND     A
0226++ FD8C 20 EC                           JR      NZ, _write_loop
0227++ FD8E 7C                              LD      A, H
0228++ FD8F E6 0F                           AND     _sector_mask >> 8
0229++ FD91 67                              LD      H, A
0230++ FD92 20 E6                           JR      NZ, _write_loop
0231++ FD94             
0232++ FD94 14                              INC     D
0233++ FD95 18 DF                           JR      _erase_sector
0234++ FD97             
0235++ FD97 DD E1       _success            POP     IX
0236++ FD99 C9                              RET
0237++ FD9A             
0238++ FD9A                                 .MODULE main1348+  FD9A             
1349+  FD9A             JUMP_TABLE_SIZE     .EQU    2
1350+  FD9A             
1351+  FD9A             BIOS_SPARE          .EQU    BIOS_TOP - $ - (3*JUMP_TABLE_SIZE)
1352+  FD9A 00 00 00 00                     .FILL   BIOS_SPARE, 0
1352+  FD9E 00 00 00 00 
1352+  FDA2 00 00 00 00 
1352+  FDA6 00 00 00 00 
1352+  FDAA 00 00 00 00 
1352+  FDAE 00 00 00 00 
1352+  FDB2 00 00 00 00 
1352+  FDB6 00 00 00 00 
1352+  FDBA 00 00 00 00 
1352+  FDBE 00 00 00 00 
1352+  FDC2 00 00 00 00 
1352+  FDC6 00 00 00 00 
1352+  FDCA 00 00 00 00 
1352+  FDCE 00 00 00 00 
1352+  FDD2 00 00 00 00 
1352+  FDD6 00 00 00 00 
1352+  FDDA 00 00 00 00 
1352+  FDDE 00 00 00 00 
1352+  FDE2 00 00 00 00 
1352+  FDE6 00 00 00 00 
1352+  FDEA 00 00 00 00 
1352+  FDEE 00 00 00 00 
1352+  FDF2 00 00 00 00 
1352+  FDF6 00 
1353+  FDF7             
1354+  FDF7 C3 26 F7                        JP          wait_for_key        ; Waits for until a key is pressed and released
1355+  FDFA C3 BB F6                        JP          play_note           ; Plays the note defined by DE (octave, note) and C (duration, tenths)
1356+  FDFD             
1357+  FDFD             
1358+  FDFD~            .IF $ > BIOS_TOP
1359+  FDFD~                .ECHO "End of BIOS is too high ("
1360+  FDFD~                .ECHO $
1361+  FDFD~                .ECHO " > "
1362+  FDFD~                .ECHO BIOS_TOP
1363+  FDFD~                .ECHO ") \n\n"
1364+  FDFD~                .STOP
1365+  FDFD             .ENDIF
1366+  FDFD             
1367+  FDFD             .ECHO "Bios Size is "
1368+  FDFD             .ECHO BIOS_TOP-BIOS_START-BIOS_SPARE
1369+  FDFD             .ECHO ". Limit is "
1370+  FDFD             .ECHO BIOS_TOP-BIOS_START
1371+  FDFD             .ECHO ". Spare "
1372+  FDFD             .ECHO BIOS_SPARE
1373+  FDFD             .ECHO "\n\n"
1374+  FDFD             
1375+  FDFD                                 .INCLUDE shared_data.asm
0001++ FDFD             ;
0002++ FDFD             ; Shared data - common state data for routines
0003++ FDFD             ;
0004++ FDFD             ; [] show default/initial values stored at the location
0005++ FDFD             ;
0006++ FDFD             ; Copyright (c) 2023 Andy Toone for Feersum Technology Ltd.
0007++ FDFD             ;
0008++ FDFD             ; Part of the MicroBeast Z80 kit computer project. Support hobby electronics.
0009++ FDFD             ;
0010++ FDFD             ; Permission is hereby granted, free of charge, to any person obtaining a copy
0011++ FDFD             ; of this software and associated documentation files (the "Software"), to deal
0012++ FDFD             ; in the Software without restriction, including without limitation the rights
0013++ FDFD             ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
0014++ FDFD             ; copies of the Software, and to permit persons to whom the Software is
0015++ FDFD             ; furnished to do so, subject to the following conditions:
0016++ FDFD             ; 
0017++ FDFD             ; The above copyright notice and this permission notice shall be included in all
0018++ FDFD             ; copies or substantial portions of the Software.
0019++ FDFD             ; 
0020++ FDFD             ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
0021++ FDFD             ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
0022++ FDFD             ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
0023++ FDFD             ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
0024++ FDFD             ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
0025++ FDFD             ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
0026++ FDFD             ; SOFTWARE.
0027++ FDFD             ;
0028++ FDFD             
0029++ FF00                                 .ORG    0FF00h
0030++ FF00             
0031++ FF00             ; I2C/Port B routines
0032++ FF00             port_b_mode         .BLOCK  1
0033++ FF01             port_b_dir          .BLOCK  1
0034++ FF02             port_b_data         .BLOCK  1
0035++ FF03             
0036++ FF03             ; Display functions
0037++ FF03             display_address     .BLOCK  1              ; byte - I/O address of the display driver (right or left) being written to
0038++ FF04             
0039++ FF04             ;
0040++ FF04             ; Stuff
0041++ FF04             timer               .BLOCK  4              ; 2 Words - counts up by 1 every 64th of a second. Rollover ~2 years.
0042++ FF08                                     
0043++ FF08             ; General I/O
0044++ FF08             ;
0045++ FF08             ; This MUST start with keyboard_state, and will all be reset to zero when io_init is called
0046++ FF08             ;
0047++ FF08             _key_state_size     .EQU    8               ; 8 key rollover
0048++ FF08             
0049++ FF08             keyboard_state      .BLOCK  _key_state_size ; state buffer - 8 bytes containing raw key codes for keys currently pressed
0050++ FF10             keyboard_pos        .BLOCK  2               ; Internal state
0051++ FF12             key_shift_state     .BLOCK  1               ; Holds state of shift and control keys in bits 0 and 1 respectively
0052++ FF13             control_key_pressed .BLOCK  1               ; If special control keys are pressed, they are stored here..
0053++ FF14             last_keycode        .BLOCK  1               ; The last keycode that was pressed, for repeats..
0054++ FF15             key_repeat_time     .BLOCK  1               ; How many poll events since the key state last changed
0055++ FF16             
0056++ FF16             _input_buffer_size  .EQU    16
0057++ FF16             input_buffer        .BLOCK _input_buffer_size          ; 16 byte input buffer. Note wraparound is handled by bitmasks, so don't change this length
0058++ FF26             input_pos           .BLOCK  1               ; Next read position in input buffer
0059++ FF27             input_free          .BLOCK  1               ; Next write position in input buffer
0060++ FF28             input_size          .BLOCK  1               ; Bytes occupied in the input buffer
0061++ FF29             
0062++ FF29             io_data_end         .EQU  input_size        ; Byte after IO data block, used to reset values to zero
0063++ FF29             
0064++ FF29             ;------------------------------- Console output and screen data ------------------------------------------------
0065++ FF29             screen_page         .BLOCK  1               ; [30?]  1 Byte, screen buffer page address
0066++ FF2A             screen_offset       .BLOCK  1               ; [0]    1 Byte, row offset (0-63) of virtual screen in screen buffer (high byte of screen address).
0067++ FF2B             
0068++ FF2B             ; *** ROW AND COL MUST BE IN THIS ORDER - READ BY bios_conout ***
0069++ FF2B             display_row         .BLOCK  1               ; [0]    1 Byte, current row being shown by the LED display
0070++ FF2C             display_col         .BLOCK  1               ; [0]    1 Byte, current column being shown by the LED display - Note, 0 based
0071++ FF2D             
0072++ FF2D             ; *** ROW AND COL MUST BE IN THIS ORDER - READ BY bios_conout ***
0073++ FF2D             cursor_row          .BLOCK  1               ; [1]    1 Byte, cursor row on virtual console. Top of page is row 1.   
0074++ FF2E             cursor_col          .BLOCK  1               ; [1]    1 Byte, cursor column on virtual console. Left of page is column 1.
0075++ FF2F             
0076++ FF2F             console_height      .BLOCK  1               ; [24]   1 Byte, virtual console height (rows)
0077++ FF30             console_width       .BLOCK  1               ; [40]   1 byte, virtual console width (columns)
0078++ FF31             
0079++ FF31             console_colour      .BLOCK  1               ; [0x0F] 1 Byte, current colour. Top 4 bits [7:4] are background, bottom 4 [3:0] are foreground
0080++ FF32             console_flags       .BLOCK  1               ;        1 Byte, bit flags for console
0081++ FF33             
0082++ FF33             console_timer       .BLOCK  1               ;        1 Byte, used to blink cursor, clear movement indicator etc.
0083++ FF34             console_escape      .BLOCK  1               ;        1 Byte, escape value (0 if not received yet)
0084++ FF35             console_param1      .BLOCK  1               ;        1 Byte, first character after escape (0 if not recieved yet)
0085++ FF36             
0086++ FF36             console_identify    .BLOCK  1               ; [0]    1 Byte, indicates console identifier sequence to be returned..
0087++ FF37             
0088++ FF37             CFLAGS_SHOW_CURSOR  .EQU    1               ; Awaiting input - show (blink) the cursor
0089++ FF37             CFLAGS_TRACK_CURSOR .EQU    2               ; LED display is tracking cursor position
0090++ FF37             CFLAGS_SHOW_MOVED   .EQU    4               ; Show display as being moved by user
0091++ FF37             CFLAGS_ESCAPE       .EQU    8               ; Escape sequence started
0092++ FF37             CFLAGS_CURSOR_ON    .EQU    16              ; Cursor is currently displayed
0093++ FF37             
0094++ FF37             SHOW_MOVE_DELAY     .EQU    60              ; How long to show the display has been moved
0095++ FF37             
0096++ FF37             ;------------------------------- BIOS customisation  ------------------------------------------------
0097++ FF37             
0098++ FF37             drive_a_mem_page    .BLOCK  1
0099++ FF38             drive_b_mem_page    .BLOCK  1
0100++ FF39             
0101++ FF39             ;------------------------------- BDOS variables ------------------------------------------------
0102++ FF39             ; *** TRACK AND SECTOR MUST BE IN THIS ORDER - READ BY _get_memdisc_addr ***
0103++ FF39             sys_track           .BLOCK  1               ; 1 Byte, Current disk track 
0104++ FF3A             sys_sector          .BLOCK  2               ; Word, current disk sector
0105++ FF3C             sys_dmaaddr         .BLOCK  2               ; Word, DMA address - Disc will read data to this address, or write from this address
0106++ FF3E             sys_disk_dph        .BLOCK  2               ; Word, points to current disk parameter header (DPH) 
0107++ FF40             sys_seldsk          .BLOCK  1               ; Byte, current selected disk drive (A=0, B=1..)
0108++ FF41             
0109++ FF41             sys_alv0            .BLOCK  32              ; 32 bytes, allocation vector 0 (max 255 blocks)
0110++ FF61             sys_alv1            .BLOCK  32              ; 32 bytes, allocation vector 1 (max 255 blocks)
0111++ FF81             
0112++ FF81             display_buffer      .BLOCK  24*2            ; 26 byte scratch area used for composing display output (eg. rtc time display etc.)
0113++ FFB1             
0114++ FFB1             intr_stackarea      .BLOCK  32              ; Interrupt handler stack
0115++ FFD1             intr_stack          .BLOCK  2
0116++ FFD3             
0117++ FFD3             ; Panic codes
0118++ FFD3             ;
0119++ FFD3             PANIC_0001          .EQU    0F001h
0120++ FFD3             PANIC_0002          .EQU    0F002h
0121++ FFD3             PANIC_0003          .EQU    0F003h
0122++ FFD3             PANIC_0004          .EQU    0F004h
0123++ FFD3             
1376+  FFD3                                 .END1134   FFD3                                 .END
tasm: Number of errors = 0
