0001   0000             ;
0002   0000             ; BIOS
0003   0000             ;
0004   0000             
0005   0000                                 .MODULE  main
0006   0000             
0007   0000             BIOS_START          .EQU   0E600h
0008   0000             BIOS_TOP            .EQU   0FDFDh
0009   0000             
0010   E600                                 .ORG   BIOS_START 
0011   E600 31 00 00    reset               LD     SP, 0
0012   E603             
0013   E603 3E 20                           LD      A, 020h
0014   E605 D3 70                           OUT     (IO_MEM_0), A       ; Page 0 is RAM 0 
0015   E607 3C                              INC     A
0016   E608 D3 71                           OUT     (IO_MEM_1), A       ; Page 1 is RAM 1
0017   E60A 3C                              INC      A
0018   E60B D3 72                           OUT     (IO_MEM_2), A       ; Page 2 is RAM 2 
0019   E60D             
0020   E60D 21 00 FE                        LD     HL, 0FE00h           ; Set up the IM 2 table
0021   E610 06 00                           LD     B, 0
0022   E612 36 FD       _fill_vector        LD     (HL), 0FDh
0023   E614 23                              INC    HL
0024   E615 10 FB                           DJNZ   _fill_vector
0025   E617             
0026   E617 3E C3                           LD     A, 0C3h              ; JP reset   instruction
0027   E619 32 FD FD                        LD     (0FDFDh), A
0028   E61C 21 D2 E8                        LD     HL, timer_int
0029   E61F 22 FE FD                        LD     (0FDFEh), HL
0030   E622             
0031   E622 3E 02                           LD      A, 2
0032   E624 D3 13                           OUT     (PIO_B_CTRL),A      ; Zero interrupt vector
0033   E626             
0034   E626 3E B7                           LD      A, 0B7h             ; Enable interrupts on any of the following bits
0035   E628 D3 13                           OUT     (PIO_B_CTRL),A
0036   E62A 00                              NOP
0037   E62B 3E CF                           LD      A, 0CFh             ; Just B5 (RTC interrupt) 
0038   E62D D3 13                           OUT     (PIO_B_CTRL),A
0039   E62F             
0040   E62F 3E FE                           LD      A, 0FEh
0041   E631 ED 47                           LD      I, A
0042   E633 ED 5E                           IM      2
0043   E635 FB                              EI
0044   E636             
0045   E636 3E 00                           LD      A, 
0046   E638 CD CE ED                        CALL    uart_init           ; Reinitialise the UART to make sure we've not missed anything
0047   E63B CD 53 EE                        CALL    uart_inline
0048   E63E 50 68 61 73                     .DB     "Phase 2:\n\r",0
0048   E642 65 20 32 3A 
0048   E646 0A 0D 00 
0049   E649             
0050   E649 CD FB F1                        CALL    rtc_reset
0051   E64C             
0052   E64C 3E 01                           LD      A, 1
0053   E64E 32 06 FF                        LD      (timer), A
0054   E651 3E 03                           LD      A, 3
0055   E653 CD C3 E8                        CALL    detect_int
0056   E656             
0057   E656 79                              LD      A, C
0058   E657 B0                              OR      B
0059   E658 20 1E                           JR      NZ, _clock_detected
0060   E65A             
0061   E65A CD 53 EE    _no_clock           CALL    uart_inline
0062   E65D 4E 6F 20 69                     .DB     "No interrupt recieved\n\r",0
0062   E661 6E 74 65 72 
0062   E665 72 75 70 74 
0062   E669 20 72 65 63 
0062   E66D 69 65 76 65 
0062   E671 64 0A 0D 00 
0063   E675 C3 3F E7                        JP      _continue
0064   E678             
0065   E678 3E 07       _clock_detected     LD      A, 7
0066   E67A CD C3 E8                        CALL    detect_int
0067   E67D 79                              LD      A, C
0068   E67E B0                              OR      B 
0069   E67F 28 D9                           JR      Z, _no_clock
0070   E681             
0071   E681                                 ; At this point BC ~= 13 * (clock * 100)
0072   E681                                 ; Divide by 13, round lowest digit up/down
0073   E681             
0074   E681 C5                              PUSH    BC
0075   E682 E1                              POP     HL
0076   E683 0E 0D                           LD      C, 13
0077   E685 CD 21 EB                        CALL    divide_hl_c
0078   E688             
0079   E688 E5                              PUSH    HL
0080   E689 D1                              POP     DE
0081   E68A CD 2E EB                        CALL    de_to_bcd
0082   E68D             
0083   E68D 3A 66 EB                        LD      A, (bcd_scratch)         ; Units
0084   E690 FE 06                           CP      6
0085   E692 38 11                           JR      C, _display_speed
0086   E694             
0087   E694 2A 67 EB                        LD      HL, (bcd_scratch+1)
0088   E697 06 04                           LD      B,  4
0089   E699             
0090   E699 7E          _increment_bcd      LD      A, (HL)
0091   E69A 3C                              INC     A
0092   E69B 77                              LD      (HL), A
0093   E69C FE 0A                           CP      10
0094   E69E 38 05                           JR      C, _display_speed        ; No carry here
0095   E6A0 AF                              XOR     A
0096   E6A1 77                              LD      (HL), A
0097   E6A2 23                              INC     HL
0098   E6A3 10 F4                           DJNZ    _increment_bcd
0099   E6A5             
0100   E6A5 3A 69 EB    _display_speed      LD      A, (bcd_scratch+3)
0101   E6A8 A7                              AND     A
0102   E6A9 28 05                           JR      Z, _skip_leading
0103   E6AB C6 30                           ADD     A, '0'
0104   E6AD 32 CF E6                        LD      (_speed_value),A
0105   E6B0 3A 68 EB    _skip_leading       LD       A, (bcd_scratch+2)
0106   E6B3 C6 30                           ADD     A, '0'
0107   E6B5 32 D0 E6                        LD      (_speed_value+1), A
0108   E6B8 3A 67 EB                        LD      A, (bcd_scratch+1)
0109   E6BB C6 30                           ADD     A, '0'
0110   E6BD 32 D2 E6                        LD      (_speed_value+3), A
0111   E6C0             
0112   E6C0 CD 53 EE                        CALL    uart_inline
0113   E6C3             
0114   E6C3 43 6C 6F 63 _speed_message      .DB     "Clock speed "
0114   E6C7 6B 20 73 70 
0114   E6CB 65 65 64 20 
0115   E6CF 20 30 2C 30 _speed_value        .DB     " 0,0Mhz", 0
0115   E6D3 4D 68 7A 00 
0116   E6D7             
0117   E6D7 CD 53 EE                        CALL    uart_inline
0118   E6DA 0A 0D 00                        .DB     "\n\r",0
0119   E6DD             
0120   E6DD CD 25 F1                        CALL    disp_clear
0121   E6E0             
0122   E6E0 21 C3 E6                        LD      HL, _speed_message
0123   E6E3 AF                              XOR     A
0124   E6E4 CD FB F0                        CALL    disp_string
0125   E6E7                                                                 ; Switch interrupts to full service routine
0126   E6E7             
0127   E6E7 CD 53 EE                        CALL    uart_inline
0128   E6EA 52 65 64 69                     .DB     "Redirecting interrupts \n\r",0
0128   E6EE 72 65 63 74 
0128   E6F2 69 6E 67 20 
0128   E6F6 69 6E 74 65 
0128   E6FA 72 72 75 70 
0128   E6FE 74 73 20 0A 
0128   E702 0D 00 
0129   E704             
0130   E704 CD C0 EB                        CALL    io_init
0131   E707 F3                              DI
0132   E708 21 DF E8                        LD      HL, keyboard_int
0133   E70B 22 FE FD                        LD     (0FDFEh), HL
0134   E70E FB                              EI
0135   E70F             
0136   E70F CD 53 EE                        CALL    uart_inline
0137   E712 57 61 69 74                     .DB     "Waiting for a key\n\r",0
0137   E716 69 6E 67 20 
0137   E71A 66 6F 72 20 
0137   E71E 61 20 6B 65 
0137   E722 79 0A 0D 00 
0138   E726             
0139   E726 CD F4 EC                        CALL    wait_for_key
0140   E729             
0141   E729 CD 53 EE                        CALL    uart_inline
0142   E72C 53 74 61 72                     .DB     "Startup complete\n\r",0
0142   E730 74 75 70 20 
0142   E734 63 6F 6D 70 
0142   E738 6C 65 74 65 
0142   E73C 0A 0D 00 
0143   E73F             _continue           
0144   E73F             
0145   E73F CD 9D F3    _repeat             CALL    rtc_display_time
0146   E742             
0147   E742 06 00                           LD      B, 0
0148   E744 10 FE                           DJNZ    $
0149   E746             
0150   E746 CD AC EC                        CALL    read_character
0151   E749 C4 52 E7                        CALL    NZ, main_menu
0152   E74C 18 F1                           JR      _repeat
0153   E74E             
0154   E74E 76          _halt               HALT
0155   E74F C3 4E E7                        JP      _halt
0156   E752             
0157   E752             ;========================================================================================================================================
0158   E752             ;
0159   E752             ; Main menu
0160   E752             ;
0161   E752             
0162   E752 21 73 E7    main_menu           LD      HL, main_menu_data
0163   E755 3E FF                           LD      A, 0FFh
0164   E757 CD BC E7                        CALL    menu_setup
0165   E75A 3A 07 FF                        LD      A, (timer+1)
0166   E75D 32 50 FF                        LD      (menu_timer), A
0167   E760             
0168   E760 CD AC EC    _menu_loop          CALL    read_character
0169   E763 C4 25 E8                        CALL    NZ, menu_button
0170   E766             
0171   E766 3A 50 FF                        LD      A, (menu_timer)
0172   E769 4F                              LD      C, A
0173   E76A 3A 07 FF                        LD      A, (timer+1)
0174   E76D 91                              SUB     C
0175   E76E FE 04                           CP      4
0176   E770 38 EE                           JR      C, _menu_loop
0177   E772 C9                              RET
0178   E773             
0179   E773 53 65 6C 65 main_menu_data      .DB     "Select action",0
0179   E777 63 74 20 61 
0179   E77B 63 74 69 6F 
0179   E77F 6E 00 
0180   E781 6B EB                           .DW     prompt
0181   E783 31 29 20 53                     .DB     "1) Start CP/M", 0
0181   E787 74 61 72 74 
0181   E78B 20 43 50 2F 
0181   E78F 4D 00 
0182   E791             
0183   E791 27 EA                           .DW     default_memory_view
0184   E793 32 29 20 4D                     .DB     "2) Monitor", 0
0184   E797 6F 6E 69 74 
0184   E79B 6F 72 00 
0185   E79E             
0186   E79E F1 E8                           .DW     default_ymodem
0187   E7A0 33 29 20 59                     .DB     "3) YModem", 0
0187   E7A4 4D 6F 64 65 
0187   E7A8 6D 00 
0188   E7AA             
0189   E7AA 8C E8                           .DW     play_music
0190   E7AC 34 29 20 4D                     .DB     "4) Music demo", 0
0190   E7B0 75 73 69 63 
0190   E7B4 20 64 65 6D 
0190   E7B8 6F 00 
0191   E7BA             
0192   E7BA 00 00                           .DW     0
0193   E7BC             
0194   E7BC             ;
0195   E7BC             ; Set up a menu.
0196   E7BC             ; Enter with HL -> start of menu data
0197   E7BC             ;             A -> Bit mask for enabled or disabled menu items
0198   E7BC             ;
0199   E7BC 32 51 FF    menu_setup          LD      (menu_enabled), A
0200   E7BF 22 4A FF                        LD      (menu_start), HL
0201   E7C2 CD 25 F1                        CALL    disp_clear
0202   E7C5 2A 4A FF                        LD      HL, (menu_start)
0203   E7C8 AF                              XOR     A
0204   E7C9 CD FB F0                        CALL    disp_string
0205   E7CC 23                              INC     HL
0206   E7CD 22 4C FF                        LD      (menu_item_start), HL
0207   E7D0 AF                              XOR     A
0208   E7D1 32 4F FF                        LD      (menu_index), A
0209   E7D4 4F                              LD      C, A
0210   E7D5 7E          _check_item         LD      A, (HL)
0211   E7D6 23                              INC     HL
0212   E7D7 B6                              OR      (HL)
0213   E7D8 28 09                           JR      Z, _counted
0214   E7DA 23                              INC     HL
0215   E7DB 7E          _item_loop          LD      A, (HL)
0216   E7DC 23                              INC     HL
0217   E7DD A7                              AND     A
0218   E7DE 20 FB                           JR      NZ, _item_loop
0219   E7E0 0C                              INC     C
0220   E7E1 18 F2                           JR      _check_item
0221   E7E3 79          _counted            LD      A, C
0222   E7E4 32 4E FF                        LD      (menu_count), A                    
0223   E7E7 C9                              RET
0224   E7E8             
0225   E7E8 CD 25 F1    menu_show_current   CALL    disp_clear
0226   E7EB 3A 4F FF                        LD      A, (menu_index)
0227   E7EE A7                              AND     A
0228   E7EF 20 0C                           JR      NZ, _display_item
0229   E7F1             
0230   E7F1 1E 80                           LD      E, DISP_DEFAULT_BRIGHTNESS  ; Menu title - default brightness...
0231   E7F3 CD FD EF                        CALL    disp_brightness
0232   E7F6 2A 4A FF                        LD      HL, (menu_start)
0233   E7F9 AF                              XOR     A
0234   E7FA C3 FB F0                        JP      disp_string
0235   E7FD 4F          _display_item       LD      C, A                    ; C is menu index
0236   E7FE 16 01                           LD      D, 1                    ; D is the enable mask
0237   E800 2A 4C FF                        LD      HL, (menu_item_start)
0238   E803 23          _display_check      INC     HL
0239   E804 23                              INC     HL
0240   E805 0D                              DEC     C
0241   E806 79                              LD      A, C                    ; Zero A without affecting flags
0242   E807 28 09                           JR      Z, _display_found
0243   E809 CB 22                           SLA     D
0244   E80B 7E          _display_loop       LD      A, (HL)                 ; Iterate through the menu string to find the zero terminator
0245   E80C 23                              INC     HL
0246   E80D A7                              AND     A
0247   E80E 20 FB                           JR      NZ, _display_loop
0248   E810 18 F1                           JR      _display_check
0249   E812             
0250   E812 3A 51 FF    _display_found      LD      A, (menu_enabled)
0251   E815 A2                              AND     D
0252   E816 1E 18                           LD      E, DISP_DIMMED
0253   E818 28 02                           JR      Z, _menu_disabled
0254   E81A 1E 80                           LD      E, DISP_DEFAULT_BRIGHTNESS
0255   E81C E5          _menu_disabled      PUSH    HL
0256   E81D CD FD EF                        CALL    disp_brightness
0257   E820 E1                              POP     HL
0258   E821 AF                              XOR     A
0259   E822 C3 FB F0                        JP      disp_string
0260   E825             
0261   E825             ;
0262   E825             ; Respond to up/down and enter buttons, or key that matches first letter of menu item...
0263   E825             ;
0264   E825 4F          menu_button         LD      C, A                    ; Reset menu timer...
0265   E826 3A 07 FF                        LD      A, (timer+1)
0266   E829 32 50 FF                        LD      (menu_timer), A
0267   E82C 79                              LD      A, C
0268   E82D             
0269   E82D FE 80                           CP      KEY_UP
0270   E82F 20 0B                           JR      NZ, _menu_test_down
0271   E831 3A 4F FF                        LD      A, (menu_index)
0272   E834 A7                              AND     A
0273   E835 C8                              RET     Z
0274   E836 3D                              DEC     A
0275   E837 32 4F FF    _store_and_show     LD      (menu_index),A 
0276   E83A 18 AC                           JR      menu_show_current
0277   E83C FE 81       _menu_test_down     CP      KEY_DOWN
0278   E83E 20 0C                           JR      NZ, _menu_test_enter
0279   E840 3A 4E FF                        LD      A, (menu_count)
0280   E843 4F                              LD      C, A
0281   E844 3A 4F FF                        LD      A, (menu_index)
0282   E847 B9                              CP      C
0283   E848 D0                              RET     NC
0284   E849 3C                              INC     A
0285   E84A 18 EB                           JR      _store_and_show
0286   E84C FE 0D       _menu_test_enter    CP      KEY_ENTER
0287   E84E 20 24                           JR      NZ, _menu_test_shortcut
0288   E850 3A 4F FF                        LD      A, (menu_index)
0289   E853 A7                              AND     A
0290   E854 C8                              RET     Z
0291   E855                                 
0292   E855 2A 4C FF                        LD      HL, (menu_item_start)
0293   E858 4F                              LD      C, A
0294   E859 16 01                           LD      D, 1
0295   E85B 0D          _find_item          DEC     C
0296   E85C 20 0B                           JR      NZ, _find_next
0297   E85E 3A 51 FF                        LD      A, (menu_enabled)   ; Check this menu item is enabled
0298   E861 A2                              AND     D
0299   E862 C8                              RET     Z
0300   E863             
0301   E863 C1                              POP     BC                  ; Get rid of the return to menu loop on the stack
0302   E864 4E                              LD      C, (HL)
0303   E865 23                              INC     HL
0304   E866 46                              LD      B, (HL)
0305   E867 C5                              PUSH    BC
0306   E868 C9                              RET
0307   E869             
0308   E869 23          _find_next          INC     HL
0309   E86A 23                              INC     HL
0310   E86B CB 22                           SLA     D
0311   E86D 7E          _find_loop          LD      A, (HL)
0312   E86E 23                              INC     HL
0313   E86F A7                              AND     A
0314   E870 20 FB                           JR      NZ, _find_loop
0315   E872 18 E7                           JR      _find_item
0316   E874             
0317   E874 57          _menu_test_shortcut LD      D, A
0318   E875 2A 4C FF                        LD      HL, (menu_item_start)
0319   E878             
0320   E878 7E          _check_shortcut     LD      A, (HL)
0321   E879 4F                              LD      C, A
0322   E87A 23                              INC     HL
0323   E87B 46                              LD      B, (HL)
0324   E87C B6                              OR      (HL)
0325   E87D C8                              RET     Z
0326   E87E             
0327   E87E 23                              INC     HL
0328   E87F 7E                              LD      A, (HL)
0329   E880 BA                              CP      D
0330   E881 20 02                           JR      NZ, _next_one
0331   E883 C5                              PUSH    BC
0332   E884 C9                              RET
0333   E885             
0334   E885 7E          _next_one           LD      A, (HL)
0335   E886 23                              INC     HL
0336   E887 A7                              AND     A
0337   E888 20 FB                           JR      NZ, _next_one
0338   E88A 18 EC                           JR      _check_shortcut
0339   E88C             
0340   E88C             ;============================================================================================================
0341   E88C             
0342   E88C CD FD EC    play_music          CALL    wait_no_keys
0343   E88F             
0344   E88F 21 FD F9                        LD      HL, music_data
0345   E892 11 00 EB                        LD      DE, 0EB00h
0346   E895 CD C3 F7                        CALL    qchan_play
0347   E898             
0348   E898 E1                              POP     HL
0349   E899 E5                              PUSH    HL
0350   E89A 7C                              LD      A, H
0351   E89B CD 34 EE                        CALL    uart_hex
0352   E89E 7D                              LD      A, L
0353   E89F CD 34 EE                        CALL    uart_hex
0354   E8A2             
0355   E8A2 CD 53 EE                        CALL    uart_inline
0356   E8A5 20 47 6F 74                     .DB     " Got back from music\n\r",0
0356   E8A9 20 62 61 63 
0356   E8AD 6B 20 66 72 
0356   E8B1 6F 6D 20 6D 
0356   E8B5 75 73 69 63 
0356   E8B9 0A 0D 00 
0357   E8BC             
0358   E8BC CD 71 EE                        CALL    init_portb
0359   E8BF CD FD EC                        CALL    wait_no_keys
0360   E8C2 C9                              RET
0361   E8C3             
0362   E8C3 01 00 00    detect_int          LD      BC, 0
0363   E8C6 57                              LD      D, A
0364   E8C7 3A 06 FF    _wait_for_tick      LD      A, (timer)               ; 13            ; Loop = 13+4+5+6+4+4+12 (=48) * BC + (13 + 4 + 11 + 13 + 4 + 17 + 10 (CALL)) = 72
0365   E8CA A2                              AND     D                        ; 4
0366   E8CB C8                              RET     Z                        ; 5 / 11
0367   E8CC 03                              INC     BC                       ; 6
0368   E8CD 79                              LD      A, C                     ; 4
0369   E8CE B0                              OR      B                        ; 4
0370   E8CF 20 F6                           JR      NZ, _wait_for_tick       ; 7 / 12
0371   E8D1 C9                              RET
0372   E8D2             
0373   E8D2 F3          timer_int           DI
0374   E8D3 E5                              PUSH    HL
0375   E8D4 2A 06 FF                        LD      HL, (timer)
0376   E8D7 23                              INC     HL
0377   E8D8 22 06 FF                        LD      (timer), HL
0378   E8DB E1                              POP     HL
0379   E8DC FB                              EI
0380   E8DD ED 4D                           RETI
0381   E8DF             
0382   E8DF F3          keyboard_int        DI
0383   E8E0 F5                              PUSH    AF
0384   E8E1 D9                              EXX
0385   E8E2 CD D7 EB                        CALL    keyboard_poll
0386   E8E5 2A 06 FF                        LD      HL, (timer)
0387   E8E8 23                              INC     HL
0388   E8E9 22 06 FF                        LD      (timer), HL
0389   E8EC D9                              EXX
0390   E8ED F1                              POP     AF
0391   E8EE FB                              EI
0392   E8EF ED 4D                           RETI
0393   E8F1             
0394   E8F1             ;======================================================================================================
0395   E8F1             ;
0396   E8F1             
0397   E8F1 CD F0 F0    default_ymodem      CALL    disp_clear_inline
0398   E8F4 53 74 61 72                     .DB     "Start transfer",0
0398   E8F8 74 20 74 72 
0398   E8FC 61 6E 73 66 
0398   E900 65 72 00 
0399   E903             
0400   E903 21 74 E5                        LD      HL, BIOS_START - YMODEM_BUFFER
0401   E906 11 FF FF                        LD      DE, 0FFFFh
0402   E909 CD 84 F4                        CALL    ymodem
0403   E90C A7                              AND     A
0404   E90D 20 73                           JR      NZ, _modem_error
0405   E90F             
0406   E90F 0E 13                           LD      C, 00010011b            ; Enable View, Exec and Exit options
0407   E911 3A 74 E5                        LD      A, (BIOS_START - YMODEM_BUFFER)
0408   E914 CB 7F                           BIT     7, A
0409   E916 20 0B                           JR      NZ, _modem_options_set
0410   E918 A7                              AND     A
0411   E919 28 04                           JR      Z, _is_firmware
0412   E91B 3E 04                           LD      A, 00000100b            ; Enable flash write
0413   E91D 18 02                           JR      _just_flash
0414   E91F 3E 08       _is_firmware        LD      A, 00001000b            ; Enable firmware write
0415   E921 B1          _just_flash         OR      C
0416   E922 4F                              LD      C, A
0417   E923 21 CE E9    _modem_options_set  LD      HL, _modem_menu
0418   E926 79                              LD      A, C
0419   E927 CD BC E7                        CALL    menu_setup
0420   E92A             
0421   E92A CD AC EC    _modem_menu_loop    CALL    read_character
0422   E92D C4 25 E8                        CALL    NZ, menu_button
0423   E930 18 F8                           JR      _modem_menu_loop
0424   E932             
0425   E932 ED 5B 78 E5 _modem_view         LD      DE, (BIOS_START - YMODEM_BUFFER+4)
0426   E936 C3 2A EA                        JP      memory_view
0427   E939             
0428   E939 2A 78 E5    _modem_exec         LD      HL, (BIOS_START - YMODEM_BUFFER+4)
0429   E93C E5                              PUSH    HL
0430   E93D C9          _modem_exit         RET
0431   E93E             
0432   E93E             _modem_bios
0433   E93E CD F0 F0    _modem_flash        CALL    disp_clear_inline
0434   E941 57 72 69 74                     .DB     "Writing",0
0434   E945 69 6E 67 00 
0435   E949 3A 74 E5                        LD      A, (BIOS_START - YMODEM_BUFFER)
0436   E94C 57                              LD      D, A
0437   E94D 2A 78 E5                        LD      HL, (BIOS_START - YMODEM_BUFFER+4)
0438   E950 ED 4B 76 E5                     LD      BC, (BIOS_START - YMODEM_BUFFER+2)
0439   E954 CD 97 F7                        CALL    flash_write
0440   E957             
0441   E957                                 ; Write hex values to OK message...
0442   E957 3A 77 E5                        LD      A, (BIOS_START - YMODEM_BUFFER+3)
0443   E95A 21 72 E9                        LD      HL, _modem_length
0444   E95D CD D7 EA                        CALL    hex_out
0445   E960 3A 76 E5                        LD      A, (BIOS_START - YMODEM_BUFFER+2)
0446   E963 21 74 E9                        LD      HL, _modem_length+2
0447   E966 CD D7 EA                        CALL    hex_out
0448   E969 CD F0 F0                        CALL    disp_clear_inline
0449   E96C 57 72 6F 74                     .DB     "Wrote "
0449   E970 65 20 
0450   E972 30 30 30 30 _modem_length       .DB     "0000h bytes",0
0450   E976 68 20 62 79 
0450   E97A 74 65 73 00 
0451   E97E CD EA EC                        CALL    get_key
0452   E981 C9                              RET
0453   E982             
0454   E982 C6 30       _modem_error        ADD     A, '0'
0455   E984 32 A7 E9                        LD      (_modem_error_disp),A
0456   E987 32 C4 E9                        LD      (_modem_error_uart),A
0457   E98A 79                              LD      A, C
0458   E98B F5                              PUSH    AF
0459   E98C FE 0A                           CP      10
0460   E98E 38 01                           JR      C, _error_in_range
0461   E990 AF                              XOR     A
0462   E991 C6 30       _error_in_range     ADD     A, '0'
0463   E993 32 A8 E9                        LD      (_modem_error_disp+1), A
0464   E996 32 C5 E9                        LD      (_modem_error_uart+1), A
0465   E999 CD F0 F0                        CALL    disp_clear_inline
0466   E99C 45 72 72 6F                     .DB     "Error code "
0466   E9A0 72 20 63 6F 
0466   E9A4 64 65 20 
0467   E9A7 00          _modem_error_disp   .DB     0
0468   E9A8 00                              .DB     0
0469   E9A9 20 00                           .DB     ' ', 0
0470   E9AB CD F4 EC                        CALL    wait_for_key
0471   E9AE F1                              POP     AF
0472   E9AF CD 34 EE                        CALL    uart_hex
0473   E9B2 CD 53 EE                        CALL    uart_inline
0474   E9B5 0D 0A 4D 6F                     .DB     "\r\nModem error: "
0474   E9B9 64 65 6D 20 
0474   E9BD 65 72 72 6F 
0474   E9C1 72 3A 20 
0475   E9C4 00          _modem_error_uart   .DB     0
0476   E9C5 00                              .DB     0
0477   E9C6 0D 0A 00                        .DB     "\r\n",0
0478   E9C9 11 74 E5                        LD     DE, BIOS_START - YMODEM_BUFFER
0479   E9CC 18 5C                           JR     memory_view
0480   E9CE             
0481   E9CE 46 69 6C 65 _modem_menu         .DB     "File OK. Select action", 0
0481   E9D2 20 4F 4B 2E 
0481   E9D6 20 53 65 6C 
0481   E9DA 65 63 74 20 
0481   E9DE 61 63 74 69 
0481   E9E2 6F 6E 00 
0482   E9E5 32 E9                           .DW     _modem_view
0483   E9E7 56 69 65 77                     .DB     "View file", 0
0483   E9EB 20 66 69 6C 
0483   E9EF 65 00 
0484   E9F1 39 E9                           .DW     _modem_exec
0485   E9F3 45 78 65 63                     .DB     "Execute", 0
0485   E9F7 75 74 65 00 
0486   E9FB 3E E9                           .DW     _modem_flash
0487   E9FD 57 72 69 74                     .DB     "Write to flash", 0
0487   EA01 65 20 74 6F 
0487   EA05 20 66 6C 61 
0487   EA09 73 68 00 
0488   EA0C 3E E9                           .DW     _modem_bios
0489   EA0E 55 70 64 61                     .DB     "Update firmware",0
0489   EA12 74 65 20 66 
0489   EA16 69 72 6D 77 
0489   EA1A 61 72 65 00 
0490   EA1E 3D E9                           .DW     _modem_exit
0491   EA20 45 78 69 74                     .DB     "Exit", 0
0491   EA24 00 
0492   EA25 00 00                           .DW     0
0493   EA27                                 
0494   EA27             ;======================================================================================================
0495   EA27             
0496   EA27 11 00 80    default_memory_view LD      DE, 8000h
0497   EA2A CD FD EC    memory_view         CALL    wait_no_keys                ; Debounce keys
0498   EA2D AF                              XOR     A
0499   EA2E 32 04 FF                        LD      (temp_byte), A
0500   EA31 CD EF EA                        CALL    mem_view_left
0501   EA34             
0502   EA34 D5          _memory_loop        PUSH    DE
0503   EA35 3A 04 FF                        LD      A, (temp_byte)
0504   EA38 A7                              AND     A
0505   EA39 20 05                           JR      NZ, _not_left
0506   EA3B CD 9C EA                        CALL    display_mem_address
0507   EA3E 18 03                           JR      _view_loop
0508   EA40             
0509   EA40 CD 8A EA    _not_left           CALL    display_mem_row
0510   EA43             
0511   EA43 CD AC EC    _view_loop          CALL    read_character
0512   EA46 28 FB                           JR      Z, _view_loop
0513   EA48             
0514   EA48 D1                              POP     DE
0515   EA49 FE 80                           CP      KEY_UP
0516   EA4B 20 0C                           JR      NZ, _view_not_up
0517   EA4D             
0518   EA4D 62                              LD      H, D
0519   EA4E 6B                              LD      L, E
0520   EA4F 11 08 00                        LD      DE, 8
0521   EA52 A7                              AND     A
0522   EA53 ED 52                           SBC     HL, DE
0523   EA55 54                              LD      D, H
0524   EA56 5D                              LD      E, L
0525   EA57 18 DB                           JR      _memory_loop
0526   EA59             
0527   EA59 FE 81       _view_not_up        CP      KEY_DOWN
0528   EA5B 20 08                           JR      NZ, _view_not_down
0529   EA5D             
0530   EA5D 21 08 00                        LD      HL, 8
0531   EA60 19                              ADD     HL, DE
0532   EA61 54                              LD      D, H
0533   EA62 5D                              LD      E, L
0534   EA63 18 CF                           JR      _memory_loop    
0535   EA65             
0536   EA65 FE 7F       _view_not_down      CP      KEY_DELETE
0537   EA67 20 09                           JR      NZ, _view_not_del
0538   EA69 1E 80                           LD      E, DISP_DEFAULT_BRIGHTNESS
0539   EA6B CD FD EF                        CALL    disp_brightness
0540   EA6E CD FD EC                        CALL    wait_no_keys
0541   EA71 C9                              RET
0542   EA72             
0543   EA72 FE 0D       _view_not_del       CP      KEY_ENTER
0544   EA74 20 BE                           JR      NZ, _memory_loop
0545   EA76             
0546   EA76 3A 04 FF                        LD      A, (temp_byte)
0547   EA79 2F                              CPL
0548   EA7A 32 04 FF                        LD      (temp_byte), A
0549   EA7D A7                              AND     A
0550   EA7E 20 05                           JR      NZ, _show_right
0551   EA80 CD EF EA                        CALL    mem_view_left
0552   EA83 18 AF                           JR      _memory_loop
0553   EA85 CD 12 EB    _show_right         CALL    mem_view_right
0554   EA88 18 AA                           JR      _memory_loop
0555   EA8A             
0556   EA8A             
0557   EA8A             
0558   EA8A             
0559   EA8A 21 28 FF    display_mem_row     LD      HL, scratch_pad
0560   EA8D 06 08                           LD      B, 8
0561   EA8F D5                              PUSH    DE
0562   EA90             
0563   EA90 1A          _row_hex            LD      A, (DE)
0564   EA91 13                              INC     DE
0565   EA92 CD D7 EA                        CALL    hex_out
0566   EA95 10 F9                           DJNZ    _row_hex
0567   EA97 D1                              POP     DE
0568   EA98             
0569   EA98 06 08                           LD      B, 8
0570   EA9A 18 1B                           JR      _write_char
0571   EA9C             
0572   EA9C             ; Display data at address DE.
0573   EA9C             ;
0574   EA9C             ; Display format is AAAA_0011223344556677ccc
0575   EA9C             ;                or 0011223344556677cccccccc
0576   EA9C             ; 
0577   EA9C             ; Where AAAA is address, 0123 are memory values, ccc are characters    
0578   EA9C             ;
0579   EA9C 21 28 FF    display_mem_address LD      HL, scratch_pad
0580   EA9F 7A                              LD      A, D
0581   EAA0 CD D7 EA                        CALL    hex_out
0582   EAA3 7B                              LD      A, E
0583   EAA4 CD D7 EA                        CALL    hex_out
0584   EAA7 36 20                           LD      (HL), ' '
0585   EAA9 23                              INC     HL
0586   EAAA 06 08                           LD      B, 8
0587   EAAC D5                              PUSH    DE
0588   EAAD             
0589   EAAD 1A          _write_hex          LD      A, (DE)
0590   EAAE 13                              INC     DE
0591   EAAF CD D7 EA                        CALL    hex_out
0592   EAB2 10 F9                           DJNZ    _write_hex
0593   EAB4 D1                              POP     DE
0594   EAB5 06 03                           LD      B, 3
0595   EAB7             
0596   EAB7 1A          _write_char         LD      A, (DE)
0597   EAB8 13                              INC     DE
0598   EAB9 CD C6 EA                        CALL    _char_out
0599   EABC 10 F9                           DJNZ    _write_char
0600   EABE             
0601   EABE AF                              XOR     A
0602   EABF 77                              LD      (HL), A
0603   EAC0 21 28 FF                        LD      HL, scratch_pad
0604   EAC3 C3 FB F0                        JP      disp_string
0605   EAC6             
0606   EAC6 FE 20       _char_out           CP      ' '
0607   EAC8 D2 CD EA                        JP      NC, _not_control_char
0608   EACB 3E 2E                           LD      A, '.'
0609   EACD FE 80       _not_control_char   CP      128
0610   EACF DA D4 EA                        JP      C, _not_extended_char
0611   EAD2 3E 2E                           LD      A, '.'
0612   EAD4 77          _not_extended_char  LD      (HL), A
0613   EAD5 23                              INC     HL
0614   EAD6 C9                              RET
0615   EAD7             
0616   EAD7             ;
0617   EAD7             ; Write the Hex value of A as two characters to (HL)
0618   EAD7             ; Uses C
0619   EAD7             ;
0620   EAD7 4F          hex_out            LD      C, A
0621   EAD8 CB 3F                           SRL     A
0622   EADA CB 3F                           SRL     A
0623   EADC CB 3F                           SRL     A
0624   EADE CB 3F                           SRL     A
0625   EAE0 CD E4 EA                        CALL    _nibble
0626   EAE3 79                              LD      A, C
0627   EAE4             
0628   EAE4 E6 0F       _nibble             AND     $0F      ;LOW NIBBLE ONLY
0629   EAE6 C6 90                           ADD     A,$90
0630   EAE8 27                              DAA 
0631   EAE9 CE 40                           ADC     A,$40
0632   EAEB 27                              DAA 
0633   EAEC 77                              LD      (HL),A
0634   EAED 23                              INC     HL
0635   EAEE C9                              RET
0636   EAEF             
0637   EAEF D5          mem_view_left       PUSH    DE
0638   EAF0 1E 80                           LD      E, DISP_DEFAULT_BRIGHTNESS
0639   EAF2 CD FD EF                        CALL    disp_brightness
0640   EAF5 3E 00                           LD      A, 0
0641   EAF7 06 04                           LD      B, 4
0642   EAF9 CD 05 EB                        CALL    _set_chars
0643   EAFC 3E 15                           LD      A, 21
0644   EAFE 06 03                           LD      B, 3
0645   EB00 CD 05 EB                        CALL    _set_chars
0646   EB03 D1                              POP     DE
0647   EB04 C9                              RET
0648   EB05             
0649   EB05 4F          _set_chars          LD      C, A
0650   EB06 C5                              PUSH    BC
0651   EB07 0E 18                           LD      C, DISP_DIMMED
0652   EB09 CD 66 F0                        CALL    disp_char_bright
0653   EB0C C1                              POP     BC
0654   EB0D 79                              LD      A, C
0655   EB0E 3C                              INC     A
0656   EB0F 10 F4                           DJNZ    _set_chars
0657   EB11 C9                              RET
0658   EB12             
0659   EB12 D5          mem_view_right      PUSH    DE
0660   EB13 1E 80                           LD      E, DISP_DEFAULT_BRIGHTNESS
0661   EB15 CD FD EF                        CALL    disp_brightness
0662   EB18 3E 10                           LD      A, 16
0663   EB1A 06 08                           LD      B, 8
0664   EB1C CD 05 EB                        CALL    _set_chars
0665   EB1F D1                              POP     DE
0666   EB20 C9                              RET
0667   EB21             
0668   EB21             ; Divide HL by C (unsigned)
0669   EB21             ;Inputs:
0670   EB21             ;     HL is the numerator
0671   EB21             ;     C is the denominator
0672   EB21             ;Outputs:
0673   EB21             ;     A is the remainder
0674   EB21             ;     B is 0
0675   EB21             ;     C is not changed
0676   EB21             ;     DE is not changed
0677   EB21             ;     HL is the quotient
0678   EB21             ;
0679   EB21             divide_hl_c
0680   EB21 06 10                           LD      B, 16
0681   EB23 AF                              XOR     A
0682   EB24 29          _div0               ADD     HL, HL
0683   EB25 17                              RLA
0684   EB26 B9                              CP      C
0685   EB27 38 02                           JR      C,_div1
0686   EB29 2C                              INC     L
0687   EB2A 91                              SUB     C
0688   EB2B 10 F7       _div1               DJNZ    _div0
0689   EB2D C9                              RET
0690   EB2E             
0691   EB2E             ;
0692   EB2E             ; Convert DE to a five digit BCD value stored in bcd_scratch
0693   EB2E             ; 
0694   EB2E AF          de_to_bcd           XOR     A
0695   EB2F 21 66 EB                        LD      HL, bcd_scratch
0696   EB32 06 05                           LD      B, 5
0697   EB34 77          _clear_scratch      LD      (HL), A
0698   EB35 23                              INC     HL
0699   EB36 10 FC                           DJNZ    _clear_scratch
0700   EB38                 
0701   EB38 06 10                           LD      B, 16           ; Convert 16 bits
0702   EB3A 0E 05       _bcd_loop           LD      C, 5
0703   EB3C 21 66 EB                        LD      HL, bcd_scratch
0704   EB3F 7E          _correct_digits     LD      A, (HL)
0705   EB40 FE 05                           CP      5
0706   EB42 38 03                           JR      C, _digit_ok
0707   EB44 C6 03                           ADD     A, 3
0708   EB46 77                              LD      (HL), A
0709   EB47 23          _digit_ok           INC     HL
0710   EB48 0D                              DEC     C
0711   EB49 20 F4                           JR      NZ, _correct_digits                   
0712   EB4B             
0713   EB4B 21 66 EB                        LD      HL, bcd_scratch
0714   EB4E 0E 05                           LD      C, 5
0715   EB50 CB 23                           SLA     E
0716   EB52 CB 12                           RL      D
0717   EB54             
0718   EB54 7E          _shift_digits       LD      A, (HL)
0719   EB55 CB 17                           RL      A
0720   EB57 CB 67                           BIT     4, A
0721   EB59 28 03                           JR      Z, _skip_carry
0722   EB5B E6 0F                           AND     0Fh
0723   EB5D 37                              SCF
0724   EB5E 77          _skip_carry         LD      (HL), A
0725   EB5F 23                              INC     HL
0726   EB60 0D                              DEC     C
0727   EB61 20 F1                           JR      NZ, _shift_digits
0728   EB63 10 D5                           DJNZ    _bcd_loop
0729   EB65 C9                              RET
0730   EB66             
0731   EB66 00 00 00 00 bcd_scratch         .DB      0,0,0,0,0      ; Five bytes - 0 to 99,999. Smallest digit (units) first
0731   EB6A 00 
0732   EB6B             
0733   EB6B 21 28 FF    prompt              LD      HL, scratch_pad
0734   EB6E 3E 3E                           LD      A, '>'
0735   EB70 06 19                           LD      B, 25
0736   EB72 77          _clear_prompt       LD      (HL), A
0737   EB73 23                              INC     HL
0738   EB74 AF                              XOR     A
0739   EB75 10 FB                           DJNZ    _clear_prompt
0740   EB77 32 52 FF                        LD      (cursor_pos), A
0741   EB7A CD 25 F1    _prompt_refresh     CALL    disp_clear
0742   EB7D AF          _prompt_display     XOR     A
0743   EB7E 21 28 FF                        LD      HL, scratch_pad
0744   EB81 CD FB F0                        CALL    disp_string
0745   EB84 CD AC EC    _prompt_loop        CALL    read_character
0746   EB87 28 FB                           JR      Z, _prompt_loop
0747   EB89 4F                              LD      C, A
0748   EB8A FE 7F                           CP      KEY_DELETE
0749   EB8C 28 1D                           JR      Z, _prompt_delete
0750   EB8E FE 0D                           CP      KEY_ENTER
0751   EB90 28 2D                           JR      Z, _prompt_enter
0752   EB92             
0753   EB92 CB 7F                           BIT     7, A
0754   EB94 20 EE                           JR      NZ, _prompt_loop
0755   EB96                                 
0756   EB96 3A 52 FF                        LD      A, (cursor_pos)
0757   EB99 FE 17                           CP      23
0758   EB9B 28 E7                           JR      Z, _prompt_loop
0759   EB9D 3C                              INC     A
0760   EB9E 32 52 FF                        LD      (cursor_pos),A
0761   EBA1 21 28 FF                        LD      HL, scratch_pad
0762   EBA4 5F                              LD      E, A
0763   EBA5 16 00                           LD      D, 0
0764   EBA7 19                              ADD     HL, DE
0765   EBA8 71                              LD      (HL), C                   
0766   EBA9 18 D2                           JR      _prompt_display
0767   EBAB             
0768   EBAB 3A 52 FF    _prompt_delete      LD      A, (cursor_pos)
0769   EBAE A7                              AND     A
0770   EBAF 28 D3                           JR      Z, _prompt_loop
0771   EBB1 21 28 FF                        Ld      HL, scratch_pad
0772   EBB4 5F                              LD      E, A
0773   EBB5 16 00                           LD      D, 0
0774   EBB7 19                              ADD     HL, DE
0775   EBB8 72                              LD      (HL), D
0776   EBB9 3D                              DEC     A
0777   EBBA 32 52 FF                        LD      (cursor_pos),A
0778   EBBD 18 BB                           JR      _prompt_refresh
0779   EBBF             
0780   EBBF C9          _prompt_enter       RET
0781   EBC0             
0782   EBC0                                 .INCLUDE shared_data.asm
0001+  EBC0             ;
0002+  EBC0             ; Shared data - common state data for routines
0003+  EBC0             ;
0004+  EBC0             ;
0005+  EBC0             
0006+  EBC0             
0007+  EBC0             ; I2C/Port B routines
0008+  EBC0             port_b_mode         .equ    0FF00h
0009+  EBC0             port_b_dir          .equ    0FF01h
0010+  EBC0             port_b_data         .equ    0FF02h
0011+  EBC0             
0012+  EBC0             ; Boot 
0013+  EBC0             boot_mode           .equ    0FF03h          ; Zero = normal boot, non-zero = delete pressed
0014+  EBC0             temp_byte           .equ    0FF04h
0015+  EBC0             
0016+  EBC0             ; Display functions
0017+  EBC0             display_address     .equ    0FF05h          ; byte
0018+  EBC0             
0019+  EBC0             ;
0020+  EBC0             ; Stuff
0021+  EBC0             timer               .equ    0FF06h          ; Word
0022+  EBC0             
0023+  EBC0             ; General I/O
0024+  EBC0             ;
0025+  EBC0             ; This MUST start with keyboard_state, and will all be reset to zero when io_init is called
0026+  EBC0             ;
0027+  EBC0             _key_state_size     .EQU    8               ; 8 key rollover
0028+  EBC0             
0029+  EBC0             keyboard_state      .EQU    0FF08h          ; state buffer - 8 bytes containing raw key codes for keys currently pressed
0030+  EBC0             keyboard_pos        .EQU    0FF10h          ; Internal state
0031+  EBC0             key_shift_state     .EQU    0FF12h          ; Holds state of shift and control keys in bits 0 and 1 respectively
0032+  EBC0             
0033+  EBC0             _input_buffer_size  .EQU    16
0034+  EBC0             input_buffer        .EQU    0FF13h          ; 16 byte input buffer. Note wraparound is handled by bitmasks, so don't change this length
0035+  EBC0             input_pos           .EQU    0FF23h          ; Next read position in input buffer
0036+  EBC0             input_free          .EQU    0FF24h          ; Next write position in input buffer
0037+  EBC0             input_size          .EQU    0FF25h          ; Bytes occupied in the input buffer
0038+  EBC0             
0039+  EBC0             io_data_end         .EQU    0FF25h          ; Byte after IO data block, used to reset values to zero
0040+  EBC0             
0041+  EBC0             
0042+  EBC0             scratch_pad         .EQU    0FF28h          ; 26 byte scratch area used for composing display output (eg. rtc time display etc.)
0043+  EBC0             
0044+  EBC0             temp_data           .EQU    0FF42h          ; 8 byte general data area
0045+  EBC0             
0046+  EBC0             menu_start          .EQU    0FF4Ah          ; Start address of current menu definition
0047+  EBC0             menu_item_start     .EQU    0FF4Ch          ; Start address of first item in menu
0048+  EBC0             menu_count          .EQU    0FF4Eh          ; Number of items in menu
0049+  EBC0             menu_index          .EQU    0FF4Fh          ; Current menu item
0050+  EBC0             menu_timer          .EQU    0FF50h          ; Time since menu was displayed
0051+  EBC0             menu_enabled        .EQU    0FF51h          ; D0 - D7 -> Menu item 1 to 8 set enabled (1) or disabled (0) 
0052+  EBC0             
0053+  EBC0             cursor_pos          .EQU    0FF52h          ; Position of cursor for prompt
0054+  EBC0             
0055+  EBC0             ;
0056+  EBC0             ; Panic codes
0057+  EBC0             ;
0058+  EBC0             PANIC_0001          .EQU    0F001h
0059+  EBC0             PANIC_0002          .EQU    0F002h
0060+  EBC0             PANIC_0003          .EQU    0F003h
0061+  EBC0             PANIC_0004          .EQU    0F004h0783   EBC0                                 
0784   EBC0                                 .INCLUDE ports.asm
0001+  EBC0             ;
0002+  EBC0             ; Port definintions
0003+  EBC0             ;
0004+  EBC0             ;
0005+  EBC0             
0006+  EBC0             CARRIAGE_RETURN     .EQU  0Dh
0007+  EBC0             NEWLINE             .EQU  0Ah
0008+  EBC0             
0009+  EBC0             ;=================================== UART ============================================
0010+  EBC0             UART_TX_RX          .EQU    020h    ; Read: receiver buffer, Write: transmitter buffer
0011+  EBC0             UART_INT_ENABLE     .EQU    021h    ; Interrupt enable register
0012+  EBC0             UART_INT_ID         .EQU    022h    ; Read: Interrupt identification register
0013+  EBC0             UART_FIFO_CTRL      .EQU    022h    ; Write: FIFO Control register
0014+  EBC0             UART_LINE_CTRL      .EQU    023h    ; Line control register
0015+  EBC0             UART_MODEM_CTRL     .EQU    024h    ; Modem control
0016+  EBC0             UART_LINE_STATUS    .EQU    025h    ; Line status
0017+  EBC0             UART_MODEM_STATUS   .EQU    026h    ; Modem status
0018+  EBC0             UART_SCRATCH        .EQU    027h    ; Scratch register
0019+  EBC0             
0020+  EBC0             ;==================================== PIO ============================================
0021+  EBC0             PIO_A_DATA          .EQU  010h
0022+  EBC0             PIO_A_CTRL          .EQU  012h
0023+  EBC0             
0024+  EBC0             PIO_B_DATA          .EQU  011h
0025+  EBC0             PIO_B_CTRL          .EQU  013h
0026+  EBC0             
0027+  EBC0             PIO_MODE_0          .EQU  00Fh      ; Mode 0: All outputs
0028+  EBC0             PIO_MODE_1          .EQU  04fh      ; Mode 1: All inputs
0029+  EBC0             PIO_MODE_2          .EQU  080h      ; Mode 2 (Port A only): Bi-directional
0030+  EBC0             PIO_MODE_3          .EQU  0CFh      ; Mode 3: Per-pin I/O on the given port - write an additional word with bits set (1) for input, reset (0) for output on the matching pin.
0031+  EBC0             
0032+  EBC0             PIO_SET_INTERRUPT   .EQU  007h      ; Set interrupt control world. By itself, this wil disable interrupts on the given port. OR with the following constants to change this
0033+  EBC0             PIO_ENABLE_INT      .EQU  080h      ; Enable interrupts on the given port, when OR'd with the PIO_SET_INTERRUPT control word.
0034+  EBC0             PIO_INT_MASK        .EQU  010h      ; When OR'd with the PIO_SET_INTERRUPT control word, the following word will enable interrupts for pins where the matching bit is zero
0035+  EBC0             
0036+  EBC0             ;================================== AUDIO ============================================
0037+  EBC0             ; Constants for Audio output
0038+  EBC0             AUDIO_PIO           .EQU  1         ; Audio on PIO (rev. 0.1 boards)
0039+  EBC0             AUDIO_UART          .EQU  2         ; Audio on UART (rev. 0.2 boards)
0040+  EBC0             
0041+  EBC0             AUDIO_VERSION       .EQU  AUDIO_UART
0042+  EBC0             
0043+  EBC0~            #IF AUDIO_VERSION = AUDIO_PIO
0044+  EBC0~            PORT_B_IOMASK       .EQU  0EFh      ; All inputs, apart from bit 4 (audio out)
0045+  EBC0~            AUDIO_MASK          .EQU  010h      ; Bitmask for audio output on Port B. The bit is set for the output pin.
0046+  EBC0~            AUDIO_PORT          .EQU  PIO_B_DATA
0047+  EBC0~            
0048+  EBC0             #ELSE
0049+  EBC0             PORT_B_IOMASK       .EQU  0FFh      ; All inputs
0050+  EBC0             AUDIO_MASK          .EQU  008h      ; Bitmask for audio output on UART Out 2. The bit is set for the output pin
0051+  EBC0             AUDIO_PORT          .EQU  UART_MODEM_CTRL
0052+  EBC0             
0053+  EBC0             #ENDIF
0054+  EBC0             
0055+  EBC0             
0056+  EBC0             ;=================================== MEMORY PAGING ===================================
0057+  EBC0             IO_MEM_0            .EQU  070h      ; Page 0: 0000h - 3fffh
0058+  EBC0             IO_MEM_1            .EQU  071h      ; Page 1: 4000h - 7fffh
0059+  EBC0             IO_MEM_2            .EQU  072h      ; Page 2: 8000h - bfffh
0060+  EBC0             IO_MEM_3            .EQU  073h      ; Page 3: c000h - ffffh
0061+  EBC0             
0062+  EBC0             IO_MEM_CTRL         .EQU  074h      ; Paging enable register
0063+  EBC0             IO_MEM_ENABLE       .EQU  1
0064+  EBC0             IO_MEM_DISABLE      .EQU  0 
0065+  EBC0             
0066+  EBC0             
0067+  EBC0             ;====================================== I2C DEVICES ===================================
0068+  EBC0             I2C_DATA_BIT            .equ    7
0069+  EBC0             I2C_CLK_BIT             .equ    6
0070+  EBC0             
0071+  EBC0             I2C_DATA_MASK           .equ    1 << I2C_DATA_BIT
0072+  EBC0             I2C_CLK_MASK            .equ    1 << I2C_CLK_BIT
0073+  EBC0             
0074+  EBC0             ; Display
0075+  EBC0             DL_ADDRESS              .EQU    050h     ; Left  Matrix controller I2C address
0076+  EBC0             DR_ADDRESS              .EQU    053h     ; Right Matrix controller I2C address
0077+  EBC0             
0078+  EBC0             DISP_REG_CRWL           .EQU    0FEh     ; Command Register write lock
0079+  EBC0             DISP_UNLOCK             .EQU    0C5h     ; Unlock command
0080+  EBC0             
0081+  EBC0             DISP_DEFAULT_BRIGHTNESS .EQU    080h     ; Default brightness
0082+  EBC0             DISP_DIMMED             .EQU    018h     ; Dimmed
0083+  EBC0             
0084+  EBC0             ; RTC
0085+  EBC0             RTC_ADDRESS             .EQU    06fh
0086+  EBC0             
0087+  EBC0             RTC_REG_SEC             .EQU    000h    ; Also has oscillator enable bit in B7, 1 = run
0088+  EBC0             RTC_REG_MIN             .EQU    001h
0089+  EBC0             RTC_REG_HOUR            .EQU    002h    ; B6: 1 = 12hr/ 0 = 24hr clock (r/w) 
0090+  EBC0                                                     ;        If 12 hr clock, B5: 1 = PM/ 0 = AM. B4: hour tens. Otherwise B5-4: hour tens, B3-0: hour units
0091+  EBC0             RTC_REG_WKDAY           .EQU    003h    ; Oscillator status bit in B5, 1 = enabled and running. 
0092+  EBC0                                                     ;   B4: 1 = power was lost, write 0 to clear (timestamp registers are set)
0093+  EBC0                                                     ;   B3: 1 = enable external battery supply (VBAT)
0094+  EBC0                                                     ;   B2-0: Weekday, from 1 to 7 
0095+  EBC0             RTC_REG_DATE            .EQU    004h    ; BCD Date (1 to 31)
0096+  EBC0             RTC_REG_MTH             .EQU    005h    ; B5: 1 = Leap year (read only). B4: month tens, B3-0: month units  (Month is 1 to 12)
0097+  EBC0             RTC_REG_YEAR            .EQU    006h    ; BCD Year
0098+  EBC0             
0099+  EBC0             RTC_REG_CTRL            .EQU    007h    ; B7: If Square wave and Alarm 0 and Alarm 1 are disabled, sets Output Pin level
0100+  EBC0                                                     ;   B6: SQWEN, 1 = Enable square wave on Output Pin, Alarms disabled
0101+  EBC0                                                     ;   B5, B4: Alarm 1, 0 Enable. 1 = Alarm is enabled
0102+  EBC0                                                     ;   B3: 1 = Use external oscillator
0103+  EBC0                                                     ;   B2: CRSTRIM, 1 = Coarse trim mode, Output pin is 64Hz
0104+  EBC0                                                     ;   B1-0: If SQWEN = 1 & CRSTRIM = 0, sets Output pin freq. 00 -> 1Hz, 01 -> 4.096kHz, 10 -> 8.192kHz, 11 -> 32.768kHz
0105+  EBC0             RTC_REG_TRIM            .EQU    008h    ; Trim, initially 0. B7: Sign, 1=Add, 0=Subtract clock cycles.  
0106+  EBC0                                                     ;   B6-0: Trim amount/2. Applied 1 every minute in fine trim, 128 times a second in coarse trim mode. 0 = disable trim0785   EBC0                                 .INCLUDE io.asm
0001+  EBC0             ;
0002+  EBC0             ; I/O routines.. specifically keyboard and serial
0003+  EBC0             ;
0004+  EBC0             ;
0005+  EBC0             
0006+  EBC0             
0007+  EBC0 21 08 FF    io_init             LD      HL, keyboard_state
0008+  EBC3 06 1D                           LD      B, io_data_end - keyboard_state
0009+  EBC5 AF                              XOR     A
0010+  EBC6 77          _init_loop          LD      (HL),A
0011+  EBC7 23                              INC     HL
0012+  EBC8 05                              DEC     B
0013+  EBC9 C2 C6 EB                        JP      NZ, _init_loop
0014+  EBCC AF                              XOR     A
0015+  EBCD 32 25 FF                        LD      (input_size),A
0016+  EBD0 32 24 FF                        LD      (input_free),A
0017+  EBD3 32 23 FF                        LD      (input_pos),A
0018+  EBD6 C9                              RET
0019+  EBD7             
0020+  EBD7             ; Poll the keyboard, adding raw codes to the keyboard_state buffer, and decoded characters to the input_buffer
0021+  EBD7             ;
0022+  EBD7 01 00 FE    keyboard_poll       LD      BC, 0FE00h          ; Keyboard row 0
0023+  EBDA 21 0E ED                        LD      HL, keyboard
0024+  EBDD ED 78       _poll_loop          IN      A, (C)              ; BC -> Keyboard row port..
0025+  EBDF 16 01                           LD      D, 1                ; D -> Current Bit
0026+  EBE1 5F                              LD      E, A                ; E -> Key row bit set
0027+  EBE2 22 10 FF    _next_key           LD      (keyboard_pos), HL
0028+  EBE5 A2                              AND     D
0029+  EBE6 C2 62 EC                        JP      NZ, _released
0030+  EBE9                                                             ; Key is pressed... add it to state buffer
0031+  EBE9 C5                              PUSH    BC
0032+  EBEA 7E                              LD      A, (HL)             ; Raw key code in A
0033+  EBEB             
0034+  EBEB 21 08 FF                        LD      HL, keyboard_state
0035+  EBEE 06 08                           LD      B, _key_state_size
0036+  EBF0 BE          _check_pressed      CP      (HL)
0037+  EBF1 CA 8C EC                        JP      Z, _do_nothing      ; Key already in state table - nothing to do..
0038+  EBF4 23                              INC     HL
0039+  EBF5 05                              DEC     B
0040+  EBF6 C2 F0 EB                        JP      NZ, _check_pressed
0041+  EBF9                                                             ; Key wasn't pressed, so add it to the first free slot
0042+  EBF9 21 08 FF                        LD      HL, keyboard_state
0043+  EBFC 06 08                           LD      B, _key_state_size
0044+  EBFE 4F                              LD      C, A
0045+  EBFF AF                              XOR     A
0046+  EC00 BE          _find_free          CP      (HL)
0047+  EC01 CA 0C EC                        JP      Z, _key_pressed
0048+  EC04 23                              INC     HL
0049+  EC05 05                              DEC     B
0050+  EC06 C2 00 EC                        JP      NZ, _find_free
0051+  EC09 C3 8C EC                        JP      _do_nothing         ; No free slots, so ignore the key
0052+  EC0C             
0053+  EC0C 71          _key_pressed        LD      (HL), C             ; Found free slot, store the raw key code
0054+  EC0D             
0055+  EC0D                                                             ; Now find the actual character code and add it to the input buffer
0056+  EC0D 3E 84                           LD      A, KEY_SHIFT        ; Handle modifier keys
0057+  EC0F B9                              CP      C
0058+  EC10 06 01                           LD      B, KEY_SHIFT_BIT
0059+  EC12 CA 58 EC                        JP      Z, _modifier
0060+  EC15 3E 86                           LD      A, KEY_CTRL
0061+  EC17 B9                              CP      C
0062+  EC18 06 02                           LD      B, KEY_CTRL_BIT
0063+  EC1A CA 58 EC                        JP      Z, _modifier         
0064+  EC1D             
0065+  EC1D 2A 10 FF                        LD      HL, (keyboard_pos)  ; Get the current keyboard character location
0066+  EC20 01 30 00                        LD      BC, _keyboard_size
0067+  EC23 3A 12 FF                        LD      A, (key_shift_state)
0068+  EC26 A7                              AND     A
0069+  EC27 CA 2F EC                        JP      Z, _get_key
0070+  EC2A 09          _modifier_offset    ADD     HL, BC
0071+  EC2B 3D                              DEC     A
0072+  EC2C C2 2A EC                        JP      NZ, _modifier_offset
0073+  EC2F             
0074+  EC2F                                                             ; Write the character to the input buffer
0075+  EC2F 7E          _get_key            LD      A, (HL)             ; Get the actual character...
0076+  EC30 A7                              AND     A                   ; Skip blank character codes
0077+  EC31 CA 8C EC                        JP      Z, _do_nothing
0078+  EC34             
0079+  EC34 6F                              LD      L, A                ; Store it in L
0080+  EC35             
0081+  EC35 3A 25 FF                        LD      A, (input_size)     ; Now check we have space
0082+  EC38 FE 10                           CP      _input_buffer_size
0083+  EC3A CA 8C EC                        JP      Z, _do_nothing
0084+  EC3D             
0085+  EC3D 3C                              INC     A
0086+  EC3E 32 25 FF                        LD      (input_size), A
0087+  EC41             
0088+  EC41 06 00                           LD      B, 0
0089+  EC43 3A 24 FF                        LD      A, (input_free)
0090+  EC46 4F                              LD      C, A
0091+  EC47 7D                              LD      A, L                ; Get the character from L
0092+  EC48 21 13 FF                        LD      HL, input_buffer
0093+  EC4B 09                              ADD     HL, BC
0094+  EC4C 77                              LD      (HL), A             ; Store the character
0095+  EC4D             
0096+  EC4D 0C                              INC     C                   ; Point to next byte in input
0097+  EC4E 3E 0F                           LD      A, 0Fh
0098+  EC50 A1                              AND     C
0099+  EC51 32 24 FF                        LD      (input_free), A
0100+  EC54             
0101+  EC54 C1                              POP     BC
0102+  EC55 C3 8D EC                        JP      _poll_next
0103+  EC58             
0104+  EC58 3A 12 FF    _modifier           LD      A, (key_shift_state)
0105+  EC5B B0                              OR      B
0106+  EC5C 32 12 FF                        LD      (key_shift_state), A
0107+  EC5F C3 8C EC                        JP      _do_nothing
0108+  EC62             
0109+  EC62                                                             ; Key is not pressed... remove it from the state buffer if it was pressed (key up event)
0110+  EC62                                                             ; TODO: This is rather inefficient...
0111+  EC62 C5          _released           PUSH    BC
0112+  EC63 7E                              LD      A, (HL)             ; Raw key code in A
0113+  EC64 A7                              AND     A
0114+  EC65 CA 8C EC                        JP      Z, _do_nothing      ; Ignore character zero
0115+  EC68             
0116+  EC68 21 08 FF                        LD      HL, keyboard_state
0117+  EC6B 06 08                           LD      B, _key_state_size
0118+  EC6D BE          _check_released     CP      (HL)
0119+  EC6E CA 79 EC                        JP      Z, _handle_release
0120+  EC71 23                              INC     HL
0121+  EC72 05                              DEC     B
0122+  EC73 C2 6D EC                        JP      NZ, _check_released
0123+  EC76 C3 8C EC                        JP      _do_nothing         ; Code not in state buffer, not released
0124+  EC79             
0125+  EC79 4F          _handle_release     LD      C, A
0126+  EC7A AF                              XOR     A
0127+  EC7B 77                              LD      (HL), A             ; Remove it from the buffer 
0128+  EC7C             
0129+  EC7C                                                             ; TODO: We should probably tell someone about this...
0130+  EC7C 3E 84                           LD      A, KEY_SHIFT        ; Handle modifier keys
0131+  EC7E B9                              CP      C
0132+  EC7F 06 01                           LD      B, KEY_SHIFT_BIT
0133+  EC81 CA A2 EC                        JP      Z, _modifier_up
0134+  EC84 3E 86                           LD      A, KEY_CTRL
0135+  EC86 B9                              CP      C
0136+  EC87 06 02                           LD      B, KEY_CTRL_BIT
0137+  EC89 CA A2 EC                        JP      Z, _modifier_up     
0138+  EC8C             
0139+  EC8C C1          _do_nothing         POP     BC
0140+  EC8D             
0141+  EC8D 2A 10 FF    _poll_next          LD      HL, (keyboard_pos)
0142+  EC90 7B                              LD      A, E                ; Get the bitmask back
0143+  EC91 23                              INC     HL
0144+  EC92 CB 22                           SLA     D
0145+  EC94 CB 72                           BIT     6, D
0146+  EC96 CA E2 EB                        JP      Z, _next_key
0147+  EC99             
0148+  EC99 CB 00                           RLC     B                   ; Move to the next key row
0149+  EC9B 3E FE                           LD      A, 0FEh
0150+  EC9D B8                              CP      B
0151+  EC9E C2 DD EB                        JP      NZ, _poll_loop
0152+  ECA1 C9                              RET
0153+  ECA2             
0154+  ECA2 3A 12 FF    _modifier_up        LD      A, (key_shift_state)
0155+  ECA5 A8                              XOR     B
0156+  ECA6 32 12 FF                        LD      (key_shift_state), A
0157+  ECA9 C3 8C EC                        JP      _do_nothing
0158+  ECAC             
0159+  ECAC             ;
0160+  ECAC             ; Reads the next available character in A, returning that or 0 if none are available
0161+  ECAC             ; Z flag is set if no character
0162+  ECAC             ; Uses HL, BC, A
0163+  ECAC 3A 25 FF    read_character      LD      A, (input_size)
0164+  ECAF A7                              AND     A
0165+  ECB0 C8                              RET     Z
0166+  ECB1             
0167+  ECB1 F3                              DI                          ; Make sure we don't get into a race condition..
0168+  ECB2 3A 25 FF                        LD      A, (input_size)
0169+  ECB5 3D                              DEC     A
0170+  ECB6 32 25 FF                        LD      (input_size),A
0171+  ECB9 3A 23 FF                        LD      A, (input_pos)
0172+  ECBC 4F                              LD      C, A
0173+  ECBD 3C                              INC     A
0174+  ECBE E6 0F                           AND     0Fh
0175+  ECC0 32 23 FF                        LD      (input_pos),A
0176+  ECC3 06 00                           LD      B, 0
0177+  ECC5 21 13 FF                        LD      HL, input_buffer
0178+  ECC8 09                              ADD     HL, BC
0179+  ECC9 7E                              LD      A, (HL)
0180+  ECCA B7                              OR      A
0181+  ECCB FB                              EI
0182+  ECCC C9                              RET
0183+  ECCD             
0184+  ECCD             ;
0185+  ECCD             ; Beep  - Middle C is 261.625Hz = 30578 cycles at 8Mhz - 15289 per half cycle
0186+  ECCD             ; Call with: HL - cycle time ( 0E80h = Middle C )
0187+  ECCD             ;             E - Number of cycles
0188+  ECCD             ;
0189+  ECCD             
0190+  ECCD             
0191+  ECCD DB 24       play_tone           IN      A, (AUDIO_PORT)        ; 200 cycles = 2/3 of a sec
0192+  ECCF 57                              LD      D, A
0193+  ECD0 7A          _beep_loop          LD      A, D
0194+  ECD1 EE 08                           XOR     AUDIO_MASK
0195+  ECD3 D3 24                           OUT     (AUDIO_PORT), A
0196+  ECD5             
0197+  ECD5 4D                              LD      C, L
0198+  ECD6 44          _beep_delay0        LD      B, H
0199+  ECD7 10 FE       _beep_delay1        DJNZ    _beep_delay1        ; 13 * (count-2) + 8
0200+  ECD9 0D                              DEC     C
0201+  ECDA 20 FA                           JR      NZ, _beep_delay0
0202+  ECDC             
0203+  ECDC 7A                              LD      A, D          
0204+  ECDD D3 24                           OUT     (AUDIO_PORT), A
0205+  ECDF             
0206+  ECDF 4D                              LD      C, L
0207+  ECE0 44          _beep_delay2        LD      B, H
0208+  ECE1 10 FE       _beep_delay3        DJNZ    _beep_delay3        ; 13 * (count-2) + 8
0209+  ECE3 0D                              DEC     C
0210+  ECE4 20 FA                           JR      NZ, _beep_delay2      
0211+  ECE6             
0212+  ECE6 1D                              DEC     E
0213+  ECE7 20 E7                           JR      NZ, _beep_loop
0214+  ECE9 C9                              RET
0215+  ECEA             
0216+  ECEA             ;
0217+  ECEA             ; Get the next key press
0218+  ECEA             ;
0219+  ECEA CD AC EC    get_key             CALL    read_character
0220+  ECED 06 00                           LD      B, 0
0221+  ECEF 10 FE                           DJNZ    $
0222+  ECF1 28 F7                           JR      Z, get_key
0223+  ECF3 C9                              RET
0224+  ECF4             ;
0225+  ECF4             ; Wait for a key to be pressed and released
0226+  ECF4             ;
0227+  ECF4             ;
0228+  ECF4 CD AC EC    wait_for_key        CALL    read_character
0229+  ECF7 06 00                           LD      B, 0
0230+  ECF9 10 FE                           DJNZ    $
0231+  ECFB 28 F7                           JR      Z, wait_for_key
0232+  ECFD             
0233+  ECFD             ;
0234+  ECFD             ; wait until there are no keys being pressed
0235+  ECFD             ;
0236+  ECFD             ;
0237+  ECFD CD AC EC    wait_no_keys        CALL    read_character
0238+  ED00 20 FB                           JR      NZ, wait_no_keys
0239+  ED02 01 00 00                        LD      BC, 0h              ; Make sure key is released
0240+  ED05 ED 78                           IN      A, (C)
0241+  ED07 E6 3F                           AND     03Fh
0242+  ED09 FE 3F                           CP      03Fh
0243+  ED0B 20 F0                           JR      NZ, wait_no_keys
0244+  ED0D C9                              RET
0245+  ED0E             
0246+  ED0E             ; Non-printing key codes
0247+  ED0E             ;
0248+  ED0E             KEY_ENTER       .EQU    13
0249+  ED0E             KEY_DELETE      .EQU    127
0250+  ED0E             
0251+  ED0E             
0252+  ED0E             ; Modifier and special keys have key codes with the top bit set..
0253+  ED0E             ;
0254+  ED0E             KEY_UP          .EQU    128
0255+  ED0E             KEY_DOWN        .EQU    129
0256+  ED0E             KEY_LEFT        .EQU    130
0257+  ED0E             KEY_RIGHT       .EQU    131
0258+  ED0E             KEY_SHIFT       .EQU    132
0259+  ED0E             KEY_CTRL        .EQU    134
0260+  ED0E             
0261+  ED0E             _keyboard_size  .EQU    48
0262+  ED0E             
0263+  ED0E             KEY_SHIFT_BIT   .EQU    1
0264+  ED0E             KEY_CTRL_BIT    .EQU    2
0265+  ED0E             
0266+  ED0E 76 63 78 7A keyboard        .DB    "vcxz", KEY_SHIFT, 0
0266+  ED12 84 00 
0267+  ED14 67 66 64 73                 .DB    "gfdsa", KEY_CTRL
0267+  ED18 61 86 
0268+  ED1A 74 72 65 77                 .DB    "trewq", KEY_DOWN
0268+  ED1E 71 81 
0269+  ED20 35 34 33 32                 .DB    "54321", KEY_UP  
0269+  ED24 31 80 
0270+  ED26 36 37 38 39                 .DB    "67890", KEY_DELETE
0270+  ED2A 30 7F 
0271+  ED2C 79 75 69 6F                 .DB    "yuiop;"
0271+  ED30 70 3B 
0272+  ED32 68 6A 6B 6C                 .DB    "hjkl.", KEY_ENTER
0272+  ED36 2E 0D 
0273+  ED38 62 6E 6D 20                 .DB    "bnm ", KEY_LEFT, KEY_RIGHT
0273+  ED3C 82 83 
0274+  ED3E             
0275+  ED3E 56 43 58 5A _shifted        .DB     "VCXZ", 0, 0
0275+  ED42 00 00 
0276+  ED44 47 46 44 53                 .DB     "GFDSA", 0
0276+  ED48 41 00 
0277+  ED4A 54 52 45 57                 .DB     "TREWQ", 0              ; Shift + down?
0277+  ED4E 51 00 
0278+  ED50 25 24 23 22                 .DB     "%$", 35, 34, "!", 0    ; Shift + up
0278+  ED54 21 00 
0279+  ED56 5E 26 2A 28                 .DB     "^&*()", 0              ; Shift + delete
0279+  ED5A 29 00 
0280+  ED5C 59 55 49 4F                 .DB     "YUIOP:"
0280+  ED60 50 3A 
0281+  ED62 48 4A 4B 4C                 .DB     "HJKL,", 0              ; Shift + enter
0281+  ED66 2C 00 
0282+  ED68 42 4E 4D 00                 .DB     "BNM", 0,0,0            ; Shift left + right
0282+  ED6C 00 00 
0283+  ED6E             
0284+  ED6E 00 00 00 00 _ctrl           .DB    0,0,0,0,0,0
0284+  ED72 00 00 
0285+  ED74 00 00 00 00                 .DB    0,0,0,0,0,0
0285+  ED78 00 00 
0286+  ED7A 00 00 00 00                 .DB    0,0,0,0,0,0
0286+  ED7E 00 00 
0287+  ED80 00 00 00 00                 .DB    0,0,0,0,0,0
0287+  ED84 00 00 
0288+  ED86 00 00 00 00                 .DB    0,0,0,0,0,0
0288+  ED8A 00 00 
0289+  ED8C 00 00 2B 3D                 .DB    0,0, "+=-", 0
0289+  ED90 2D 00 
0290+  ED92 00 3C 40 3E                 .DB    0, "<@>_", 0
0290+  ED96 5F 00 
0291+  ED98 00 3F 2F 00                 .DB    0, "?/", 0,0,0
0291+  ED9C 00 00 
0292+  ED9E             
0293+  ED9E 00 00 00 00 _shift_ctrl     .DB    0,0,0,0,0,0
0293+  EDA2 00 00 
0294+  EDA4 00 00 00 00                 .DB    0,0,0,0,0,0
0294+  EDA8 00 00 
0295+  EDAA 00 00 00 00                 .DB    0,0,0,0,0,0
0295+  EDAE 00 00 
0296+  EDB0 00 00 00 00                 .DB    0,0,0,0,0,0
0296+  EDB4 00 00 
0297+  EDB6 00 00 00 00                 .DB    0,0,0,0,0,0
0297+  EDBA 00 00 
0298+  EDBC 00 00 00 00                 .DB    0,0,0,0,0,0
0298+  EDC0 00 00 
0299+  EDC2 00 00 00 00                 .DB    0,0,0,0,0,0
0299+  EDC6 00 00 
0300+  EDC8 00 00 00 00                 .DB    0,0,0,0,0,0
0300+  EDCC 00 00 
0786   EDCE                                 .INCLUDE uart.asm
0001+  EDCE             ;
0002+  EDCE             ; UART routines..
0003+  EDCE             ;
0004+  EDCE             ;
0005+  EDCE             
0006+  EDCE                                 .MODULE     uart
0007+  EDCE             
0008+  EDCE             ;
0009+  EDCE             ; Baud rates, assuming 1.8432Mhz crystal
0010+  EDCE             ;
0011+  EDCE             UART_9600           .EQU    12
0012+  EDCE             UART_19200          .EQU    6
0013+  EDCE             UART_38400          .EQU    3
0014+  EDCE             
0015+  EDCE             UART_MODE_AUTO      .EQU    022h   ; Auto flow mode
0016+  EDCE             UART_MODE_NO_FLOW   .EQU    000h   ; Auto RTS and CTS disabled
0017+  EDCE             UART_MODE_DIAG      .EQU    030h   ; Loopback mode
0018+  EDCE             
0019+  EDCE             ;
0020+  EDCE             ; Various constants
0021+  EDCE             ;
0022+  EDCE             UART_8N1            .EQU    003h
0023+  EDCE             UART_TIMEOUT        .EQU    50000
0024+  EDCE             
0025+  EDCE             _CTS_STATUS_MASK    .EQU    010h
0026+  EDCE             
0027+  EDCE             ;
0028+  EDCE             ; Set up the UART. Assume it has had time to settle after reset...
0029+  EDCE             ;
0030+  EDCE             ;
0031+  EDCE 01 06 00    uart_init           LD      BC, UART_19200              ; B is flow control, 0 -> No auto flow control
0032+  EDD1             
0033+  EDD1 DB 26                           IN      A,(UART_MODEM_STATUS)       ; If CTS is enabled, assume we can use flow control
0034+  EDD3 E6 10                           AND     _CTS_STATUS_MASK
0035+  EDD5 28 02                           JR      Z, _no_listener
0036+  EDD7             
0037+  EDD7 06 22                           LD      B, UART_MODE_AUTO
0038+  EDD9                                     
0039+  EDD9 3E 80       _no_listener        LD      A, 80h                      ; Divisor Latch Setting Mode
0040+  EDDB D3 23                           OUT     (UART_LINE_CTRL), A         ;  - entered by writing 1 to bit 7 of LCR
0041+  EDDD 00                              NOP
0042+  EDDE 00                              NOP
0043+  EDDF 79                              LD      A, C
0044+  EDE0 D3 20                           OUT     (UART_TX_RX), A
0045+  EDE2 00                              NOP
0046+  EDE3 00                              NOP
0047+  EDE4 AF                              XOR     A
0048+  EDE5 D3 21                           OUT     (UART_INT_ENABLE), A
0049+  EDE7 00                              NOP
0050+  EDE8 00                              NOP
0051+  EDE9             
0052+  EDE9 3E 03                           LD      A, UART_8N1                 ; Set 8N1 and exit divisor latch setting mode
0053+  EDEB D3 23                           OUT     (UART_LINE_CTRL), A
0054+  EDED             
0055+  EDED 3E 07                           LD      A, 07h                      ; Enable and clear FIFO registers
0056+  EDEF D3 22                           OUT     (UART_FIFO_CTRL), A
0057+  EDF1             
0058+  EDF1 78                              LD      A, B
0059+  EDF2 A7                              AND     A
0060+  EDF3 28 02                           JR      Z, _no_flowcontrol
0061+  EDF5             
0062+  EDF5 D3 24                           OUT     (UART_MODEM_CTRL), A
0063+  EDF7             
0064+  EDF7 00          _no_flowcontrol     NOP
0065+  EDF8 00                              NOP
0066+  EDF9 C9                              RET
0067+  EDFA             
0068+  EDFA             ;
0069+  EDFA             ; Send character in A to UART
0070+  EDFA             ; Preserves all registers
0071+  EDFA             ;
0072+  EDFA             ; Carry flag is set on return if the UART send succeeded, clear if it timed out
0073+  EDFA             ;
0074+  EDFA C5          uart_send           PUSH    BC
0075+  EDFB F5                              PUSH    AF
0076+  EDFC 01 50 C3                        LD      BC, UART_TIMEOUT
0077+  EDFF DB 25       _check_ready        IN      A, (UART_LINE_STATUS)
0078+  EE01 CB 6F                           BIT     5, A
0079+  EE03 C2 11 EE                        JP      NZ, _uart_ready             ; Bit 5 is set when the UART is ready
0080+  EE06 0B                              DEC     BC
0081+  EE07 78                              LD      A, B
0082+  EE08 B1                              OR      C
0083+  EE09 C2 FF ED                        JP      NZ, _check_ready
0084+  EE0C             
0085+  EE0C F1                              POP     AF
0086+  EE0D C1                              POP     BC
0087+  EE0E 37                              SCF
0088+  EE0F 3F                              CCF
0089+  EE10 C9                              RET
0090+  EE11             
0091+  EE11 F1          _uart_ready         POP     AF
0092+  EE12 C1                              POP     BC
0093+  EE13 D3 20                           OUT     (UART_TX_RX), A
0094+  EE15 37                              SCF
0095+  EE16 C9                              RET
0096+  EE17             
0097+  EE17             ;
0098+  EE17             ; Check to see if there are any characters to receive
0099+  EE17             ; Preserves all registers
0100+  EE17             ;
0101+  EE17             ; Returns with carry set if there are characters ready, clear if not
0102+  EE17             ;
0103+  EE17 F5          uart_ready          PUSH    AF
0104+  EE18 DB 25                           IN      A, (UART_LINE_STATUS)
0105+  EE1A CB 47                           BIT     0, A
0106+  EE1C CA 22 EE                        JP      Z, _not_ready
0107+  EE1F F1                              POP     AF
0108+  EE20 37                              SCF
0109+  EE21 C9                              RET
0110+  EE22             
0111+  EE22 F1          _not_ready          POP     AF
0112+  EE23 37                              SCF
0113+  EE24 3F                              CCF
0114+  EE25 C9                              RET
0115+  EE26             
0116+  EE26             ;
0117+  EE26             ; Receive a character from the UART in A
0118+  EE26             ; 
0119+  EE26             ; Returns with a character in A and the carry flag set. If no characters
0120+  EE26             ; are available, returns with the carry flag clear.
0121+  EE26             ;
0122+  EE26 DB 25       uart_receive        IN      A, (UART_LINE_STATUS)
0123+  EE28 CB 47                           BIT     0, A
0124+  EE2A CA 31 EE                        JP      Z, _no_character
0125+  EE2D DB 20                           IN      A, (UART_TX_RX)
0126+  EE2F 37                              SCF
0127+  EE30 C9                              RET
0128+  EE31             
0129+  EE31 37          _no_character       SCF
0130+  EE32 3F                              CCF
0131+  EE33 C9                              RET
0132+  EE34             
0133+  EE34             ;
0134+  EE34             ; Write A has a hex byte
0135+  EE34             ; Overwrites A...
0136+  EE34             ;
0137+  EE34 F5          uart_hex            PUSH    AF
0138+  EE35 CB 2F                           SRA     A
0139+  EE37 CB 2F                           SRA     A
0140+  EE39 CB 2F                           SRA     A
0141+  EE3B CB 2F                           SRA     A
0142+  EE3D CD 4A EE                        CALL    to_hex
0143+  EE40 CD FA ED                        CALL    uart_send
0144+  EE43 F1                              POP     AF
0145+  EE44 CD 4A EE                        CALL    to_hex
0146+  EE47 C3 FA ED                        JP      uart_send
0147+  EE4A             ;
0148+  EE4A             ; Returns the low nibble of A as a hex digit
0149+  EE4A             ;
0150+  EE4A E6 0F       to_hex              AND $0F      ;LOW NIBBLE ONLY
0151+  EE4C C6 90                           ADD A,$90
0152+  EE4E 27                              DAA 
0153+  EE4F CE 40                           ADC A,$40
0154+  EE51 27                              DAA 
0155+  EE52 C9                              RET 
0156+  EE53             ;
0157+  EE53             ; Inline send. Sends the zero terminated string immediately following the call to this function to the UART.
0158+  EE53             ;
0159+  EE53             ; Returns with Carry set if the string was successfully sent, otherwise, carry is clear.
0160+  EE53             ;
0161+  EE53             ; Uses A 
0162+  EE53             ;
0163+  EE53 E3          uart_inline         EX      (SP), HL
0164+  EE54 CD 62 EE                        CALL    uart_string
0165+  EE57 DA 60 EE                        JP      C, _inline_end      
0166+  EE5A 7E          _find_end           LD      A, (HL)             ; Get the current character  (Carry preserved)
0167+  EE5B 23                              INC     HL                  ; Point to next character    (Carry preserved)
0168+  EE5C A7                              AND     A                   ; Test if the current character was zero (Clears carry)
0169+  EE5D C2 5A EE                        JP      NZ, _find_end       ; If it was, we're done, otherwise repeat
0170+  EE60 E3          _inline_end         EX      (SP), HL
0171+  EE61 C9                              RET
0172+  EE62             ;
0173+  EE62             ; Send a zero terminated string pointed to by HL to the UART
0174+  EE62             ;
0175+  EE62             ; Returns with Carry Set if the string was sent sucessfully, clear otherwise
0176+  EE62             ;                    
0177+  EE62 7E          uart_string         LD      A,(HL)
0178+  EE63 23                              INC     HL
0179+  EE64 A7                              AND     A
0180+  EE65 CA 6F EE                        JP      Z, _string_end
0181+  EE68 CD FA ED                        CALL    uart_send
0182+  EE6B DA 62 EE                        JP      C, uart_string
0183+  EE6E C9                              RET
0184+  EE6F 37          _string_end         SCF
0185+  EE70 C9                              RET
0186+  EE71             
0187+  EE71                                 .MODULE main0787   EE71                                 .INCLUDE i2c.asm 
0001+  EE71             ; ============================================ I2C Routines =================================================
0002+  EE71             ; Assume I2C clock is on Port B bit 6
0003+  EE71             ;            data is on Port B bit 7
0004+  EE71             ;
0005+  EE71             
0006+  EE71                                 .MODULE i2c
0007+  EE71             
0008+  EE71 3E CF       init_portb          LD      A, PIO_MODE_3           ; Port B mode 3
0009+  EE73 32 00 FF                        LD      (port_b_mode), A
0010+  EE76 D3 13                           OUT     (PIO_B_CTRL), A
0011+  EE78             
0012+  EE78 3E FF                           LD      A, PORT_B_IOMASK        ;
0013+  EE7A 32 01 FF                        LD      (port_b_dir), A
0014+  EE7D D3 13                           OUT     (PIO_B_CTRL), A
0015+  EE7F             
0016+  EE7F 3E 3F                           LD      A, 03Fh                 ; All bits high apart from D7, D6
0017+  EE81 32 02 FF                        LD      (port_b_data),A
0018+  EE84 D3 11                           OUT     (PIO_B_DATA), A         ; Changing D7 or D6 to an output will drive the lines low
0019+  EE86 C9                              RET
0020+  EE87             
0021+  EE87             ; Reset the bus
0022+  EE87             ;
0023+  EE87             ; Uses A, B, D
0024+  EE87 06 0A       i2c_bus_reset       LD      B, 0ah          ; ten cycles
0025+  EE89 CD 97 EF    _loop_b             CALL    i2c_scl_cycle
0026+  EE8C 10 FB                           DJNZ    _loop_b
0027+  EE8E CD 87 EF                        CALL    i2c_scl_high
0028+  EE91 06 F0                           LD      B, 0F0h
0029+  EE93 10 FE                           DJNZ    $
0030+  EE95 C9                              RET
0031+  EE96             
0032+  EE96             ;
0033+  EE96             ; Uses A
0034+  EE96 CD 67 EF    i2c_start           CALL    i2c_sda_high
0035+  EE99 CD 87 EF                        CALL    i2c_scl_high
0036+  EE9C CD 77 EF                        CALL    i2c_sda_low     ; Drive data low
0037+  EE9F CD 57 EF                        CALL    i2c_scl_low     ; Drive clock low
0038+  EEA2 C9                              RET
0039+  EEA3             
0040+  EEA3             ;
0041+  EEA3             ; Uses A
0042+  EEA3 CD 77 EF    i2c_stop            CALL    i2c_sda_low     ; Drive data low
0043+  EEA6 CD 87 EF                        CALL    i2c_scl_high
0044+  EEA9 CD 67 EF                        CALL    i2c_sda_high
0045+  EEAC C9                              RET
0046+  EEAD             
0047+  EEAD             ;
0048+  EEAD             ; Read a byte from Device address H, Register L
0049+  EEAD             ; Calls i2c_start, but does NOT call i2c_stop
0050+  EEAD             ; Returns With Carry SET and A containing the register value, or Carry CLEAR if no acknowledge
0051+  EEAD             ; Uses A, B, C, D, H, L
0052+  EEAD             ; Preserves H, L
0053+  EEAD CD 96 EE    i2c_read_from       CALL    i2c_start
0054+  EEB0 7C                              LD      A, H
0055+  EEB1 CD E1 EE                        CALL    i2c_address_w
0056+  EEB4 30 17                           JR      NC, _read_end
0057+  EEB6 7D                              LD      A, L
0058+  EEB7 CD E3 EE                        CALL    i2c_write
0059+  EEBA 30 11                           JR      NC, _read_end
0060+  EEBC 06 32                           LD      B, 50
0061+  EEBE 10 FE       _read_pause         DJNZ    _read_pause
0062+  EEC0 CD 96 EE                        CALL    i2c_start
0063+  EEC3 7C                              LD      A, H
0064+  EEC4 CD DB EE                        CALL    i2c_address_r
0065+  EEC7 30 04                           JR      NC, _read_end
0066+  EEC9 CD F0 EE                        CALL    i2c_read
0067+  EECC 37                              SCF
0068+  EECD C9          _read_end           RET
0069+  EECE             
0070+  EECE             ;
0071+  EECE             ; Prepare to write to Device address H, Register L
0072+  EECE             ; Calls i2c_start, but does NOT call i2c_stop
0073+  EECE             ; Returns with Carry SET if OK, CLEAR if no acknowledgement
0074+  EECE             ;
0075+  EECE             ; Preserves H, L
0076+  EECE CD 96 EE    i2c_write_to        CALL    i2c_start
0077+  EED1 7C                              LD      A, H
0078+  EED2 CD E1 EE                        CALL    i2c_address_w
0079+  EED5 D0                              RET     NC
0080+  EED6 7D                              LD      A, L
0081+  EED7 CD E3 EE                        CALL    i2c_write
0082+  EEDA C9                              RET
0083+  EEDB             
0084+  EEDB             ; Start reading from device address held in A
0085+  EEDB             ;
0086+  EEDB             ; Uses A, B, C, D
0087+  EEDB CB 27       i2c_address_r       SLA     A
0088+  EEDD F6 01                           OR      1
0089+  EEDF 18 02                           JR      i2c_write
0090+  EEE1             
0091+  EEE1             ; Start writing to device address held in A
0092+  EEE1             ;
0093+  EEE1             ; Uses A, B, C, D
0094+  EEE1 CB 27       i2c_address_w       SLA     A
0095+  EEE3             
0096+  EEE3             ; Write A as a byte to i2c bus
0097+  EEE3             ; Returns Carry CLEAR if no acknowledge
0098+  EEE3             ;
0099+  EEE3             ; Uses A, B, C, D
0100+  EEE3 CD 0B EF    i2c_write           CALL    i2c_send_byte
0101+  EEE6 CB 7A                           BIT     I2C_DATA_BIT, D     ; D contains acknowledge bit
0102+  EEE8 37                              SCF
0103+  EEE9 C8                              RET     Z               ; Return with carry set if acknowledge bit is low
0104+  EEEA             
0105+  EEEA CD A3 EE                        CALL    i2c_stop        ; Stop bus if error
0106+  EEED 37                              SCF
0107+  EEEE 3F                              CCF
0108+  EEEF C9                              RET                     ; Clear carry if acknowledge is high
0109+  EEF0             
0110+  EEF0             ; Read byte from i2C into A, without ACK
0111+  EEF0             ;
0112+  EEF0             ; Uses A, B, C, D
0113+  EEF0 06 08       i2c_read            LD      B, 8h
0114+  EEF2 DB 11       _loop_r             IN      A, (PIO_B_DATA)
0115+  EEF4 37                              SCF
0116+  EEF5 CB 7F                           BIT     I2C_DATA_BIT, A
0117+  EEF7 20 01                           JR      NZ, _data_high
0118+  EEF9 3F                              CCF
0119+  EEFA CB 11       _data_high          RL      C
0120+  EEFC CD 97 EF                        CALL    i2c_scl_cycle
0121+  EEFF 10 F1                           DJNZ    _loop_r
0122+  EF01                                 ; CALL    i2c_scl_cycle
0123+  EF01             
0124+  EF01 79                              LD      A, C
0125+  EF02 C9                              RET
0126+  EF03             
0127+  EF03             ;
0128+  EF03             ; Send an ACK..
0129+  EF03             ;
0130+  EF03 CD 77 EF    i2c_ack             CALL    i2c_sda_low
0131+  EF06 CD 97 EF                        CALL    i2c_scl_cycle
0132+  EF09 18 5C                           JR      i2c_sda_high
0133+  EF0B             
0134+  EF0B             ;
0135+  EF0B             ; Send a byte in A, returning the ACK state in D
0136+  EF0B             ; Uses A, B, C,
0137+  EF0B             ;
0138+  EF0B E5          i2c_send_byte       PUSH    HL
0139+  EF0C D5                              PUSH    DE
0140+  EF0D 2A 00 FF                        LD      HL, (port_b_mode)           ; L = port_b_mode, H = port_b_dir
0141+  EF10 57                              LD      D, A
0142+  EF11                                 
0143+  EF11 3E 3F                           LD      A, ~(I2C_DATA_MASK|I2C_CLK_MASK)           ; Set SDA and SCL (port_b_dir bit) LOW
0144+  EF13 A4                              AND     H
0145+  EF14 CB 27                           SLA     A
0146+  EF16 67                              LD      H, A
0147+  EF17             
0148+  EF17 0E 13                           LD      C, PIO_B_CTRL
0149+  EF19 06 08                           LD      B, 8
0150+  EF1B             
0151+  EF1B 1E 40                           LD      E, I2C_CLK_MASK
0152+  EF1D             
0153+  EF1D 7C          _fast_loop          LD      A, H
0154+  EF1E CB 22                           SLA     D
0155+  EF20 CB 1F                           RR      A
0156+  EF22 ED 69                           OUT     (C),L
0157+  EF24 D3 13                           OUT     (PIO_B_CTRL), A
0158+  EF26             
0159+  EF26 B3                              OR      E
0160+  EF27 ED 69                           OUT     (C), L
0161+  EF29 D3 13                           OUT     (PIO_B_CTRL), A                 ; Clock high
0162+  EF2B             
0163+  EF2B AB                              XOR     E
0164+  EF2C ED 69                           OUT     (C), L
0165+  EF2E D3 13                           OUT     (PIO_B_CTRL),A                  ; Clock low
0166+  EF30 10 EB                           DJNZ    _fast_loop
0167+  EF32             
0168+  EF32 7C                              LD      A, H
0169+  EF33 37                              SCF
0170+  EF34 CB 1F                           RR      A
0171+  EF36 ED 69                           OUT     (C),L                           ; Release SDA
0172+  EF38 D3 13                           OUT     (PIO_B_CTRL), A
0173+  EF3A             
0174+  EF3A B3                              OR      E
0175+  EF3B ED 69                           OUT     (C), L
0176+  EF3D D3 13                           OUT     (PIO_B_CTRL), A                 ; Clock high
0177+  EF3F             
0178+  EF3F ED 69                           OUT     (C), L
0179+  EF41 AB                              XOR     E
0180+  EF42 6F                              LD      L, A
0181+  EF43 32 01 FF                        LD      (port_b_dir), A
0182+  EF46             
0183+  EF46 DB 11                           IN      A, (PIO_B_DATA)                 ; Read ACK
0184+  EF48 ED 69                           OUT     (C),L                           ; Clock low
0185+  EF4A             
0186+  EF4A D1                              POP     DE
0187+  EF4B E1                              POP     HL
0188+  EF4C 57                              LD      D, A
0189+  EF4D C9                              RET
0190+  EF4E             
0191+  EF4E             ; Cycle SCL, returning SDA,SCL in D
0192+  EF4E             ;
0193+  EF4E             ; Uses A, D
0194+  EF4E CD 57 EF    i2c_scl_cycle2      CALL    i2c_scl_low
0195+  EF51 CD 87 EF                        CALL    i2c_scl_high
0196+  EF54 DB 11                           IN      A, (PIO_B_DATA)
0197+  EF56 57                              LD      D, A
0198+  EF57                                 ; Fall into scl_low...
0199+  EF57             
0200+  EF57             ; SCL/SDA toggle routines
0201+  EF57             ;
0202+  EF57             ; All use A
0203+  EF57 3A 00 FF    i2c_scl_low         LD      A, (port_b_mode)
0204+  EF5A D3 13                           OUT     (PIO_B_CTRL), A
0205+  EF5C             
0206+  EF5C 3A 01 FF                        LD      A, (port_b_dir)
0207+  EF5F CB B7                           RES     I2C_CLK_BIT, A
0208+  EF61 D3 13                           OUT     (PIO_B_CTRL), A
0209+  EF63 32 01 FF                        LD      (port_b_dir), A
0210+  EF66 C9                              RET
0211+  EF67             
0212+  EF67 3A 00 FF    i2c_sda_high        LD      A, (port_b_mode)
0213+  EF6A D3 13                           OUT     (PIO_B_CTRL), A
0214+  EF6C             
0215+  EF6C 3A 01 FF                        LD      A, (port_b_dir)
0216+  EF6F CB FF                           SET     I2C_DATA_BIT, A
0217+  EF71 D3 13                           OUT     (PIO_B_CTRL), A
0218+  EF73 32 01 FF                        LD      (port_b_dir), A
0219+  EF76 C9                              RET
0220+  EF77             
0221+  EF77 3A 00 FF    i2c_sda_low         LD      A, (port_b_mode)
0222+  EF7A D3 13                           OUT     (PIO_B_CTRL), A
0223+  EF7C             
0224+  EF7C 3A 01 FF                        LD      A, (port_b_dir)
0225+  EF7F CB BF                           RES     I2C_DATA_BIT, A
0226+  EF81 D3 13                           OUT     (PIO_B_CTRL), A
0227+  EF83 32 01 FF                        LD      (port_b_dir), A
0228+  EF86 C9                              RET
0229+  EF87             
0230+  EF87 3A 00 FF    i2c_scl_high        LD      A, (port_b_mode)
0231+  EF8A D3 13                           OUT     (PIO_B_CTRL), A
0232+  EF8C             
0233+  EF8C 3A 01 FF                        LD      A, (port_b_dir)
0234+  EF8F CB F7                           SET     I2C_CLK_BIT, A
0235+  EF91 D3 13                           OUT     (PIO_B_CTRL), A
0236+  EF93 32 01 FF                        LD      (port_b_dir), A
0237+  EF96 C9                              RET
0238+  EF97             
0239+  EF97 C5          i2c_scl_cycle       PUSH   BC
0240+  EF98 01 13 00                        LD     BC, PIO_B_CTRL
0241+  EF9B 3A 00 FF                        LD     A, (port_b_mode)
0242+  EF9E 57                              LD     D, A
0243+  EF9F 3A 01 FF                        LD     A, (port_b_dir)
0244+  EFA2             
0245+  EFA2 CB B7                           RES    I2C_CLK_BIT, A
0246+  EFA4 32 01 FF                        LD     (port_b_dir), A
0247+  EFA7 ED 51                           OUT    (C), D
0248+  EFA9 D3 13                           OUT    (PIO_B_CTRL), A
0249+  EFAB                                 
0250+  EFAB CB F7                           SET    I2C_CLK_BIT, A
0251+  EFAD ED 51                           OUT    (C), D
0252+  EFAF D3 13                           OUT    (PIO_B_CTRL), A
0253+  EFB1                                 
0254+  EFB1 DB 11                           IN     A, (PIO_B_DATA)
0255+  EFB3 ED 51                           OUT    (C), D
0256+  EFB5 57                              LD     D, A
0257+  EFB6 3A 01 FF                        LD     A, (port_b_dir)
0258+  EFB9 D3 13                           OUT    (PIO_B_CTRL), A
0259+  EFBB C1                              POP    BC
0260+  EFBC C9                              RET
0261+  EFBD             
0262+  EFBD                                 .MODULE main
0788   EFBD             
0789   EFBD                                 .INCLUDE disp.asm
0001+  EFBD             ; ========================================== Display Routines ===============================================
0002+  EFBD             ;
0003+  EFBD                                 .MODULE disp
0004+  EFBD             
0005+  EFBD             CONFIG_PAGE         .EQU    3
0006+  EFBD             BRIGHT_PAGE         .EQU    1
0007+  EFBD             LED_PAGE            .EQU    0 
0008+  EFBD             
0009+  EFBD CD 25 F1    display_init        CALL    disp_clear
0010+  EFC0 1E 80                           LD      E, DISP_DEFAULT_BRIGHTNESS
0011+  EFC2 CD FD EF                        CALL    disp_brightness
0012+  EFC5             
0013+  EFC5 CD D1 EF                        CALL    disp_select_l
0014+  EFC8 CD DD EF                        CALL    disp_config
0015+  EFCB             
0016+  EFCB CD D7 EF                        CALL    disp_select_r
0017+  EFCE CD DD EF                        CALL    disp_config
0018+  EFD1             
0019+  EFD1 3E 50       disp_select_l       LD      A, DL_ADDRESS
0020+  EFD3 32 05 FF                        LD      (display_address), A
0021+  EFD6 C9                              RET
0022+  EFD7             
0023+  EFD7 3E 53       disp_select_r       LD      A, DR_ADDRESS
0024+  EFD9 32 05 FF                        LD      (display_address), A
0025+  EFDC C9                              RET
0026+  EFDD             
0027+  EFDD 2E 03       disp_config         LD      L, CONFIG_PAGE
0028+  EFDF CD 38 F0                        CALL    disp_page
0029+  EFE2 CD 96 EE                        CALL    i2c_start
0030+  EFE5 3A 05 FF                        LD      A, (display_address)
0031+  EFE8 CD E1 EE                        CALL    i2c_address_w
0032+  EFEB 3E 00                           LD      A, 000h
0033+  EFED CD E3 EE                        CALL    i2c_write
0034+  EFF0 3E 01                           LD      A, 001h         ; Turn display on
0035+  EFF2 CD E3 EE                        CALL    i2c_write
0036+  EFF5 3E 78                           LD      A, 078h         ; 0.020mA
0037+  EFF7 CD E3 EE                        CALL    i2c_write
0038+  EFFA C3 A3 EE                        JP      i2c_stop
0039+  EFFD             
0040+  EFFD             ;
0041+  EFFD             ; Sets the brightness for the display
0042+  EFFD             ; Enter with E set to the desired brightness for all segments
0043+  EFFD             ;
0044+  EFFD CD D1 EF    disp_brightness     CALL    disp_select_l
0045+  F000 CD 06 F0                        CALL    _set_bright
0046+  F003 CD D7 EF                        CALL    disp_select_r
0047+  F006 2E 01       _set_bright         LD      L, BRIGHT_PAGE
0048+  F008 CD 38 F0                        CALL    disp_page
0049+  F00B 2E 0C                           LD      L, 12
0050+  F00D CD 96 EE    _bright_loop        CALL    i2c_start
0051+  F010 3A 05 FF                        LD      A, (display_address)
0052+  F013 CD E1 EE                        CALL    i2c_address_w
0053+  F016 7D                              LD      A, L
0054+  F017 3D                              DEC     A
0055+  F018 CB 27                           SLA     A
0056+  F01A CB 27                           SLA     A
0057+  F01C CB 27                           SLA     A
0058+  F01E CB 27                           SLA     A
0059+  F020 CD E3 EE                        CALL    i2c_write
0060+  F023 26 10                           LD      H, 010h
0061+  F025 7B          _bright_byte        LD      A, E
0062+  F026 CD E3 EE                        CALL    i2c_write
0063+  F029 25                              DEC     H
0064+  F02A 20 F9                           JR      NZ, _bright_byte
0065+  F02C CD A3 EE                        CALL    i2c_stop
0066+  F02F 2D                              DEC     L
0067+  F030 20 DB                           JR      NZ, _bright_loop
0068+  F032 2E 00                           LD      L, LED_PAGE
0069+  F034 CD 38 F0                        CALL    disp_page
0070+  F037 C9                              RET
0071+  F038             
0072+  F038             ; Set the Page number
0073+  F038             ; Call with page number in L
0074+  F038             ;
0075+  F038             ; Uses A, B, C, D
0076+  F038 CD 50 F0    disp_page           CALL    disp_unlock
0077+  F03B CD 96 EE                        CALL    i2c_start
0078+  F03E 3A 05 FF                        LD      A, (display_address)
0079+  F041 CD E1 EE                        CALL    i2c_address_w
0080+  F044 3E FD                           LD      A, 0FDh
0081+  F046 CD E3 EE                        CALL    i2c_write
0082+  F049 7D                              LD      A, L
0083+  F04A CD E3 EE                        CALL    i2c_write
0084+  F04D C3 A3 EE                        JP      i2c_stop
0085+  F050             
0086+  F050 CD 96 EE    disp_unlock         CALL    i2c_start           ; Must be called before switching pages
0087+  F053 3A 05 FF                        LD      A, (display_address)
0088+  F056 CD E1 EE                        CALL    i2c_address_w
0089+  F059 3E FE                           LD      A, DISP_REG_CRWL
0090+  F05B CD E3 EE                        CALL    i2c_write
0091+  F05E 3E C5                           LD      A, DISP_UNLOCK
0092+  F060 CD E3 EE                        CALL    i2c_write
0093+  F063 C3 A3 EE                        JP      i2c_stop
0094+  F066             
0095+  F066             ; Set the character at column A to brightness C
0096+  F066             ;
0097+  F066             ;
0098+  F066 C5          disp_char_bright    PUSH    BC
0099+  F067 06 50                           LD      B, DL_ADDRESS
0100+  F069 FE 0C                           CP      12
0101+  F06B DA 72 F0                        JP      C, _bright_left
0102+  F06E 06 53                           LD      B, DR_ADDRESS
0103+  F070 D6 0C                           SUB     12
0104+  F072 5F          _bright_left        LD      E, A
0105+  F073 78                              LD      A, B
0106+  F074 32 05 FF                        LD      (display_address), A
0107+  F077 2E 01                           LD      L, BRIGHT_PAGE
0108+  F079 CD 38 F0                        CALL    disp_page
0109+  F07C             
0110+  F07C CD 96 EE                        CALL    i2c_start
0111+  F07F 3A 05 FF                        LD      A, (display_address)
0112+  F082 CD E1 EE                        CALL    i2c_address_w
0113+  F085 7B                              LD      A, E
0114+  F086 CB 27                           SLA     A
0115+  F088 CB 27                           SLA     A
0116+  F08A CB 27                           SLA     A
0117+  F08C CB 27                           SLA     A
0118+  F08E CD E3 EE                        CALL    i2c_write
0119+  F091 E1                              POP     HL
0120+  F092 26 10                           LD      H, 010h
0121+  F094 7D          _bright_char_loop   LD      A, L
0122+  F095 CD E3 EE                        CALL    i2c_write
0123+  F098 25                              DEC     H
0124+  F099 20 F9                           JR      NZ, _bright_char_loop
0125+  F09B CD A3 EE                        CALL    i2c_stop
0126+  F09E             
0127+  F09E 2E 00                           LD      L, LED_PAGE
0128+  F0A0 CD 38 F0                        CALL    disp_page
0129+  F0A3 C9                              RET
0130+  F0A4                                 
0131+  F0A4             ; Display a single character A at column C
0132+  F0A4             ;
0133+  F0A4             ; Returns with A pointing to next column
0134+  F0A4             ;
0135+  F0A4 FE 20       disp_character      CP      32
0136+  F0A6 F2 B0 F0                        JP      P, _not_control
0137+  F0A9             
0138+  F0A9 21 61 48    _invalid_char       LD      HL, INVALID_CHAR_BITMASK
0139+  F0AC 79                              LD      A, C
0140+  F0AD C3 C5 F0                        JP      disp_bitmask
0141+  F0B0             
0142+  F0B0 CB 7F       _not_control        BIT     7, A
0143+  F0B2 C2 A9 F0                        JP      NZ, _invalid_char
0144+  F0B5 D6 20                           SUB     32
0145+  F0B7             
0146+  F0B7 16 00                           LD      D, 0
0147+  F0B9 5F                              LD      E, A
0148+  F0BA CB 23                           SLA     E                   ; Don't need to shift into D, since bit 7 is zero
0149+  F0BC 21 33 F1                        LD      HL, font  
0150+  F0BF 19                              ADD     HL, DE
0151+  F0C0 56                              LD      D, (HL)
0152+  F0C1 23                              INC     HL
0153+  F0C2 66                              LD      H, (HL)
0154+  F0C3 6A                              LD      L, D
0155+  F0C4 79                              LD      A, C
0156+  F0C5                                 ; Fall into disp_bitmask
0157+  F0C5             
0158+  F0C5             ; Display a bitmask in HL at column A (0 - 23)
0159+  F0C5             ;
0160+  F0C5             ; Returns with A pointing to next column
0161+  F0C5             ;
0162+  F0C5             ; Uses A, B, C, D, E
0163+  F0C5 F5          disp_bitmask        PUSH    AF
0164+  F0C6 06 50                           LD      B, DL_ADDRESS
0165+  F0C8 FE 0C                           CP      12
0166+  F0CA DA D1 F0                        JP      C, _disp_left
0167+  F0CD 06 53                           LD      B, DR_ADDRESS
0168+  F0CF D6 0C                           SUB     12
0169+  F0D1 5F          _disp_left          LD      E, A
0170+  F0D2 CD 96 EE                        CALL    i2c_start
0171+  F0D5 78                              LD      A, B
0172+  F0D6 CD E1 EE                        CALL    i2c_address_w
0173+  F0D9 7B                              LD      A, E
0174+  F0DA CB 27                           SLA     A
0175+  F0DC CD E3 EE                        CALL    i2c_write
0176+  F0DF 7D                              LD      A, L
0177+  F0E0 CD E3 EE                        CALL    i2c_write
0178+  F0E3 7C                              LD      A, H
0179+  F0E4 CD E3 EE                        CALL    i2c_write
0180+  F0E7 CD A3 EE                        CALL    i2c_stop
0181+  F0EA F1                              POP     AF
0182+  F0EB 3C                              INC     A
0183+  F0EC C9                              RET
0184+  F0ED             
0185+  F0ED             
0186+  F0ED C3 C5 F0                        JP      disp_bitmask
0187+  F0F0             ;
0188+  F0F0             ; Clear the display and show an inline string from column 0
0189+  F0F0             ;
0190+  F0F0 CD 25 F1    disp_clear_inline   CALL    disp_clear
0191+  F0F3 AF                              XOR     A
0192+  F0F4             ;
0193+  F0F4             ; Display an inline string to column A->
0194+  F0F4             ;
0195+  F0F4 E3          disp_inline         EX      (SP), HL
0196+  F0F5 CD FB F0                        CALL    disp_string
0197+  F0F8 23                              INC     HL
0198+  F0F9 E3                              EX      (SP), HL
0199+  F0FA C9                              RET
0200+  F0FB             
0201+  F0FB             ; Display a string pointed to by HL to column A->
0202+  F0FB             ; Note string should be zero terminated...
0203+  F0FB             ; Returns with HL pointing to the 0 terminator
0204+  F0FB             ;
0205+  F0FB 5F          disp_string         LD      E, A
0206+  F0FC 7E                              LD      A, (HL)
0207+  F0FD B7                              OR      A
0208+  F0FE C2 02 F1                        JP      NZ, _char_ok
0209+  F101 C9                              RET
0210+  F102             
0211+  F102 D6 20       _char_ok            SUB     32
0212+  F104 F2 0C F1                        JP      P, _char_ok2
0213+  F107 21 61 48                        LD      HL, INVALID_CHAR_BITMASK
0214+  F10A 18 10                           JR      _show_char
0215+  F10C             
0216+  F10C 06 00       _char_ok2           LD      B, 0
0217+  F10E 4F                              LD      C, A
0218+  F10F E5                              PUSH    HL
0219+  F110 21 33 F1                        LD      HL, font
0220+  F113 CB 21                           SLA     C
0221+  F115 CB 10                           RL      B
0222+  F117 09                              ADD     HL, BC
0223+  F118 4E                              LD      C, (HL)
0224+  F119 23                              INC     HL
0225+  F11A 66                              LD      H, (HL)
0226+  F11B 69                              LD      L, C
0227+  F11C 7B          _show_char          LD      A, E
0228+  F11D CD C5 F0                        CALL    disp_bitmask
0229+  F120 E1                              POP     HL
0230+  F121 23                              INC     HL
0231+  F122 C3 FB F0                        JP      disp_string
0232+  F125             
0233+  F125             ; Clear the display
0234+  F125             ;
0235+  F125 3E 00       disp_clear          LD      A, 0
0236+  F127 21 00 00                        LD      HL, 0
0237+  F12A CD C5 F0    _clear_loop         CALL    disp_bitmask
0238+  F12D FE 18                           CP      24
0239+  F12F C2 2A F1                        JP      NZ, _clear_loop
0240+  F132 C9                              RET
0241+  F133             
0242+  F133                                 .MODULE main0790   F133                                 .INCLUDE font.asm
0001+  F133             ;
0002+  F133             ; Font definition
0003+  F133             ;
0004+  F133             ;
0005+  F133             
0006+  F133             INVALID_CHAR_BITMASK    .EQU 04861h
0007+  F133             
0008+  F133             font
0009+  F133 00 00                           .dw     0000h
0010+  F135 00 49                           .dw     4900h   ; !
0011+  F137 02 02                           .dw     0202h   ; "
0012+  F139 CE 12                           .dw     12ceh   ; #
0013+  F13B ED 12                           .dw     12edh   ; $
0014+  F13D E4 2D                           .dw     2de4h   ; %
0015+  F13F 59 0B                           .dw     0b59h   ; &
0016+  F141 00 02                           .dw     0200h   ; '
0017+  F143 00 0C                           .dw     0c00h   ; (
0018+  F145 00 21                           .dw     2100h   ; )
0019+  F147 C0 3F                           .dw     3fc0h   ; *
0020+  F149 C0 12                           .dw     12c0h   ; +
0021+  F14B 00 20                           .dw     2000h   ; ,
0022+  F14D C0 00                           .dw     00c0h   ; -
0023+  F14F 00 40                           .dw     4000h   ; .
0024+  F151 00 24                           .dw     2400h   ; /
0025+  F153             
0026+  F153 3F 24                           .dw     243fh   ; 0
0027+  F155 06 04                           .dw     0406h   ; 1
0028+  F157 DB 00                           .dw     00dbh   ; 2
0029+  F159 8F 00                           .dw     008fh   ; 3
0030+  F15B E6 00                           .dw     00e6h   ; 4
0031+  F15D 69 08                           .dw     0869h   ; 5
0032+  F15F FD 00                           .dw     00fdh   ; 6
0033+  F161 01 14                           .dw     1401h   ; 7
0034+  F163 FF 00                           .dw     00ffh   ; 8
0035+  F165 EF 00                           .dw     00efh   ; 9
0036+  F167 00 12                           .dw     1200h   ; :
0037+  F169 00 22                           .dw     2200h   ; ;
0038+  F16B 40 0C                           .dw     0c40h   ; <
0039+  F16D C8 00                           .dw     00c8h   ; = 
0040+  F16F 80 21                           .dw     2180h   ; >
0041+  F171 83 50                           .dw     5083h   ; ?
0042+  F173             
0043+  F173 BB 02                           .dw     02bbh   ; @
0044+  F175 F7 00                           .dw     00f7h   ; A
0045+  F177 8F 12                           .dw     128fh   ; B
0046+  F179 39 00                           .dw     0039h   ; C
0047+  F17B 0F 12                           .dw     120fh   ; D
0048+  F17D 79 00                           .dw     0079h   ; E
0049+  F17F 71 00                           .dw     0071h   ; F
0050+  F181 BD 00                           .dw     00bdh   ; G
0051+  F183 F6 00                           .dw     00f6h   ; H
0052+  F185 09 12                           .dw     1209h   ; I
0053+  F187 1E 00                           .dw     001eh   ; J
0054+  F189 70 0C                           .dw     0c70h   ; K
0055+  F18B 38 00                           .dw     0038h   ; L
0056+  F18D 36 05                           .dw     0536h   ; M
0057+  F18F 36 09                           .dw     0936h   ; N
0058+  F191 3F 00                           .dw     003fh   ; O
0059+  F193             
0060+  F193 F3 00                           .dw     00f3h   ; P
0061+  F195 3F 08                           .dw     083fh   ; Q
0062+  F197 F3 08                           .dw     08f3h   ; R
0063+  F199 ED 00                           .dw     00edh   ; S
0064+  F19B 01 12                           .dw     1201h   ; T
0065+  F19D 3E 00                           .dw     003eh   ; U
0066+  F19F 30 24                           .dw     2430h   ; V
0067+  F1A1 36 28                           .dw     2836h   ; W
0068+  F1A3 00 2D                           .dw     2d00h   ; X
0069+  F1A5 EE 00                           .dw     00eeh   ; Y
0070+  F1A7 09 24                           .dw     2409h   ; Z
0071+  F1A9 39 00                           .dw     0039h   ; [
0072+  F1AB 00 09                           .dw     0900h   ; \
0073+  F1AD 0F 00                           .dw     000fh   ; ]
0074+  F1AF 00 28                           .dw     2800h   ; ^
0075+  F1B1 08 00                           .dw     0008h   ; _
0076+  F1B3             
0077+  F1B3 00 01                           .dw     0100h   ; `
0078+  F1B5 8C 20                           .dw     208ch   ; a
0079+  F1B7 78 08                           .dw     0878h   ; b
0080+  F1B9 D8 00                           .dw     00d8h   ; c
0081+  F1BB 8E 20                           .dw     208eh   ; d 
0082+  F1BD 58 20                           .dw     2058h   ; e 
0083+  F1BF C0 14                           .dw     14c0h   ; f
0084+  F1C1 8E 04                           .dw     048eh   ; g
0085+  F1C3 70 10                           .dw     1070h   ; h
0086+  F1C5 00 10                           .dw     1000h   ; i
0087+  F1C7 10 22                           .dw     2210h   ; j
0088+  F1C9 00 1E                           .dw     1e00h   ; k
0089+  F1CB 30 00                           .dw     0030h   ; l
0090+  F1CD D4 10                           .dw     10d4h   ; m
0091+  F1CF 50 10                           .dw     1050h   ; n
0092+  F1D1 DC 00                           .dw     00dch   ; o
0093+  F1D3             
0094+  F1D3 70 01                           .dw     0170h   ; p
0095+  F1D5 86 04                           .dw     0486h   ; q
0096+  F1D7 50 00                           .dw     0050h   ; r
0097+  F1D9 88 08                           .dw     0888h   ; s
0098+  F1DB 78 00                           .dw     0078h   ; t
0099+  F1DD 1C 00                           .dw     001ch   ; u
0100+  F1DF 10 20                           .dw     2010h   ; v
0101+  F1E1 14 28                           .dw     2814h   ; w
0102+  F1E3 00 2D                           .dw     2d00h   ; x
0103+  F1E5 8E 02                           .dw     028eh   ; y
0104+  F1E7 48 20                           .dw     2048h   ; z
0105+  F1E9 49 21                           .dw     2149h   ; {
0106+  F1EB 00 12                           .dw     1200h   ; |
0107+  F1ED 89 0C                           .dw     0c89h   ; }
0108+  F1EF C0 24                           .dw     24c0h   ; ~
0109+  F1F1 00 00                           .dw     0000h   ; 0791   F1F3             
0792   F1F3                                 .INCLUDE rtc.asm
0001+  F1F3             ; RTC Routines
0002+  F1F3             ;
0003+  F1F3             ;
0004+  F1F3             ;
0005+  F1F3                                     .MODULE rtc
0006+  F1F3                                     ;  Initial time on power up..
0007+  F1F3 23          timestamp               .db  23h            ; Seconds
0008+  F1F4 59                                  .db  59h            ; Minutes
0009+  F1F5 08                                  .db  08h            ; Hours    (24 hr clock)
0010+  F1F6 06                                  .db  06h            ; Weekday  (1-7. Monday=1)
0011+  F1F7 05                                  .db  05h            ; Date
0012+  F1F8 11                                  .db  11h            ; Month
0013+  F1F9 22                                  .db  22h            ; Year 
0014+  F1FA FF                                  .db  0ffh           ; 0ffh end marker
0015+  F1FB             
0016+  F1FB             ; Set the initial time and start the clock
0017+  F1FB             ;
0018+  F1FB             ;
0019+  F1FB CD 53 EE    rtc_reset               CALL    uart_inline
0020+  F1FE 43 68 65 63                         .DB     "Checking RTC\n\r",0
0020+  F202 6B 69 6E 67 
0020+  F206 20 52 54 43 
0020+  F20A 0A 0D 00 
0021+  F20D             
0022+  F20D 26 6F                               LD      H, RTC_ADDRESS
0023+  F20F 2E 00                               LD      L, RTC_REG_SEC      ; Read the seconds register
0024+  F211 CD AD EE                            CALL    i2c_read_from
0025+  F214 5F                                  LD      E, A
0026+  F215 D2 EE F2                            JP      NC, rtc_ack_error
0027+  F218 CD A3 EE                            CALL    i2c_stop
0028+  F21B CD E9 F2                            CALL    _pause
0029+  F21E CB 7B                               BIT     7, E                ; Check to see if the clock is running
0030+  F220 28 07                               JR      Z, _do_reset        ; If not, reset the time
0031+  F222             
0032+  F222 CD 0B F3                            CALL    _check_ctrl         ; If it is, check that ctrl is set correctly
0033+  F225 C2 AF F2                            JP      NZ, _set_ctrl
0034+  F228 C9                                  RET
0035+  F229             
0036+  F229 CD 53 EE    _do_reset               CALL    uart_inline
0037+  F22C 52 65 73 65                         .DB     "Reset time\n\r",0
0037+  F230 74 20 74 69 
0037+  F234 6D 65 0A 0D 
0037+  F238 00 
0038+  F239             
0039+  F239 26 6F                               LD      H, RTC_ADDRESS      ; Clock isn't running, reset to default time
0040+  F23B 2E 00                               LD      L, RTC_REG_SEC
0041+  F23D CD CE EE                            CALL    i2c_write_to
0042+  F240 D2 EE F2                            JP      NC, rtc_ack_error
0043+  F243             
0044+  F243 21 F3 F1                            LD      HL, timestamp
0045+  F246 7E          _reset_loop             LD      A, (HL)
0046+  F247 23                                  INC     HL
0047+  F248 FE FF                               CP      0ffh
0048+  F24A CA 55 F2                            JP      Z, _start_clock
0049+  F24D CD E3 EE                            CALL    i2c_write
0050+  F250 D2 EE F2                            JP      NC, rtc_ack_error
0051+  F253 18 F1                               JR      _reset_loop
0052+  F255             
0053+  F255 CD A3 EE    _start_clock            CALL    i2c_stop            ; Enable VBAT and start the clock
0054+  F258             
0055+  F258 CD 53 EE                            CALL    uart_inline
0056+  F25B 53 74 61 72                         .DB     "Starting clock\n\r",0
0056+  F25F 74 69 6E 67 
0056+  F263 20 63 6C 6F 
0056+  F267 63 6B 0A 0D 
0056+  F26B 00 
0057+  F26C             
0058+  F26C 26 6F                               LD      H, RTC_ADDRESS      ; Enable VBAT
0059+  F26E 2E 03                               LD      L, RTC_REG_WKDAY
0060+  F270 CD AD EE                            CALL    i2c_read_from
0061+  F273 D2 EE F2                            JP      NC, rtc_ack_error
0062+  F276 5F                                  LD      E, A
0063+  F277 CD A3 EE                            CALL    i2c_stop
0064+  F27A CB DB                               SET     3, E
0065+  F27C CD E9 F2                            CALL    _pause
0066+  F27F             
0067+  F27F CD CE EE                            CALL    i2c_write_to
0068+  F282 D2 EE F2                            JP      NC, rtc_ack_error
0069+  F285 7B                                  LD      A, E
0070+  F286 CD E3 EE                            CALL    i2c_write
0071+  F289 D2 EE F2                            JP      NC, rtc_ack_error
0072+  F28C CD A3 EE                            CALL    i2c_stop
0073+  F28F             
0074+  F28F 26 6F                               LD      H, RTC_ADDRESS      ; Enable clock
0075+  F291 2E 00                               LD      L, RTC_REG_SEC      ; Read the seconds register
0076+  F293 CD AD EE                            CALL    i2c_read_from
0077+  F296 D2 EE F2                            JP      NC, rtc_ack_error
0078+  F299 5F                                  LD      E, A
0079+  F29A CD A3 EE                            CALL    i2c_stop
0080+  F29D CB FB                               SET     7, E                ; Set bit 7 to enable clock
0081+  F29F                                     
0082+  F29F CD CE EE                            CALL    i2c_write_to
0083+  F2A2 D2 EE F2                            JP      NC, rtc_ack_error
0084+  F2A5 7B                                  LD      A, E
0085+  F2A6 CD E3 EE                            CALL    i2c_write
0086+  F2A9 D2 EE F2                            JP      NC, rtc_ack_error
0087+  F2AC CD A3 EE                            CALL    i2c_stop
0088+  F2AF             
0089+  F2AF 06 04       _set_ctrl               LD      B, 4
0090+  F2B1 C5          _set_ctrl_loop          PUSH    BC
0091+  F2B2 26 6F                               LD      H, RTC_ADDRESS      ; Set Coarse mode and Output Pin to Square wave - gives 64 Hz pulse
0092+  F2B4 2E 07                               LD      L, RTC_REG_CTRL
0093+  F2B6 CD CE EE                            CALL    i2c_write_to
0094+  F2B9 D2 EE F2                            JP      NC, rtc_ack_error
0095+  F2BC 3E 44                               LD      A, 044h
0096+  F2BE CD E3 EE                            CALL    i2c_write
0097+  F2C1 D2 EE F2                            JP      NC, rtc_ack_error
0098+  F2C4 AF                                  XOR     A
0099+  F2C5 CD E3 EE                            CALL    i2c_write
0100+  F2C8 D2 EE F2                            JP      NC, rtc_ack_error
0101+  F2CB CD A3 EE                            CALL    i2c_stop
0102+  F2CE             
0103+  F2CE CD E9 F2                            CALL    _pause
0104+  F2D1             
0105+  F2D1 CD 0B F3                            CALL    _check_ctrl
0106+  F2D4 C1                                  POP     BC
0107+  F2D5 C8                                  RET     Z
0108+  F2D6             
0109+  F2D6 CD 53 EE                            CALL    uart_inline
0110+  F2D9 52 65 73 65                         .DB     "Reset trim\r\n",0
0110+  F2DD 74 20 74 72 
0110+  F2E1 69 6D 0D 0A 
0110+  F2E5 00 
0111+  F2E6 10 C9                               DJNZ    _set_ctrl_loop
0112+  F2E8 C9                                  RET
0113+  F2E9             
0114+  F2E9 06 00       _pause                  LD      B, 0
0115+  F2EB 10 FE                               DJNZ    $
0116+  F2ED C9                                  RET
0117+  F2EE             
0118+  F2EE CD A3 EE    rtc_ack_error           CALL    i2c_stop
0119+  F2F1                                     
0120+  F2F1 CD 53 EE                            CALL    uart_inline
0121+  F2F4 52 54 43 20                         .DB     "RTC Panic\n\r",0
0121+  F2F8 50 61 6E 69 
0121+  F2FC 63 0A 0D 00 
0122+  F300 7C                                  LD      A, H
0123+  F301 CD 34 EE                            CALL    uart_hex
0124+  F304 7D                                  LD      A, L
0125+  F305 CD 34 EE                            CALL    uart_hex
0126+  F308 C3 08 F3                            JP      $
0127+  F30B             
0128+  F30B             ; Check that the control is set to coarse trim and 0 offset
0129+  F30B             ; Returns with Zero flag set if settings are good.
0130+  F30B             ;
0131+  F30B 26 6F       _check_ctrl             LD      H, RTC_ADDRESS      
0132+  F30D 2E 07                               LD      L, RTC_REG_CTRL
0133+  F30F CD AD EE                            CALL    i2c_read_from
0134+  F312 D2 EE F2                            JP      NC, rtc_ack_error
0135+  F315 5F                                  LD      E, A
0136+  F316 CD 03 EF                            CALL    i2c_ack
0137+  F319 CD F0 EE                            CALL    i2c_read
0138+  F31C 57                                  LD      D, A
0139+  F31D CD A3 EE                            CALL    i2c_stop
0140+  F320 7B                                  LD      A, E
0141+  F321 06 04                               LD      B, 4
0142+  F323 FE 44                               CP      044h
0143+  F325 C0                                  RET     NZ
0144+  F326 7A                                  LD      A, D
0145+  F327 A7                                  AND     A
0146+  F328 C9                                  RET 
0147+  F329             
0148+  F329 52 54 43 20 ack_error               .DB "RTC Ack error 0",0
0148+  F32D 41 63 6B 20 
0148+  F331 65 72 72 6F 
0148+  F335 72 20 30 00 
0149+  F339             
0150+  F339             ;
0151+  F339             ;
0152+  F339             ; 00 - Second
0153+  F339             ; 01 - Minute
0154+  F339             ; 02 - Hour
0155+  F339             ; 03 - Wkday
0156+  F339             ; 04 - Date
0157+  F339             ; 05 - Month
0158+  F339             ; 06 - Year
0159+  F339             ;
0160+  F339             _offset_sec             .EQU    0
0161+  F339             _offset_min             .EQU    1
0162+  F339             _offset_hour            .EQU    2
0163+  F339             _offset_wkday           .EQU    3
0164+  F339             _offset_date            .EQU    4
0165+  F339             _offset_month           .EQU    5
0166+  F339             _offset_year            .EQU    6
0167+  F339             
0168+  F339             ;
0169+  F339             ; Read the time into the temp_data area
0170+  F339             ; Returns with Carry SET if successful, else Carry CLEAR
0171+  F339             ;
0172+  F339 26 6F       rtc_get_time2           LD      H, RTC_ADDRESS
0173+  F33B 2E 00                               LD      L, RTC_REG_SEC
0174+  F33D CD AD EE                            CALL    i2c_read_from
0175+  F340 30 3E                               JR      NC, _get_error
0176+  F342 21 42 FF                            LD      HL, temp_data
0177+  F345 06 07                               LD      B, 7
0178+  F347 18 0D                               JR      _store_time2
0179+  F349 C5          _get_loop2              PUSH    BC
0180+  F34A CD 96 EE                            CALL    i2c_start
0181+  F34D 3E 6F                               LD      A, RTC_ADDRESS  
0182+  F34F CD DB EE                            CALL    i2c_address_r   
0183+  F352 CD F0 EE                            CALL    i2c_read
0184+  F355 C1                                  POP     BC
0185+  F356 77          _store_time2            LD      (HL), A
0186+  F357 CD A3 EE                            CALL    i2c_stop
0187+  F35A 23                                  INC     HL
0188+  F35B 10 EC                               DJNZ    _get_loop2
0189+  F35D 37                                  SCF
0190+  F35E C9                                  RET
0191+  F35F             
0192+  F35F 26 6F       rtc_get_time            LD      H, RTC_ADDRESS
0193+  F361 2E 00                               LD      L, RTC_REG_SEC
0194+  F363 CD AD EE                            CALL    i2c_read_from
0195+  F366 30 18                               JR      NC, _get_error
0196+  F368 21 42 FF                            LD      HL, temp_data
0197+  F36B 06 07                               LD      B, 7
0198+  F36D 18 08                               JR      _store_time
0199+  F36F C5          _get_loop               PUSH    BC 
0200+  F370 CD 03 EF                            CALL    i2c_ack
0201+  F373 CD F0 EE                            CALL    i2c_read
0202+  F376 C1                                  POP     BC
0203+  F377 77          _store_time             LD      (HL), A
0204+  F378 23                                  INC     HL
0205+  F379 10 F4                               DJNZ    _get_loop
0206+  F37B CD A3 EE                            CALL    i2c_stop
0207+  F37E 37                                  SCF
0208+  F37F C9                                  RET
0209+  F380             
0210+  F380 CD A3 EE    _get_error              CALL    i2c_stop
0211+  F383 CD 53 EE                            CALL    uart_inline 
0212+  F386 45 72 72 6F                         .DB     "Error getting time\r\n", 0
0212+  F38A 72 20 67 65 
0212+  F38E 74 74 69 6E 
0212+  F392 67 20 74 69 
0212+  F396 6D 65 0D 0A 
0212+  F39A 00 
0213+  F39B AF                                  XOR     A
0214+  F39C C9                                  RET
0215+  F39D             
0216+  F39D CD 5F F3    rtc_display_time        CALL    rtc_get_time
0217+  F3A0 11 28 FF                            LD      DE, scratch_pad
0218+  F3A3 3A 45 FF                            LD      A, (temp_data+_offset_wkday)
0219+  F3A6 21 38 F4                            LD      HL, _weekdays
0220+  F3A9 E6 07                               AND     7
0221+  F3AB 4F                                  LD      C, A
0222+  F3AC             
0223+  F3AC CD 27 F4                            CALL    _search_word
0224+  F3AF CD 30 F4                            CALL    _copy_word
0225+  F3B2                                     
0226+  F3B2 CD 0D F4    _get_date               CALL    _space
0227+  F3B5 3A 46 FF                            LD      A, (temp_data+_offset_date)
0228+  F3B8 E6 3F                               AND     03Fh
0229+  F3BA CD 12 F4                            CALL    _two_chars
0230+  F3BD CD 0D F4                            CALL    _space
0231+  F3C0             
0232+  F3C0 3A 47 FF                            LD      A, (temp_data+_offset_month)
0233+  F3C3 21 54 F4                            LD      HL, _months
0234+  F3C6 E6 1F                               AND     01fh
0235+  F3C8 CB 67                               BIT     4, A
0236+  F3CA 28 02                               JR      Z, _month_ok
0237+  F3CC D6 06                               SUB     6
0238+  F3CE 4F          _month_ok               LD      C,A
0239+  F3CF             
0240+  F3CF CD 27 F4                            CALL    _search_word
0241+  F3D2 CD 30 F4                            CALL    _copy_word
0242+  F3D5 CD 0D F4                            CALL    _space
0243+  F3D8 3E 20                               LD      A, 20h
0244+  F3DA CD 12 F4                            CALL    _two_chars
0245+  F3DD             
0246+  F3DD 3A 48 FF                            LD      A, (temp_data+_offset_year)
0247+  F3E0 CD 12 F4                            CALL    _two_chars
0248+  F3E3 CD 0D F4                            CALL    _space
0249+  F3E6             
0250+  F3E6 3A 44 FF                            LD      A, (temp_data+_offset_hour)
0251+  F3E9 E6 3F                               AND     03fh
0252+  F3EB CD 12 F4                            CALL    _two_chars
0253+  F3EE CD 0D F4                            CALL    _space
0254+  F3F1             
0255+  F3F1 3A 43 FF                            LD      A, (temp_data+_offset_min)
0256+  F3F4 E6 7F                               AND     07fh
0257+  F3F6 CD 12 F4                            CALL    _two_chars
0258+  F3F9 CD 0D F4                            CALL    _space
0259+  F3FC             
0260+  F3FC 3A 42 FF                            LD      A, (temp_data+_offset_sec)
0261+  F3FF E6 7F                               AND     07fh
0262+  F401 CD 12 F4                            CALL    _two_chars
0263+  F404 AF                                  XOR     A
0264+  F405 12                                  LD      (DE),A
0265+  F406             
0266+  F406 21 28 FF                            LD      HL, scratch_pad
0267+  F409 CD FB F0                            CALL    disp_string
0268+  F40C C9                                  RET
0269+  F40D             
0270+  F40D 3E 20       _space                  LD      A, ' '
0271+  F40F 12                                  LD      (DE), A
0272+  F410 13                                  INC     DE
0273+  F411 C9                                  RET
0274+  F412             
0275+  F412 4F          _two_chars              LD      C,A
0276+  F413 CB 3F                               SRL     A
0277+  F415 CB 3F                               SRL     A
0278+  F417 CB 3F                               SRL     A
0279+  F419 CB 3F                               SRL     A
0280+  F41B C6 30                               ADD     A, '0'
0281+  F41D 12                                  LD      (DE), A
0282+  F41E 13                                  INC     DE
0283+  F41F 79                                  LD      A,C
0284+  F420 E6 0F                               AND     0fh
0285+  F422 C6 30                               ADD     A, '0'
0286+  F424 12                                  LD      (DE), A
0287+  F425 13                                  INC     DE
0288+  F426 C9                                  RET
0289+  F427             ;
0290+  F427             ; Search table pointed to by HL for the C'th word (1-based)
0291+  F427             ; Returns with HL pointing to the word indexed by C, where the first word has index 1
0292+  F427             ;
0293+  F427 0D          _search_word            DEC     C
0294+  F428 C8                                  RET     Z
0295+  F429 7E          _next_char              LD      A, (HL)
0296+  F42A 23                                  INC     HL
0297+  F42B A7                                  AND     A
0298+  F42C 20 FB                               JR      NZ, _next_char
0299+  F42E 18 F7                               JR      _search_word
0300+  F430             
0301+  F430             ;
0302+  F430             ; Copy from (DE) to (HL) until we encounter a 0
0303+  F430             ; Return with DE pointing to the next location, and HL pointing to the zero byte
0304+  F430             ;
0305+  F430 7E          _copy_word              LD      A, (HL)              ; HL -> Day of week string..
0306+  F431 A7                                  AND     A
0307+  F432 C8                                  RET     Z             
0308+  F433 12                                  LD      (DE), A
0309+  F434 23                                  INC     HL
0310+  F435 13                                  INC     DE
0311+  F436 18 F8                               JR      _copy_word
0312+  F438             
0313+  F438 4D 6F 6E 00 _weekdays               .DB "Mon",0
0314+  F43C 54 75 65 00                         .DB "Tue",0
0315+  F440 57 65 64 00                         .DB "Wed",0
0316+  F444 54 68 75 00                         .DB "Thu",0
0317+  F448 46 72 69 00                         .DB "Fri",0
0318+  F44C 53 61 74 00                         .DB "Sat",0
0319+  F450 53 75 6E 00                         .DB "Sun",0
0320+  F454             
0321+  F454 4A 61 6E 00 _months                 .DB "Jan",0
0322+  F458 46 65 62 00                         .DB "Feb",0
0323+  F45C 4D 61 72 00                         .DB "Mar",0
0324+  F460 41 70 72 00                         .DB "Apr",0
0325+  F464 4D 61 79 00                         .DB "May",0
0326+  F468 4A 75 6E 00                         .DB "Jun",0
0327+  F46C 4A 75 6C 00                         .DB "Jul",0
0328+  F470 41 75 67 00                         .DB "Aug",0
0329+  F474 53 65 70 00                         .DB "Sep",0
0330+  F478 4F 63 74 00                         .DB "Oct",0
0331+  F47C 4E 6F 76 00                         .DB "Nov",0
0332+  F480 44 65 63 00                         .DB "Dec",0
0333+  F484             
0334+  F484                                     .MODULE main0793   F484                                 .INCLUDE ymodem.asm
0001+  F484             ;
0002+  F484             ; YModem implementation.
0003+  F484             ; File format: The filename MAY indicate the load address in memory for the file. If so, the format is:
0004+  F484             ;       filename_yHHHH.suffix
0005+  F484             ;
0006+  F484             ; Where:  _yHHHH indicates a preferred destination address of HHHH - four digits hexadecimal value (uppercase).
0007+  F484             ;
0008+  F484             
0009+  F484                                 .MODULE ymodem
0010+  F484             
0011+  F484             _FLASH_PREFIX       .EQU    'f'
0012+  F484             _DEST_PREFIX        .EQU    'y'
0013+  F484             
0014+  F484             ; Return values
0015+  F484             YMODEM_SUCCESS      .EQU    000h
0016+  F484             YMODEM_TIMEOUT      .EQU    001h
0017+  F484             YMODEM_UNKNOWN      .EQU    002h            ; Unknown packet type (Packet byte in C)
0018+  F484             YMODEM_CANCEL       .EQU    003h            ; Cancelled by sender
0019+  F484             YMODEM_PACKET_ERROR .EQU    004h            ; Packet data error (Error code in C)
0020+  F484             YMODEM_LENGTH_ERROR .EQU    005h            ; Length data in zeroth packet is invalid
0021+  F484             YMODEM_NO_DEST      .EQU    006h            ; No destination provided
0022+  F484             YMODEM_SEND_TIMEOUT .EQU    007h
0023+  F484             YMODEM_MULTI_FILES  .EQU    008h            ; Cannot receive more than one file 
0024+  F484             
0025+  F484             _SOH                .EQU    001h            ; 128 byte data packet header
0026+  F484             _STX                .EQU    002h            ; 1024 byte data packet header
0027+  F484             _EOT                .EQU    004h            ; End transfer
0028+  F484             _ACK                .EQU    006h            ; Respond
0029+  F484             _NAK                .EQU    015h            ; No response
0030+  F484             _CAN                .EQU    018h            ; Transmission aborted
0031+  F484             _C                  .EQU    043h            ; Request packet
0032+  F484             
0033+  F484             _SOH_PACKET_SIZE    .EQU    128
0034+  F484             _STX_PACKET_SIZE    .EQU    1024
0035+  F484             _FRAME_OVERHEAD     .EQU    5               ; Three byte header + two byte CRC (high byte first)
0036+  F484             
0037+  F484             _TIMEOUT_COUNT      .EQU    50000
0038+  F484             
0039+  F484             
0040+  F484             _ERR_PACKET_COUNT   .EQU    1               ; Wrong packet index
0041+  F484             _ERR_CHECK_HIGH     .EQU    2               ; High byte of CRC failed
0042+  F484             _ERR_CHECK_LOW      .EQU    3               ; Low byte of CRC failed
0043+  F484             _ERR_CANCEL         .EQU    4               ; Got a cancel request without second cancel
0044+  F484             _ERR_ZERO_PACKET    .EQU    5               ; Zeroth packet must be SOH
0045+  F484             
0046+  F484             _dest_set_by_file   .EQU    0FEh            ; File destination set from filename
0047+  F484             
0048+  F484             ymodem_data_length  .EQU    12              ; Size of data block before buffer
0049+  F484             file_mode           .EQU    -12             ; FFh : Normal transfer,  FEh : Destination set by file, 0-7Fh : Flash write 
0050+  F484             file_count          .EQU    -11
0051+  F484             length_low          .EQU    -10
0052+  F484             length_high         .EQU    -9
0053+  F484             dest_low            .EQU    -8
0054+  F484             dest_high           .EQU    -7
0055+  F484             current_packet      .EQU    -6
0056+  F484             packet_type         .EQU    -5
0057+  F484             recieved_packet     .EQU    -4
0058+  F484             recieved_packet_cpl .EQU    -3
0059+  F484             crc_low             .EQU    -2
0060+  F484             crc_high            .EQU    -1
0061+  F484             
0062+  F484             YMODEM_BUFFER       .EQU    _SOH_PACKET_SIZE + ymodem_data_length
0063+  F484             
0064+  F484             ;
0065+  F484             ; ymodem - Main entry point. Call with:
0066+  F484             ;     HL = Address of YMODEM_BUFFER (=128 + ymodem_data_length) byte buffer for receiving data
0067+  F484             ;     DE = (Optional) address to write data. 0xFFFF to accept destination from filename otherwise
0068+  F484             ;
0069+  F484             ; Returns status code in A:
0070+  F484             ;     YMODEM_SUCCESS : (=0) If the file was successfully received
0071+  F484             ;     YMODEM_xxxx    : (Non zero) If the receiver timed out waiting for a byte
0072+  F484             ;
0073+  F484             
0074+  F484 01 0C 00    ymodem              LD      BC, ymodem_data_length      ; Skip data block at start of buffer
0075+  F487 09                              ADD     HL, BC
0076+  F488 E5                              PUSH    HL
0077+  F489 DD E1                           POP     IX
0078+  F48B AF                              XOR     A                           
0079+  F48C DD 77 F5                        LD      (IX+file_count), A
0080+  F48F 3D                              DEC     A
0081+  F490 DD 77 F4                        LD      (IX+file_mode), A
0082+  F493 DD 73 F8                        LD      (IX+dest_low), E
0083+  F496 DD 72 F9                        LD      (IX+dest_high), D
0084+  F499             
0085+  F499 AF          _ymodem_start       XOR     A                           ; Set initial packet number
0086+  F49A DD 77 FA                        LD      (IX+current_packet), A
0087+  F49D FD 21 FF FF                     LD      IY, 0FFFFh                  ; IY - bytes to load. Default - load all bytes
0088+  F4A1             
0089+  F4A1 CD AF F6    _packet_loop        CALL    _recieve_safe
0090+  F4A4 20 07                           JR      NZ, _packet_byte
0091+  F4A6 3E 43       _send_crc_and_loop  LD      A, _C
0092+  F4A8 CD DA F6                        CALL    _send_byte
0093+  F4AB 18 F4                           JR      _packet_loop
0094+  F4AD             
0095+  F4AD FE 01       _packet_byte        CP      _SOH
0096+  F4AF C2 BA F4                        JP      NZ, _check_stx
0097+  F4B2             
0098+  F4B2             ; SOH - May be zero'th or last packet
0099+  F4B2 DD E5                           PUSH    IX
0100+  F4B4 E1                              POP     HL
0101+  F4B5 01 80 00                        LD      BC, _SOH_PACKET_SIZE
0102+  F4B8 18 40                           JR      _receive_packet
0103+  F4BA             
0104+  F4BA FE 02       _check_stx          CP      _STX
0105+  F4BC 20 07                           JR      NZ, _check_eot
0106+  F4BE                                                                     ; STX packets go straight to DE
0107+  F4BE 62                              LD      H, D
0108+  F4BF 6B                              LD      L, E
0109+  F4C0 01 00 04                        LD      BC, _STX_PACKET_SIZE    
0110+  F4C3 18 35                           JR      _receive_packet
0111+  F4C5             
0112+  F4C5 FE 04       _check_eot          CP      _EOT
0113+  F4C7 20 0A                           JR      NZ, _check_can
0114+  F4C9                                                                     ; End of transmission
0115+  F4C9 3E 06                           LD      A, _ACK 
0116+  F4CB CD DA F6                        CALL    _send_byte
0117+  F4CE             
0118+  F4CE DD 34 F5                        INC     (IX+file_count)      
0119+  F4D1 18 C6                           JR      _ymodem_start  
0120+  F4D3             
0121+  F4D3 FE 18       _check_can          CP      _CAN
0122+  F4D5 20 1E                           JR      NZ, _unknown_packet
0123+  F4D7                                                                     ; Single cancel request. Check for another
0124+  F4D7 CD BA F6                        CALL    _receive_byte
0125+  F4DA FE 18                           CP      _CAN
0126+  F4DC 3E 04                           LD      A, _ERR_CANCEL
0127+  F4DE 20 10                           JR      NZ, _packet_error
0128+  F4E0             
0129+  F4E0 3E 06                           LD      A, _ACK 
0130+  F4E2 CD DA F6                        CALL    _send_byte
0131+  F4E5 CD AF F6    _purge              CALL    _recieve_safe               ; Purge remains of any cancel request
0132+  F4E8 20 FB                           JR      NZ, _purge
0133+  F4EA             
0134+  F4EA 3E 03                           LD      A, YMODEM_CANCEL
0135+  F4EC A7                              AND     A
0136+  F4ED C9                              RET
0137+  F4EE             
0138+  F4EE 3E 05       _zero_error         LD      A, _ERR_ZERO_PACKET
0139+  F4F0 4F          _packet_error       LD      C, A                        ; Packet data error - return error code in C
0140+  F4F1 3E 04                           LD      A, YMODEM_PACKET_ERROR
0141+  F4F3 A7                              AND     A
0142+  F4F4 C9                              RET
0143+  F4F5             
0144+  F4F5 4F          _unknown_packet     LD      C, A                        ; Unknown packet type - return header byte in C
0145+  F4F6 3E 02                           LD      A, YMODEM_UNKNOWN
0146+  F4F8 A7                              AND     A
0147+  F4F9 C9                              RET     
0148+  F4FA             
0149+  F4FA             ; Receive data for both SOH and STX packets..
0150+  F4FA             ; At this point HL is destination, and BC is a byte count
0151+  F4FA DD 77 FB    _receive_packet     LD      (IX+packet_type), A         
0152+  F4FD AF                              XOR     A
0153+  F4FE DD BE FA                        CP      (IX+current_packet)         ; If this is the zeroth packet, it must be SOH
0154+  F501 20 07                           JR      NZ, _not_zeroth_packet
0155+  F503 3E 01                           LD      A, _SOH
0156+  F505 DD 96 FB                        SUB     (IX+packet_type)            ; Leave A as zero if this is OK
0157+  F508 20 E4                           JR      NZ, _zero_error
0158+  F50A             
0159+  F50A DD 77 FF    _not_zeroth_packet  LD      (IX+crc_high), A
0160+  F50D DD 77 FE                        LD      (IX+crc_low), A
0161+  F510             
0162+  F510 CD BA F6                        CALL    _receive_byte   
0163+  F513 DD 77 FC                        LD      (IX+recieved_packet), A
0164+  F516 CD BA F6                        CALL    _receive_byte   
0165+  F519 DD 77 FD                        LD      (IX+recieved_packet_cpl), A
0166+  F51C             
0167+  F51C CD BA F6    _data_loop          CALL    _receive_byte
0168+  F51F 77                              LD      (HL), A
0169+  F520             
0170+  F520 CD 7D F6                        CALL    _calc_checksum  
0171+  F523             
0172+  F523 C5                              PUSH    BC                          ; Count down the bytes remaining, and stop increasing HL once we reach 0
0173+  F524 01 FF FF                        LD      BC, -1
0174+  F527 FD 09                           ADD     IY, BC                      ; Carry set if IY not zero
0175+  F529 C1                              POP     BC
0176+  F52A 38 03                           JR      C, _in_range
0177+  F52C FD 23                           INC     IY
0178+  F52E 2B                              DEC     HL
0179+  F52F             
0180+  F52F 23          _in_range           INC     HL
0181+  F530 0B                              DEC     BC
0182+  F531             
0183+  F531 78                              LD      A, B
0184+  F532 B1                              OR      C
0185+  F533 20 E7                           JR      NZ, _data_loop
0186+  F535             
0187+  F535 AF                              XOR     A
0188+  F536 CD 7D F6                        CALL    _calc_checksum  
0189+  F539 AF                              XOR     A
0190+  F53A CD 7D F6                        CALL    _calc_checksum  
0191+  F53D             
0192+  F53D CD BA F6                        CALL    _receive_byte
0193+  F540 47                              LD      B, A
0194+  F541 CD BA F6                        CALL    _receive_byte   
0195+  F544 4F                              LD      C, A
0196+  F545             ;
0197+  F545             ; Now do checks...
0198+  F545             
0199+  F545 DD 7E FC                        LD      A, (IX+recieved_packet)
0200+  F548 2F                              CPL
0201+  F549 DD BE FD                        CP      (IX+recieved_packet_cpl)
0202+  F54C 3E 01                           LD      A, _ERR_PACKET_COUNT
0203+  F54E 20 A0                           JR      NZ, _packet_error
0204+  F550 DD 7E FF                        LD      A, (IX+crc_high)
0205+  F553 B8                              CP      B
0206+  F554 3E 02                           LD      A, _ERR_CHECK_HIGH
0207+  F556 20 98                           JR      NZ, _packet_error
0208+  F558 DD 7E FE                        LD      A, (IX+crc_low)
0209+  F55B B9                              CP      C
0210+  F55C 3E 03                           LD      A, _ERR_CHECK_LOW
0211+  F55E 20 90                           JR      NZ, _packet_error
0212+  F560             
0213+  F560             ; CRC and packet number check out... 
0214+  F560 DD 7E FC                        LD      A, (IX+recieved_packet)
0215+  F563 DD BE FA                        CP      (IX+current_packet)
0216+  F566 20 3F                           JR      NZ, _send_nak
0217+  F568 DD 34 FA                        INC     (IX+current_packet)
0218+  F56B A7                              AND     A
0219+  F56C 28 42                           JR      Z, _header_packet
0220+  F56E             
0221+  F56E DD 7E FB                        LD      A, (IX+packet_type)
0222+  F571 FE 01                           CP      _SOH
0223+  F573 20 28                           JR      NZ, _not_soh
0224+  F575             
0225+  F575             ; SOH packets must be copied to DE -> 
0226+  F575 FD E5                           PUSH    IY                      ; Calculate how many bytes left..
0227+  F577 C1                              POP     BC
0228+  F578 21 80 00                        LD      HL, _SOH_PACKET_SIZE
0229+  F57B A7                              AND     A
0230+  F57C ED 42                           SBC     HL, BC
0231+  F57E                                 
0232+  F57E FD E5                           PUSH    IY
0233+  F580 C1                              POP     BC
0234+  F581 FD 21 00 00                     LD      IY, 0                   ; Set IY to zero in case there is:
0235+  F585             
0236+  F585 30 0F                           JR      NC, _copy_soh           ; Less than a full packet remaining..
0237+  F587             
0238+  F587 FD E5                           PUSH    IY                      ; Otherwise, calculate remaining bytes..
0239+  F589 E1                              POP     HL
0240+  F58A 01 80 00                        LD      BC, _SOH_PACKET_SIZE
0241+  F58D A7                              AND     A
0242+  F58E ED 42                           SBC     HL, BC
0243+  F590 E5                              PUSH    HL
0244+  F591 FD E1                           POP     IY
0245+  F593 01 80 00                        LD      BC, _SOH_PACKET_SIZE    ;..given we're transferring the whole packet..
0246+  F596             
0247+  F596 DD E5       _copy_soh           PUSH    IX
0248+  F598 E1                              POP     HL     
0249+  F599 ED B0                           LDIR
0250+  F59B 62                              LD      H, D
0251+  F59C 6B                              LD      L, E
0252+  F59D             
0253+  F59D 54          _not_soh            LD      D, H
0254+  F59E 5D                              LD      E, L
0255+  F59F 3E 06       _send_ack           LD      A, _ACK 
0256+  F5A1 CD DA F6    _send_and_loop      CALL    _send_byte
0257+  F5A4 C3 A6 F4                        JP      _send_crc_and_loop      
0258+  F5A7             
0259+  F5A7 CD AF F6    _send_nak           CALL   _recieve_safe                ; Drain the incoming stream before sending nak
0260+  F5AA 20 FB                           JR      NZ, _send_nak
0261+  F5AC             
0262+  F5AC 3E 15                           LD      A, _NAK
0263+  F5AE 18 F1                           JR      _send_and_loop
0264+  F5B0             
0265+  F5B0             
0266+  F5B0 DD E5       _header_packet      PUSH    IX
0267+  F5B2 E1                              POP     HL
0268+  F5B3 7E                              LD      A, (HL)                     ; Empty zeroth packet means end of batch send
0269+  F5B4 A7                              AND     A
0270+  F5B5 20 09                           JR      NZ, _check_filecount
0271+  F5B7             
0272+  F5B7 3E 06                           LD      A, _ACK 
0273+  F5B9 CD DA F6                        CALL    _send_byte
0274+  F5BC 3E 00                           LD      A, YMODEM_SUCCESS   
0275+  F5BE A7                              AND     A
0276+  F5BF C9                              RET
0277+  F5C0             
0278+  F5C0 DD 7E F5    _check_filecount    LD      A, (IX+file_count)
0279+  F5C3 A7                              AND     A
0280+  F5C4 28 04                           JR      Z, _next_filechar
0281+  F5C6             
0282+  F5C6 3E 08                           LD      A, YMODEM_MULTI_FILES
0283+  F5C8 A7                              AND     A
0284+  F5C9 C9                              RET
0285+  F5CA             
0286+  F5CA 7E          _next_filechar      LD      A, (HL)
0287+  F5CB 23                              INC     HL
0288+  F5CC A7          _check_char         AND     A
0289+  F5CD 28 65                           JR      Z, _read_length
0290+  F5CF FE 5F                           CP      '_'                     ; Check for special transfer modes
0291+  F5D1 20 F7                           JR      NZ, _next_filechar
0292+  F5D3 7E                              LD      A, (HL)
0293+  F5D4 4F                              LD      C, A                    ; Remember the prefix char in C
0294+  F5D5 23                              INC     HL
0295+  F5D6 FE 79                           CP      _DEST_PREFIX
0296+  F5D8 20 07                           JR      NZ, _check_flash
0297+  F5DA 06 04                           LD      B, 4
0298+  F5DC 11 00 00                        LD      DE, 0
0299+  F5DF 18 09                           JR      _parse_dest
0300+  F5E1             
0301+  F5E1 FE 66       _check_flash        CP      _FLASH_PREFIX
0302+  F5E3 20 E7                           JR      NZ, _check_char
0303+  F5E5 06 02                           LD      B, 2
0304+  F5E7 11 00 00                        LD      DE, 0
0305+  F5EA             
0306+  F5EA 7E          _parse_dest         LD      A, (HL)
0307+  F5EB 23                              INC     HL
0308+  F5EC D6 30                           SUB     '0'
0309+  F5EE 38 3C                           JR      C, _invalid_dest
0310+  F5F0 FE 0A                           CP      10
0311+  F5F2 38 08                           JR      C, _digit_checked
0312+  F5F4 D6 07                           SUB     7
0313+  F5F6 38 34                           JR      C, _invalid_dest
0314+  F5F8 FE 10                           CP      16
0315+  F5FA 30 30                           JR      NC, _invalid_dest
0316+  F5FC             
0317+  F5FC E5          _digit_checked      PUSH    HL
0318+  F5FD 62                              LD      H, D
0319+  F5FE 6B                              LD      L, E
0320+  F5FF 29                              ADD     HL, HL
0321+  F600 29                              ADD     HL, HL
0322+  F601 29                              ADD     HL, HL
0323+  F602 29                              ADD     HL, HL
0324+  F603 B5                              OR      L
0325+  F604 54                              LD      D, H
0326+  F605 5F                              LD      E, A
0327+  F606 E1                              POP     HL
0328+  F607 10 E1                           DJNZ    _parse_dest
0329+  F609             
0330+  F609 3E FF                           LD      A, 0FFh                     ; Only set the dest from the filename if 
0331+  F60B DD BE F8                        CP      (IX+dest_low)               ; the routine was called with a destination of 0FFFFh
0332+  F60E 20 BA                           JR      NZ, _next_filechar
0333+  F610 DD BE F9                        CP      (IX+dest_high)
0334+  F613 20 B5                           JR      NZ, _next_filechar
0335+  F615                                 
0336+  F615 DD 36 F4 FE                     LD      (IX+file_mode), _dest_set_by_file
0337+  F619 79                              LD      A, C                        ; Which char did we start with?
0338+  F61A FE 66                           CP      _FLASH_PREFIX
0339+  F61C 20 06                           JR      NZ, _set_dest
0340+  F61E             
0341+  F61E DD 73 F4                        LD      (IX+file_mode), E
0342+  F621 11 00 40                        LD      DE,04000h
0343+  F624             
0344+  F624 DD 73 F8    _set_dest           LD      (IX+dest_low), E
0345+  F627 DD 72 F9                        LD      (IX+dest_high), D
0346+  F62A             
0347+  F62A 18 9E                           JR      _next_filechar
0348+  F62C             
0349+  F62C DD 5E F8    _invalid_dest       LD      E, (IX+dest_low)            ; We silently skip invalid destination values
0350+  F62F DD 56 F9                        LD      D, (IX+dest_high)
0351+  F632 18 96                           JR      _next_filechar
0352+  F634             
0353+  F634 3E FF       _read_length        LD      A, 0FFh                     ; At this point we should have a valid destination
0354+  F636 DD BE F8                        CP      (IX+dest_low)               
0355+  F639 20 09                           JR      NZ, _dest_ok
0356+  F63B DD BE F9                        CP      (IX+dest_high)
0357+  F63E 20 04                           JR      NZ, _dest_ok
0358+  F640             
0359+  F640 3E 06                           LD      A, YMODEM_NO_DEST
0360+  F642 A7                              AND     A
0361+  F643 C9                              RET
0362+  F644             
0363+  F644 44          _dest_ok            LD      B, H
0364+  F645 4D                              LD      C, L               
0365+  F646 21 00 00                        LD      HL, 0
0366+  F649 0A                              LD      A, (BC)                     ; Length is optional
0367+  F64A A7                              AND     A
0368+  F64B CA 9F F5                        JP      Z, _send_ack
0369+  F64E             
0370+  F64E 0A          _parse_length       LD      A, (BC)
0371+  F64F 03                              INC     BC
0372+  F650 A7                              AND     A
0373+  F651 28 1A                           JR      Z, _length_end
0374+  F653 FE 20                           CP      ' '
0375+  F655 28 16                           JR      Z, _length_end
0376+  F657 D6 30                           SUB     '0'
0377+  F659 38 1E                           JR      C, _invalid_length
0378+  F65B FE 0A                           CP      10
0379+  F65D 30 1A                           JR      NC, _invalid_length
0380+  F65F D5                              PUSH    DE
0381+  F660 54                              LD      D, H
0382+  F661 5D                              LD      E, L
0383+  F662 29                              ADD     HL, HL
0384+  F663 29                              ADD     HL, HL
0385+  F664 19                              ADD     HL, DE
0386+  F665 29                              ADD     HL, HL
0387+  F666 5F                              LD      E, A
0388+  F667 16 00                           LD      D, 0
0389+  F669 19                              ADD     HL, DE
0390+  F66A D1                              POP     DE
0391+  F66B 18 E1                           JR      _parse_length
0392+  F66D E5          _length_end         PUSH    HL
0393+  F66E FD E1                           POP     IY
0394+  F670 DD 75 F6                        LD      (IX+length_low), L
0395+  F673 DD 74 F7                        LD      (IX+length_high), H
0396+  F676 C3 9F F5                        JP      _send_ack
0397+  F679             
0398+  F679 3E 05       _invalid_length     LD      A, YMODEM_LENGTH_ERROR      ; Hard fail on invalid length data
0399+  F67B A7                              AND     A
0400+  F67C C9                              RET
0401+  F67D             
0402+  F67D             ;-----
0403+  F67D             ; Calculate the checksum from A
0404+  F67D E5          _calc_checksum      PUSH    HL
0405+  F67E C5                              PUSH    BC
0406+  F67F             
0407+  F67F 06 01                           LD      B, 1
0408+  F681 4F                              LD      C, A
0409+  F682 DD 66 FF                        LD      H, (IX+crc_high)
0410+  F685 DD 6E FE                        LD      L, (IX+crc_low)
0411+  F688             
0412+  F688 29          _crc_loop           ADD     HL, HL
0413+  F689 F5                              PUSH    AF
0414+  F68A             
0415+  F68A CB 21                           SLA     C
0416+  F68C CB 10                           RL      B
0417+  F68E 30 02                           JR      NC, _no_in_overflow
0418+  F690 CB C1                           SET     0, C
0419+  F692             _no_in_overflow
0420+  F692 CB 40                           BIT     0, B
0421+  F694 28 01                           JR      Z, _no_in_bit
0422+  F696 23                              INC     HL
0423+  F697             _no_in_bit                    
0424+  F697 F1                              POP     AF
0425+  F698 30 08                           JR      NC, _no_crc_overflow
0426+  F69A 3E 21                           LD      A, 021h
0427+  F69C AD                              XOR     L 
0428+  F69D 6F                              LD      L,A
0429+  F69E 3E 10                           LD      A, 010h
0430+  F6A0 AC                              XOR     H 
0431+  F6A1 67                              LD      H, A
0432+  F6A2             _no_crc_overflow
0433+  F6A2 CB 41                           BIT     0, C
0434+  F6A4 28 E2                           JR      Z, _crc_loop    
0435+  F6A6             
0436+  F6A6 DD 74 FF                        LD      (IX+crc_high), H
0437+  F6A9 DD 75 FE                        LD      (IX+crc_low), L
0438+  F6AC C1                              POP     BC
0439+  F6AD E1                              POP     HL
0440+  F6AE C9                              RET
0441+  F6AF             
0442+  F6AF             ;
0443+  F6AF             ; Recieve a byte with timeout, without exiting ymodem
0444+  F6AF             ; If success, A contains byte, non-zero flag set
0445+  F6AF             ; Otherwise A is zero, Zero flag is set
0446+  F6AF             ;
0447+  F6AF 21 B8 F6    _recieve_safe       LD      HL, _back_safe
0448+  F6B2 E5                              PUSH    HL
0449+  F6B3 CD BA F6                        CALL    _receive_byte
0450+  F6B6 E1                              POP     HL
0451+  F6B7 C9                              RET
0452+  F6B8 AF          _back_safe          XOR     A
0453+  F6B9 C9                              RET     
0454+  F6BA             
0455+  F6BA             ;
0456+  F6BA             ; Receive a byte with timeout
0457+  F6BA             ; If success: A contains byte, non-zero flag set
0458+  F6BA             ; Otherwise : Pops the return address off the stack and returns to the original caller with A containing YMODEM_TIMEOUT
0459+  F6BA             ;
0460+  F6BA C5          _receive_byte       PUSH    BC
0461+  F6BB 01 50 C3                        LD      BC, _TIMEOUT_COUNT
0462+  F6BE DB 25       _receive_loop       IN      A, (UART_LINE_STATUS)
0463+  F6C0 CB 47                           BIT     0, A
0464+  F6C2 20 12                           JR      NZ, _receive_ready
0465+  F6C4 78                              LD      A, B
0466+  F6C5 06 0A                           LD      B, 10
0467+  F6C7 A7          _rx_delay           AND     A
0468+  F6C8 10 FD                           DJNZ    _rx_delay
0469+  F6CA 47                              LD      B, A
0470+  F6CB 0B                              DEC     BC
0471+  F6CC 78                              LD      A, B
0472+  F6CD B1                              OR      C
0473+  F6CE 20 EE                           JR      NZ, _receive_loop
0474+  F6D0 C1                              POP     BC
0475+  F6D1 C1                              POP     BC
0476+  F6D2 3E 01                           LD      A, YMODEM_TIMEOUT
0477+  F6D4 A7                              AND     A
0478+  F6D5 C9                              RET
0479+  F6D6             
0480+  F6D6 DB 20       _receive_ready      IN      A, (UART_TX_RX)
0481+  F6D8 C1                              POP     BC
0482+  F6D9 C9                              RET
0483+  F6DA             
0484+  F6DA             ;
0485+  F6DA             ; Sned a byte with timeout
0486+  F6DA             ; If success: returns normally, no registers affected
0487+  F6DA             ; Otherwise : Pops the return address off the stack and returns to the original caller with A containing YMODEM_SEND_TIMEOUT
0488+  F6DA             ;
0489+  F6DA C5          _send_byte          PUSH    BC
0490+  F6DB F5                              PUSH    AF
0491+  F6DC 01 50 C3                        LD      BC, _TIMEOUT_COUNT
0492+  F6DF DB 25       _send_loop          IN      A, (UART_LINE_STATUS)
0493+  F6E1 CB 6F                           BIT     5, A
0494+  F6E3 C2 F3 F6                        JP      NZ, _send_ready             ; Bit 5 is set when the UART is ready
0495+  F6E6 0B                              DEC     BC
0496+  F6E7 78                              LD      A, B
0497+  F6E8 B1                              OR      C
0498+  F6E9 C2 DF F6                        JP      NZ, _send_loop
0499+  F6EC             
0500+  F6EC F1                              POP     AF
0501+  F6ED C1                              POP     BC
0502+  F6EE C1                              POP     BC
0503+  F6EF             
0504+  F6EF 3E 07                           LD      A, YMODEM_SEND_TIMEOUT
0505+  F6F1 A7                              AND     A
0506+  F6F2 C9                              RET
0507+  F6F3             
0508+  F6F3 F1          _send_ready         POP     AF
0509+  F6F4 C1                              POP     BC
0510+  F6F5 D3 20                           OUT     (UART_TX_RX), A
0511+  F6F7 C9                              RET
0512+  F6F8             
0513+  F6F8                                 .MODULE main0794   F6F8                                 .INCLUDE flash.asm
0001+  F6F8             ;
0002+  F6F8             ; Flash update routines
0003+  F6F8             ;
0004+  F6F8             ; Note that any memory write operations *at all* during flash updates will cancel the current operation.
0005+  F6F8             ; That means no data can be stored to memory, no stack operations (call, push), no interrupts.
0006+  F6F8             ; 
0007+  F6F8             ;
0008+  F6F8                                 .MODULE     flash
0009+  F6F8             
0010+  F6F8             _cmd_1_addr         .EQU  05555h
0011+  F6F8             _cmd_2_addr         .EQU  02AAAh
0012+  F6F8             
0013+  F6F8             _bank_mask          .EQU  03FFFh                ; One memory bank is 14 bits -> 16Kb
0014+  F6F8             _sector_mask        .EQU  00FFFh                ; A sector is 12 bits -> 4Kb
0015+  F6F8             
0016+  F6F8             _cmd_1_addr_bank    .EQU  _cmd_1_addr >> 14
0017+  F6F8             _cmd_2_addr_bank    .EQU  _cmd_2_addr >> 14
0018+  F6F8             _cmd_3_addr_bank    .EQU  _cmd_1_addr_bank
0019+  F6F8             _cmd_4_addr_bank    .EQU  _cmd_1_addr_bank
0020+  F6F8             _cmd_5_addr_bank    .EQU  _cmd_2_addr_bank
0021+  F6F8             
0022+  F6F8             _cmd_1_logical_addr .EQU  _cmd_1_addr & _bank_mask
0023+  F6F8             _cmd_2_logical_addr .EQU  _cmd_2_addr & _bank_mask
0024+  F6F8             _cmd_3_logical_addr .EQU  _cmd_1_logical_addr
0025+  F6F8             _cmd_4_logical_addr .EQU  _cmd_1_logical_addr
0026+  F6F8             _cmd_5_logical_addr .EQU  _cmd_2_logical_addr
0027+  F6F8             
0028+  F6F8             _cmd_1_data         .EQU  0AAh
0029+  F6F8             _cmd_2_data         .EQU  055h
0030+  F6F8             _cmd_3_data_write   .EQU  0A0h
0031+  F6F8             _cmd_3_data_erase   .EQU  080h
0032+  F6F8             _cmd_4_data         .EQU  0AAh
0033+  F6F8             _cmd_5_data         .EQU  055h
0034+  F6F8             
0035+  F6F8             _cmd_6_data_erase   .EQU  030h
0036+  F6F8             
0037+  F6F8             ;
0038+  F6F8             ; Enter with A -> 7 bit index of 4K sector to be erased.
0039+  F6F8             ;
0040+  F6F8             ; Preserves BC, DE, HL
0041+  F6F8             ;
0042+  F6F8             ; Note this uses bank 0, and leaves it configured for the page containing the erased sector
0043+  F6F8             ;
0044+  F6F8             ; Typical time to erase sector ~18ms
0045+  F6F8             ;
0046+  F6F8 F3          flash_sector_erase  DI                          ; Disable interrupts
0047+  F6F9 E5                              PUSH    HL
0048+  F6FA C5                              PUSH    BC
0049+  F6FB D5                              PUSH    DE
0050+  F6FC             
0051+  F6FC E6 7F                           AND     07fh
0052+  F6FE 57                              LD      D, A
0053+  F6FF CB 3A                           SRL     D
0054+  F701 CB 3A                           SRL     D                   ; D is now the bank number
0055+  F703             
0056+  F703 CB 27                           SLA     A
0057+  F705 CB 27                           SLA     A
0058+  F707 CB 27                           SLA     A
0059+  F709 CB 27                           SLA     A
0060+  F70B E6 30                           AND     030h
0061+  F70D 5F                              LD      E, A                ; E is the sector within the bank shifted into bits 13 & 12
0062+  F70E             
0063+  F70E 0E 70                           LD      C, IO_MEM_0         ; Use bank 0 to write to
0064+  F710 3E 01                           LD      A, _cmd_1_addr_bank
0065+  F712 ED 79                           OUT     (C), A
0066+  F714 21 55 15                        LD      HL, _cmd_1_logical_addr
0067+  F717 36 AA                           LD      (HL), _cmd_1_data
0068+  F719             
0069+  F719 3E 00                           LD      A, _cmd_2_addr_bank
0070+  F71B ED 79                           OUT     (C), A
0071+  F71D 21 AA 2A                        LD      HL, _cmd_2_logical_addr
0072+  F720 36 55                           LD      (HL), _cmd_2_data
0073+  F722             
0074+  F722 3E 01                           LD      A, _cmd_3_addr_bank
0075+  F724 ED 79                           OUT     (C), A
0076+  F726 21 55 15                        LD      HL, _cmd_3_logical_addr
0077+  F729 36 80                           LD      (HL), _cmd_3_data_erase
0078+  F72B             
0079+  F72B 3E 01                           LD      A, _cmd_4_addr_bank
0080+  F72D ED 79                           OUT     (C), A
0081+  F72F 21 55 15                        LD      HL, _cmd_4_logical_addr
0082+  F732 36 AA                           LD      (HL), _cmd_4_data
0083+  F734             
0084+  F734 3E 00                           LD      A, _cmd_5_addr_bank
0085+  F736 ED 79                           OUT     (C), A
0086+  F738 21 AA 2A                        LD      HL, _cmd_5_logical_addr
0087+  F73B 36 55                           LD      (HL), _cmd_5_data
0088+  F73D             
0089+  F73D ED 51                           OUT     (C), D                  ; Switch to the bank containing our sector
0090+  F73F 63                              LD      H, E                    ; And write the sector bits as an address (bits 0-11 are ignored)
0091+  F740 36 30                           LD      (HL), _cmd_6_data_erase
0092+  F742             
0093+  F742 7E          _wait_erase         LD      A,(HL)
0094+  F743 CB 07                           RLC     A
0095+  F745 30 FB                           JR      NC, _wait_erase
0096+  F747             
0097+  F747 D1                              POP     DE
0098+  F748 C1                              POP     BC
0099+  F749 E1                              POP     HL
0100+  F74A FB                              EI
0101+  F74B C9                              RET
0102+  F74C             
0103+  F74C             ;
0104+  F74C             ; Enter with A -> Byte to write
0105+  F74C             ;            D -> 7 bit index of 4K sector being written
0106+  F74C             ;            HL -> 12 bit address of byte within sector
0107+  F74C             ;
0108+  F74C             ; Preserves D, HL
0109+  F74C             ; Uses A, BC, E
0110+  F74C             ;
0111+  F74C             ; Typical time to erase byte ~14us
0112+  F74C             ;
0113+  F74C F3          flash_write_byte    DI
0114+  F74D 5F                              LD      E, A                ; Preserve our byte
0115+  F74E                                 
0116+  F74E 7C                              LD      A, H                ; Make sure HL is within our sector
0117+  F74F E6 0F                           AND     _sector_mask >> 8
0118+  F751 67                              LD      H, A
0119+  F752             
0120+  F752 7A                              LD      A, D                ; Make sure D is a valid sector index
0121+  F753 E6 7F                           AND     07fh
0122+  F755 57                              LD      D, A
0123+  F756 47                              LD      B, A
0124+  F757             
0125+  F757 7A                              LD      A, D                ; Get the bottom 2 bits of our sector index..
0126+  F758 E6 03                           AND     03h
0127+  F75A CB 27                           SLA     A
0128+  F75C CB 27                           SLA     A
0129+  F75E CB 27                           SLA     A
0130+  F760 CB 27                           SLA     A
0131+  F762 B4                              OR      H
0132+  F763 67                              LD      H, A                ; ..and OR them into H to get a 14 bit address within our bank
0133+  F764             
0134+  F764 CB 3A                           SRL     D
0135+  F766 CB 3A                           SRL     D                   ; D is now our bank number
0136+  F768             
0137+  F768 E5                              PUSH    HL
0138+  F769             
0139+  F769 0E 70                           LD      C, IO_MEM_0         ; Use bank 0 to write to
0140+  F76B 3E 01                           LD      A, _cmd_1_addr_bank
0141+  F76D ED 79                           OUT     (C), A
0142+  F76F 21 55 15                        LD      HL, _cmd_1_logical_addr
0143+  F772 36 AA                           LD      (HL), _cmd_1_data
0144+  F774             
0145+  F774 3E 00                           LD      A, _cmd_2_addr_bank
0146+  F776 ED 79                           OUT     (C), A
0147+  F778 21 AA 2A                        LD      HL, _cmd_2_logical_addr
0148+  F77B 36 55                           LD      (HL), _cmd_2_data
0149+  F77D             
0150+  F77D 3E 01                           LD      A, _cmd_3_addr_bank
0151+  F77F ED 79                           OUT     (C), A
0152+  F781 21 55 15                        LD      HL, _cmd_3_logical_addr
0153+  F784 36 A0                           LD      (HL), _cmd_3_data_write
0154+  F786             
0155+  F786 ED 51                           OUT     (C), D
0156+  F788 E1                              POP     HL
0157+  F789 73                              LD      (HL), E
0158+  F78A             
0159+  F78A 7E          _wait_byte          LD      A, (HL)
0160+  F78B AB                              XOR     E
0161+  F78C CB 07                           RLC     A
0162+  F78E 30 FA                           JR      NC, _wait_byte
0163+  F790             
0164+  F790 7C                              LD      A, H                ; Clear bits 13 & 12 to restore HL to sector address..
0165+  F791 E6 0F                           AND     _sector_mask >> 8
0166+  F793 67                              LD      H, A
0167+  F794                            
0168+  F794 50                              LD      D, B                ; And restore D
0169+  F795 FB                              EI
0170+  F796 C9                              RET
0171+  F797             
0172+  F797             ;
0173+  F797             ; Write a flash data block. This uses Page 0 to write the data, so the source must be above 4000h
0174+  F797             ;
0175+  F797             ;       D -> 7 bit index of 4K sector being written
0176+  F797             ;       HL -> Address of source data
0177+  F797             ;       BC -> bytes to write
0178+  F797             ;
0179+  F797             
0180+  F797 DD E5       flash_write         PUSH    IX
0181+  F799 E5                              PUSH    HL
0182+  F79A DD E1                           POP     IX
0183+  F79C 21 00 00                        LD      HL, 0
0184+  F79F             
0185+  F79F             _erase_sector       ; Lower 12 bits of HL are zero, erase sector before writing bytes
0186+  F79F 7A                              LD      A, D
0187+  F7A0 CD F8 F6                        CALL    flash_sector_erase
0188+  F7A3 DD 7E 00    _write_loop         LD      A, (IX+0)
0189+  F7A6 C5                              PUSH    BC
0190+  F7A7 CD 4C F7                        CALL    flash_write_byte
0191+  F7AA C1                              POP     BC
0192+  F7AB             
0193+  F7AB DD 23                           INC     IX
0194+  F7AD 0B                              DEC     BC
0195+  F7AE 78                              LD      A, B
0196+  F7AF B1                              OR      C
0197+  F7B0 28 0E                           JR      Z, _success
0198+  F7B2             
0199+  F7B2 23                              INC     HL
0200+  F7B3 7D                              LD      A, L
0201+  F7B4 A7                              AND     A
0202+  F7B5 20 EC                           JR      NZ, _write_loop
0203+  F7B7 7C                              LD      A, H
0204+  F7B8 E6 0F                           AND     _sector_mask >> 8
0205+  F7BA 67                              LD      H, A
0206+  F7BB 20 E6                           JR      NZ, _write_loop
0207+  F7BD             
0208+  F7BD 14                              INC     D
0209+  F7BE 18 DF                           JR      _erase_sector
0210+  F7C0             
0211+  F7C0 DD E1       _success            POP     IX
0212+  F7C2 C9                              RET
0213+  F7C3             
0214+  F7C3                                 .MODULE main0795   F7C3             
0796   F7C3                                 .INCLUDE "music\\qchan.asm"
0001+  F7C3             ;QChan beeper music engine by Shiru (shiru@mail_ru) 03'11
0002+  F7C3             ;Four channels of tone with global volumes, per-pattern tempo and decays
0003+  F7C3             ;One channel of interrupting drums, no ROM data required
0004+  F7C3             ;Feel free to do whatever you want with the code, it is PD
0005+  F7C3             
0006+  F7C3             
0007+  F7C3             					.MODULE qchan
0008+  F7C3             
0009+  F7C3             END_MARKER  		.EQU 128
0010+  F7C3             
0011+  F7C3             ;
0012+  F7C3             ; Enter with HL = start of music data
0013+  F7C3             ;            DE = location to store frequency table (must be page aligned)
0014+  F7C3             ;
0015+  F7C3 7A          qchan_play			LD  	A, D
0016+  F7C4 32 6B F8    					LD      (readLoop_tableAddr), A
0017+  F7C7 1E 00       					LD      E, 0
0018+  F7C9 43          					LD      B, E
0019+  F7CA 0E 7C       					LD      C, freqEnd-freqOriginal
0020+  F7CC E5          					PUSH    HL
0021+  F7CD 21 81 F9    					LD      HL, freqOriginal
0022+  F7D0 ED B0       					LDIR
0023+  F7D2 E1          					POP     HL
0024+  F7D3             
0025+  F7D3 DB 24       					IN      A, (AUDIO_PORT)
0026+  F7D5 E6 F7       					AND     ~AUDIO_MASK
0027+  F7D7 32 21 F9    					LD      (sound_low), A
0028+  F7DA 32 DD F8    					LD      (drum_value), A
0029+  F7DD F6 08       					OR      AUDIO_MASK
0030+  F7DF 32 16 F9    					LD      (sound_high), A
0031+  F7E2             
0032+  F7E2 F3          					di
0033+  F7E3 7E          					ld 		a,(hl)
0034+  F7E4 23          					inc 	hl
0035+  F7E5 32 79 F8    					ld 		(readLoop_ch0vol),a
0036+  F7E8 7E          					ld 		a,(hl)
0037+  F7E9 23          					inc 	hl
0038+  F7EA 32 8E F8    					ld 		(readLoop_ch1vol),a
0039+  F7ED 7E          					ld 		a,(hl)
0040+  F7EE 23          					inc 	hl
0041+  F7EF 32 A5 F8    					ld 		(readLoop_ch2vol),a
0042+  F7F2 7E          					ld 		a,(hl)
0043+  F7F3 23          					inc 	hl
0044+  F7F4 32 BC F8    					ld 		(readLoop_ch3vol),a
0045+  F7F7 22 2D F8    					ld 		(readLoop_orderPtr),hl
0046+  F7FA 21 00 00    					ld 		hl,0
0047+  F7FD 22 EE F8    					ld 		(readLoop_frq0),hl
0048+  F800 22 8B F8    					ld 		(readLoop_frq1),hl
0049+  F803 22 A1 F8    					ld 		(readLoop_frq2),hl
0050+  F806 22 B8 F8    					ld 		(readLoop_frq3),hl
0051+  F809 7D          					ld 		a,l
0052+  F80A 32 FA F8    					ld 		(soundLoop_vol0),a
0053+  F80D 32 FF F8    					ld 		(soundLoop_vol1),a
0054+  F810 32 07 F9    					ld 		(soundLoop_vol2),a
0055+  F813 32 0F F9    					ld 		(soundLoop_vol3),a
0056+  F816 32 2E F9    					ld 		(soundLoop_frameCnt),a
0057+  F819             
0058+  F819 D9          					exx
0059+  F81A E5          					push hl
0060+  F81B FD E5       					push iy
0061+  F81D ED 73 79 F9 					ld (stopPlayer_oldSP),sp
0062+  F821             
0063+  F821 18 09       					jr readLoop_nextPosition
0064+  F823             
0065+  F823             ;=================================================================
0066+  F823             readLoop
0067+  F823             readLoop_musicPtr    .EQU    $+1
0068+  F823 11 00 00    					ld de,0
0069+  F826             readLoop_readRow
0070+  F826 1A          					ld a,(de)
0071+  F827 FE 80       					cp  END_MARKER
0072+  F829 C2 6A F8    					jp nz,_readNotes
0073+  F82C             readLoop_nextPosition
0074+  F82C             readLoop_orderPtr   .EQU    $+1
0075+  F82C 21 00 00    					ld hl,0
0076+  F82F 5E          					ld e,(hl)
0077+  F830 23          					inc hl
0078+  F831 56          					ld d,(hl)
0079+  F832 23          					inc hl
0080+  F833 7A          					ld a,d
0081+  F834 B3          					or e
0082+  F835 28 29       					jr z,_orderLoop
0083+  F837 22 2D F8    					ld (readLoop_orderPtr),hl
0084+  F83A 1A          					ld a,(de)
0085+  F83B CB 27       					SLA  A 							; Should slow down the frame rate
0086+  F83D 32 66 F9    					ld (soundLoop_frameMax),a
0087+  F840 13          					inc de
0088+  F841 1A          					ld a,(de)
0089+  F842 CB 3F       					SRL  A 							; Halve the decay rate
0090+  F844 32 31 F9    					ld (soundLoop_ch0decay),a
0091+  F847 13          					inc de
0092+  F848 1A          					ld a,(de)
0093+  F849 CB 3F       					SRL  A 							; Halve the decay rate
0094+  F84B 32 3D F9    					ld (soundLoop_ch1decay),a
0095+  F84E 13          					inc de
0096+  F84F 1A          					ld a,(de)
0097+  F850 CB 3F       					SRL  A 							; Halve the decay rate
0098+  F852 32 49 F9    					ld (soundLoop_ch2decay),a
0099+  F855 13          					inc de
0100+  F856 1A          					ld a,(de)
0101+  F857 CB 3F       					SRL  A 							; Halve the decay rate
0102+  F859 32 55 F9    					ld (soundLoop_ch3decay),a
0103+  F85C 13          					inc de
0104+  F85D C3 26 F8    					jp readLoop_readRow
0105+  F860             _orderLoop
0106+  F860 5E          					ld e,(hl)
0107+  F861 23          					inc hl
0108+  F862 56          					ld d,(hl)
0109+  F863 ED 53 2D F8 					ld (readLoop_orderPtr),de
0110+  F867 C3 2C F8    					jp readLoop_nextPosition
0111+  F86A             _readNotes
0112+  F86A             readLoop_tableAddr   .EQU    $+1
0113+  F86A 26 00       					ld h, 0 					;freqTable/256
0114+  F86C 13          					inc de
0115+  F86D B7          					or a
0116+  F86E 28 0D       					jr z,_noNote0
0117+  F870 6F          					ld l,a
0118+  F871 4E          					ld c,(hl)
0119+  F872 2C          					inc l
0120+  F873 46          					ld b,(hl)
0121+  F874 ED 43 EE F8 					ld (readLoop_frq0),bc
0122+  F878             readLoop_ch0vol   .EQU    $+1
0123+  F878 3E 10       					ld a,16
0124+  F87A 32 FA F8    					ld (soundLoop_vol0),a
0125+  F87D             _noNote0
0126+  F87D 1A          					ld a,(de)
0127+  F87E 13          					inc de
0128+  F87F B7          					or a
0129+  F880 28 10       					jr z,_noNote1
0130+  F882 6F          					ld l,a
0131+  F883 4E          					ld c,(hl)
0132+  F884 2C          					inc l
0133+  F885 46          					ld b,(hl)
0134+  F886 ED 43 8B F8 					ld (readLoop_frq1),bc
0135+  F88A             readLoop_frq1   	.EQU    $+1
0136+  F88A 31 00 00    					ld sp,0
0137+  F88D             readLoop_ch1vol   	.EQU    $+1
0138+  F88D 3E 10       					ld a,16
0139+  F88F 32 FF F8    					ld (soundLoop_vol1),a
0140+  F892             _noNote1
0141+  F892 1A          					ld a,(de)
0142+  F893 13          					inc de
0143+  F894 B7          					or a
0144+  F895 28 12       					jr z,_noNote2
0145+  F897 6F          					ld l,a
0146+  F898 4E          					ld c,(hl)
0147+  F899 2C          					inc l
0148+  F89A 46          					ld b,(hl)
0149+  F89B ED 43 A1 F8 					ld (readLoop_frq2),bc
0150+  F89F D9          					exx
0151+  F8A0             readLoop_frq2   	.EQU    $+1
0152+  F8A0 11 00 00    					ld de,0
0153+  F8A3 D9          					exx
0154+  F8A4             readLoop_ch2vol   	.EQU    $+1
0155+  F8A4 3E 10       					ld a,16
0156+  F8A6 32 07 F9    					ld (soundLoop_vol2),a
0157+  F8A9             _noNote2
0158+  F8A9 1A          					ld a,(de)
0159+  F8AA 13          					inc de
0160+  F8AB B7          					or a
0161+  F8AC 28 12       					jr z,_noNote3
0162+  F8AE 6F          					ld l,a
0163+  F8AF 4E          					ld c,(hl)
0164+  F8B0 2C          					inc l
0165+  F8B1 46          					ld b,(hl)
0166+  F8B2 ED 43 B8 F8 					ld (readLoop_frq3),bc
0167+  F8B6 D9          					exx
0168+  F8B7             readLoop_frq3   	.EQU    $+1
0169+  F8B7 01 00 00    					ld bc,0
0170+  F8BA D9          					exx
0171+  F8BB             readLoop_ch3vol   	.EQU    $+1
0172+  F8BB 3E 10       					ld a,16
0173+  F8BD 32 0F F9    					ld (soundLoop_vol3),a
0174+  F8C0             _noNote3
0175+  F8C0 ED 53 24 F8 					ld (readLoop_musicPtr),de
0176+  F8C4 1A          					ld a,(de)
0177+  F8C5 FE 81       					cp 129
0178+  F8C7 38 23       					jr c,_noDrum
0179+  F8C9 13          					inc de
0180+  F8CA ED 53 24 F8 					ld (readLoop_musicPtr),de
0181+  F8CE             
0182+  F8CE 06 80       					ld b,128
0183+  F8D0 90          					sub b
0184+  F8D1 87          					add a,a
0185+  F8D2 4F          					ld c,a
0186+  F8D3 5F          					ld e,a
0187+  F8D4 6F          					ld l,a
0188+  F8D5 67          					ld h,a
0189+  F8D6             _drum1
0190+  F8D6 0D          					dec c
0191+  F8D7 20 07       					jr nz,_drum2
0192+  F8D9 4B          					ld c,e
0193+  F8DA E6 10       					and 16
0194+  F8DC             drum_value          .EQU $+1
0195+  F8DC F6 00       					OR      0
0196+  F8DE D3 11       					OUT     (PIO_B_DATA), A
0197+  F8E0             _drum2
0198+  F8E0 7D          					ld a,l
0199+  F8E1 C6 0B       					add a,11
0200+  F8E3 AC          					xor h
0201+  F8E4 6F          					ld l,a
0202+  F8E5 7C          					ld a,h
0203+  F8E6 C6 0C       					add a,12
0204+  F8E8 AD          					xor l
0205+  F8E9 67          					ld h,a
0206+  F8EA 10 EA       					djnz _drum1
0207+  F8EC             
0208+  F8EC             _noDrum
0209+  F8EC AF          					xor a
0210+  F8ED             
0211+  F8ED             readLoop_frq0   	.EQU    $+1
0212+  F8ED 11 00 00    					ld de,0
0213+  F8F0             
0214+  F8F0             ;=================================================================
0215+  F8F0             soundLoopRepeat
0216+  F8F0 08          					EX 	AF, AF'
0217+  F8F1             
0218+  F8F1             soundLoopRepeat_prevCnt1   .EQU    $+1
0219+  F8F1 21 00 00    					ld hl,0
0220+  F8F4 0E 40       					ld c,64						; Was 64??
0221+  F8F6             
0222+  F8F6             ;=================================================================
0223+  F8F6             soundLoop
0224+  F8F6 DD 19       					add ix,de		;15
0225+  F8F8 9F          					sbc a,a			;4
0226+  F8F9             soundLoop_vol0   	.EQU    $+1
0227+  F8F9 E6 00       					and 0			;7
0228+  F8FB 47          					ld b,a			;4
0229+  F8FC 39          					add hl,sp		;11
0230+  F8FD 9F          					sbc a,a			;4
0231+  F8FE             soundLoop_vol1   	.EQU    $+1
0232+  F8FE E6 00       					and 0			;7
0233+  F900 B0          					or b			;4
0234+  F901 47          					ld b,a			;4
0235+  F902 D9          					exx				;4
0236+  F903 FD 19       					add iy,de		;15
0237+  F905 9F          					sbc a,a			;4
0238+  F906             soundLoop_vol2   	.EQU    $+1
0239+  F906 E6 00       					and 0			;7
0240+  F908 D9          					exx				;4
0241+  F909 B0          					or b			;4
0242+  F90A 47          					ld b,a			;4
0243+  F90B D9          					exx				;4
0244+  F90C 09          					add hl,bc		;11
0245+  F90D 9F          					sbc a,a			;4
0246+  F90E             soundLoop_vol3   	.EQU    $+1
0247+  F90E E6 00       					and 0			;7
0248+  F910 D9          					exx				;4
0249+  F911 B0          					or b			;4
0250+  F912 28 09       					jr z,_noOut		;7/12
0251+  F914 47          					ld b,a			;4
0252+  F915             sound_high  		.EQU   $+1					
0253+  F915 3E 08       					ld a,AUDIO_MASK	;7
0254+  F917 D3 24       					OUT     (AUDIO_PORT), A		;11
0255+  F919 78          					ld a,b			;4
0256+  F91A 10 FE       					djnz $			;~
0257+  F91C 2F          					cpl				;4
0258+  F91D             _noOut
0259+  F91D C6 11       					add a,17		;7
0260+  F91F 47          					ld b,a			;4
0261+  F920             sound_low           .EQU  	$+1
0262+  F920 3E 00       					LD  A,0 		; 7 (was 4)
0263+  F922             					;xor a			;4
0264+  F922 D3 24       					OUT     (AUDIO_PORT), A		;11
0265+  F924 10 FE       					djnz $			;~
0266+  F926 0D          					dec c			;4
0267+  F927 C2 F6 F8    					jp nz,soundLoop	;10=~404t
0268+  F92A             
0269+  F92A 22 F2 F8    					ld (soundLoopRepeat_prevCnt1),hl
0270+  F92D             
0271+  F92D             soundLoop_frameCnt   .EQU    $+1
0272+  F92D 3E 00       					ld a,0
0273+  F92F 4F          					ld c,a
0274+  F930             soundLoop_ch0decay   .EQU    $+1
0275+  F930 E6 00       					and 0
0276+  F932 20 07       					jr nz,_ch0dskip
0277+  F934 21 FA F8    					ld hl,soundLoop_vol0
0278+  F937 B6          					or (hl)
0279+  F938 28 01       					jr z,$+3
0280+  F93A 35          					dec (hl)
0281+  F93B             _ch0dskip
0282+  F93B 79          					ld a,c
0283+  F93C             soundLoop_ch1decay   .EQU    $+1
0284+  F93C E6 00       					and 0
0285+  F93E 20 07       					jr nz,_ch1dskip
0286+  F940 21 FF F8    					ld hl,soundLoop_vol1
0287+  F943 B6          					or (hl)
0288+  F944 28 01       					jr z,$+3
0289+  F946 35          					dec (hl)
0290+  F947             _ch1dskip
0291+  F947 79          					ld a,c
0292+  F948             soundLoop_ch2decay   .EQU    $+1
0293+  F948 E6 00       					and 0
0294+  F94A 20 07       					jr nz,_ch2dskip
0295+  F94C 21 07 F9    					ld hl,soundLoop_vol2
0296+  F94F B6          					or (hl)
0297+  F950 28 01       					jr z,$+3
0298+  F952 35          					dec (hl)
0299+  F953             _ch2dskip
0300+  F953 79          					ld a,c
0301+  F954             soundLoop_ch3decay   .EQU    $+1
0302+  F954 E6 00       					and 0
0303+  F956 20 07       					jr nz,_ch3dskip
0304+  F958 21 0F F9    					ld hl,soundLoop_vol3
0305+  F95B B6          					or (hl)
0306+  F95C 28 01       					jr z,$+3
0307+  F95E 35          					dec (hl)
0308+  F95F             _ch3dskip
0309+  F95F 21 2E F9    					ld hl,soundLoop_frameCnt
0310+  F962 34          					inc (hl)
0311+  F963             
0312+  F963 08          					EX  	AF, AF'
0313+  F964 3C          					inc a
0314+  F965             soundLoop_frameMax   .EQU    $+1
0315+  F965 FE 14       					cp 20
0316+  F967 DA F0 F8    					jp c,soundLoopRepeat
0317+  F96A             
0318+  F96A 01 00 00    					LD   	BC, 00h
0319+  F96D ED 78       					IN      A, (C)
0320+  F96F E6 3F       					AND     3fh
0321+  F971 FE 3F                           CP      3fh
0322+  F973             
0323+  F973 20 03       					jr nz,_stopPlayer
0324+  F975 C3 23 F8    					jp readLoop
0325+  F978             
0326+  F978             _stopPlayer
0327+  F978             stopPlayer_oldSP   .EQU    $+1
0328+  F978 31 00 00    					ld sp,0
0329+  F97B FD E1       					pop iy
0330+  F97D E1          					pop hl
0331+  F97E D9          					exx
0332+  F97F FB          					ei
0333+  F980 C9          					ret
0334+  F981             
0335+  F981             
0336+  F981             					; align 256
0337+  F981             ;freqTable			.EQU   0EF00h
0338+  F981             
0339+  F981             freqOriginal
0340+  F981             					; For 8Mhz CPU - 128 bytes(?)
0341+  F981 00 00       			        .DW		0
0342+  F983 6C 00 72 00 			        .DW		108,114,121,128,136,144,153,162,171,182,192,204
0342+  F987 79 00 80 00 
0342+  F98B 88 00 90 00 
0342+  F98F 99 00 A2 00 
0342+  F993 AB 00 B6 00 
0342+  F997 C0 00 CC 00 
0343+  F99B D8 00 E5 00 			        .DW		216,229,242,257,272,288,306,324,343,364,385,408
0343+  F99F F2 00 01 01 
0343+  F9A3 10 01 20 01 
0343+  F9A7 32 01 44 01 
0343+  F9AB 57 01 6C 01 
0343+  F9AF 81 01 98 01 
0344+  F9B3 B0 01 CA 01 			        .DW		432,458,485,514,545,577,612,648,687,728,771,817
0344+  F9B7 E5 01 02 02 
0344+  F9BB 21 02 41 02 
0344+  F9BF 64 02 88 02 
0344+  F9C3 AF 02 D8 02 
0344+  F9C7 03 03 31 03 
0345+  F9CB 61 03 95 03 			        .DW		865,917,971,1029,1090,1155,1224,1297,1374,1456,1542,1634
0345+  F9CF CB 03 05 04 
0345+  F9D3 42 04 83 04 
0345+  F9D7 C8 04 11 05 
0345+  F9DB 5E 05 B0 05 
0345+  F9DF 06 06 62 06 
0346+  F9E3 C3 06 2A 07 			        .DW		1731,1834,1943,2059,2181,2311,2449,2594,2748,2912,3085,3269
0346+  F9E7 97 07 0B 08 
0346+  F9EB 85 08 07 09 
0346+  F9EF 91 09 22 0A 
0346+  F9F3 BC 0A 60 0B 
0346+  F9F7 0D 0C C5 0C 
0347+  F9FB 00 00       			        .DW		0
0348+  F9FD             freqEnd
0349+  F9FD             
0350+  F9FD             ; Original table - for 3_5Mhz CPU
0351+  F9FD             ;	dw 0
0352+  F9FD             ;	dw 247,262,277,294,311,330,349,370,392,416,440,467
0353+  F9FD             ;	dw 494,524,555,588,623,660,699,741,785,832,881,934
0354+  F9FD             ;	dw 989,1048,1110,1176,1246,1320,1399,1482,1570,1664,1763,1868
0355+  F9FD             ;	dw 1979,2096,2221,2353,2493,2641,2798,2965,3141,3328,3526,3736
0356+  F9FD             ;	dw 3958,4193,4442,4707,4987,5283,5597,5930,6283,6656,7052,7472
0357+  F9FD             ;	dw 0
0358+  F9FD             
0359+  F9FD             					.MODULE main0797   F9FD                                 .INCLUDE "music\\testing.asm"
0001+  F9FD             						.MODULE music
0002+  F9FD 0F 0C 08 0C music_data				.DB 00fh, 00ch, 008h, 00ch
0003+  FA01 9F FA       						.DW _p01
0004+  FA03             _loop
0005+  FA03 0D FA       						.DW _p00
0006+  FA05 0D FA       						.DW _p00
0007+  FA07 F3 FA       						.DW _p02
0008+  FA09 00 00       						.DW 0
0009+  FA0B 03 FA       						.DW _loop
0010+  FA0D             _p00
0011+  FA0D 11 03 01 0F 						.DB 011h, 003h, 001h, 00fh, 00fh    ; Speed, decay0,1,2,3
0011+  FA11 0F 
0012+  FA12 32 00 00 7A 						.DB 032h, 000h, 000h, 07ah, 081h
0012+  FA16 81 
0013+  FA17 00 00 00 00 						.DB 000h, 000h, 000h, 000h
0014+  FA1B 52 4A 00 00 						.DB 052h, 04ah, 000h, 000h
0015+  FA1F 52 4A 00 00 						.DB 052h, 04ah, 000h, 000h
0016+  FA23 40 00 7A 62 						.DB 040h, 000h, 07ah, 062h, 082h
0016+  FA27 82 
0017+  FA28 52 4A 00 00 						.DB 052h, 04ah, 000h, 000h
0018+  FA2C 52 4A 00 00 						.DB 052h, 04ah, 000h, 000h
0019+  FA30 52 4A 00 66 						.DB 052h, 04ah, 000h, 066h
0020+  FA34 32 00 62 00 						.DB 032h, 000h, 062h, 000h, 081h
0020+  FA38 81 
0021+  FA39 00 00 00 7A 						.DB 000h, 000h, 000h, 07ah
0022+  FA3D 52 4A 00 66 						.DB 052h, 04ah, 000h, 066h, 081h
0022+  FA41 81 
0023+  FA42 52 4A 66 62 						.DB 052h, 04ah, 066h, 062h
0024+  FA46 40 00 00 00 						.DB 040h, 000h, 000h, 000h, 082h
0024+  FA4A 82 
0025+  FA4B 52 4A 7A 00 						.DB 052h, 04ah, 07ah, 000h
0026+  FA4F 3C 4A 66 60 						.DB 03ch, 04ah, 066h, 060h
0027+  FA53 52 4A 62 00 						.DB 052h, 04ah, 062h, 000h
0028+  FA57 32 00 00 7A 						.DB 032h, 000h, 000h, 07ah, 081h
0028+  FA5B 81 
0029+  FA5C 00 00 00 00 						.DB 000h, 000h, 000h, 000h
0030+  FA60 52 4A 60 00 						.DB 052h, 04ah, 060h, 000h, 081h
0030+  FA64 81 
0031+  FA65 52 4A 00 00 						.DB 052h, 04ah, 000h, 000h
0032+  FA69 40 00 7A 62 						.DB 040h, 000h, 07ah, 062h, 082h
0032+  FA6D 82 
0033+  FA6E 52 4A 00 00 						.DB 052h, 04ah, 000h, 000h
0034+  FA72 52 4A 00 00 						.DB 052h, 04ah, 000h, 000h
0035+  FA76 52 4A 00 66 						.DB 052h, 04ah, 000h, 066h, 082h
0035+  FA7A 82 
0036+  FA7B 32 00 62 00 						.DB 032h, 000h, 062h, 000h, 081h
0036+  FA7F 81 
0037+  FA80 00 00 00 7A 						.DB 000h, 000h, 000h, 07ah
0038+  FA84 40 4A 00 66 						.DB 040h, 04ah, 000h, 066h, 081h
0038+  FA88 81 
0039+  FA89 52 4A 66 6A 						.DB 052h, 04ah, 066h, 06ah
0040+  FA8D 3C 00 00 00 						.DB 03ch, 000h, 000h, 000h, 082h
0040+  FA91 82 
0041+  FA92 52 4A 7A 00 						.DB 052h, 04ah, 07ah, 000h
0042+  FA96 3A 4A 66 6C 						.DB 03ah, 04ah, 066h, 06ch
0043+  FA9A 52 4A 6A 00 						.DB 052h, 04ah, 06ah, 000h
0044+  FA9E 80          						.DB 080h
0045+  FA9F             _p01
0046+  FA9F 11 01 01 01 						.DB 011h, 001h, 001h, 001h, 001h    ; Speed, decay0,1,2,3
0046+  FAA3 01 
0047+  FAA4 62 00 00 00 						.DB 062h, 000h, 000h, 000h, 081h
0047+  FAA8 81 
0048+  FAA9 4A 00 00 00 						.DB 04ah, 000h, 000h, 000h, 082h
0048+  FAAD 82 
0049+  FAAE 62 00 00 00 						.DB 062h, 000h, 000h, 000h, 081h
0049+  FAB2 81 
0050+  FAB3 4A 00 00 00 						.DB 04ah, 000h, 000h, 000h, 082h
0050+  FAB7 82 
0051+  FAB8 58 62 00 00 						.DB 058h, 062h, 000h, 000h, 083h
0051+  FABC 83 
0052+  FABD 40 4A 00 00 						.DB 040h, 04ah, 000h, 000h, 084h
0052+  FAC1 84 
0053+  FAC2 58 62 00 00 						.DB 058h, 062h, 000h, 000h, 083h
0053+  FAC6 83 
0054+  FAC7 40 4A 00 00 						.DB 040h, 04ah, 000h, 000h, 084h
0054+  FACB 84 
0055+  FACC 4A 58 00 00 						.DB 04ah, 058h, 000h, 000h, 085h
0055+  FAD0 85 
0056+  FAD1 32 40 00 00 						.DB 032h, 040h, 000h, 000h, 086h
0056+  FAD5 86 
0057+  FAD6 4A 58 00 00 						.DB 04ah, 058h, 000h, 000h, 085h
0057+  FADA 85 
0058+  FADB 32 40 00 00 						.DB 032h, 040h, 000h, 000h, 086h
0058+  FADF 86 
0059+  FAE0 40 4A 00 00 						.DB 040h, 04ah, 000h, 000h, 087h
0059+  FAE4 87 
0060+  FAE5 00 32 00 00 						.DB 000h, 032h, 000h, 000h
0061+  FAE9 00 4A 00 00 						.DB 000h, 04ah, 000h, 000h, 087h
0061+  FAED 87 
0062+  FAEE 00 32 00 00 						.DB 000h, 032h, 000h, 000h
0063+  FAF2 80          						.DB 080h
0064+  FAF3             _p02
0065+  FAF3 11 03 01 0F 						.DB 011h, 003h, 001h, 00fh, 00fh    ; Speed, decay0,1,2,3
0065+  FAF7 0F 
0066+  FAF8 28 00 00 7A 						.DB 028h, 000h, 000h, 07ah, 081h
0066+  FAFC 81 
0067+  FAFD 00 00 00 00 						.DB 000h, 000h, 000h, 000h
0068+  FB01 48 40 00 00 						.DB 048h, 040h, 000h, 000h
0069+  FB05 48 40 00 00 						.DB 048h, 040h, 000h, 000h
0070+  FB09 36 00 7A 62 						.DB 036h, 000h, 07ah, 062h, 082h
0070+  FB0D 82 
0071+  FB0E 48 40 00 00 						.DB 048h, 040h, 000h, 000h
0072+  FB12 48 40 00 00 						.DB 048h, 040h, 000h, 000h
0073+  FB16 48 40 00 66 						.DB 048h, 040h, 000h, 066h
0074+  FB1A 28 00 62 00 						.DB 028h, 000h, 062h, 000h, 081h
0074+  FB1E 81 
0075+  FB1F 00 00 00 7A 						.DB 000h, 000h, 000h, 07ah
0076+  FB23 48 40 00 66 						.DB 048h, 040h, 000h, 066h, 081h
0076+  FB27 81 
0077+  FB28 48 40 66 62 						.DB 048h, 040h, 066h, 062h
0078+  FB2C 36 00 00 00 						.DB 036h, 000h, 000h, 000h, 082h
0078+  FB30 82 
0079+  FB31 48 40 7A 00 						.DB 048h, 040h, 07ah, 000h
0080+  FB35 32 40 66 60 						.DB 032h, 040h, 066h, 060h
0081+  FB39 48 40 62 00 						.DB 048h, 040h, 062h, 000h
0082+  FB3D 28 00 00 7A 						.DB 028h, 000h, 000h, 07ah, 081h
0082+  FB41 81 
0083+  FB42 00 00 00 00 						.DB 000h, 000h, 000h, 000h
0084+  FB46 48 40 60 00 						.DB 048h, 040h, 060h, 000h, 081h
0084+  FB4A 81 
0085+  FB4B 48 40 00 00 						.DB 048h, 040h, 000h, 000h
0086+  FB4F 36 00 7A 62 						.DB 036h, 000h, 07ah, 062h, 082h
0086+  FB53 82 
0087+  FB54 48 40 00 00 						.DB 048h, 040h, 000h, 000h
0088+  FB58 48 40 00 00 						.DB 048h, 040h, 000h, 000h
0089+  FB5C 48 40 00 66 						.DB 048h, 040h, 000h, 066h, 082h
0089+  FB60 82 
0090+  FB61 28 00 62 00 						.DB 028h, 000h, 062h, 000h, 081h
0090+  FB65 81 
0091+  FB66 00 00 00 7A 						.DB 000h, 000h, 000h, 07ah
0092+  FB6A 36 40 00 66 						.DB 036h, 040h, 000h, 066h, 081h
0092+  FB6E 81 
0093+  FB6F 48 40 66 6A 						.DB 048h, 040h, 066h, 06ah
0094+  FB73 32 00 00 00 						.DB 032h, 000h, 000h, 000h, 082h
0094+  FB77 82 
0095+  FB78 48 40 7A 00 						.DB 048h, 040h, 07ah, 000h
0096+  FB7C 30 40 66 6C 						.DB 030h, 040h, 066h, 06ch
0097+  FB80 48 40 6A 00 						.DB 048h, 040h, 06ah, 000h
0098+  FB84 2C 00 00 7A 						.DB 02ch, 000h, 000h, 07ah, 081h
0098+  FB88 81 
0099+  FB89 00 00 00 00 						.DB 000h, 000h, 000h, 000h
0100+  FB8D 4A 44 6C 00 						.DB 04ah, 044h, 06ch, 000h
0101+  FB91 4A 44 00 00 						.DB 04ah, 044h, 000h, 000h
0102+  FB95 3A 00 7A 62 						.DB 03ah, 000h, 07ah, 062h, 082h
0102+  FB99 82 
0103+  FB9A 4A 44 00 00 						.DB 04ah, 044h, 000h, 000h
0104+  FB9E 4A 44 00 00 						.DB 04ah, 044h, 000h, 000h
0105+  FBA2 4A 44 00 66 						.DB 04ah, 044h, 000h, 066h
0106+  FBA6 2C 00 62 00 						.DB 02ch, 000h, 062h, 000h, 081h
0106+  FBAA 81 
0107+  FBAB 00 00 00 7A 						.DB 000h, 000h, 000h, 07ah
0108+  FBAF 4A 44 00 66 						.DB 04ah, 044h, 000h, 066h, 081h
0108+  FBB3 81 
0109+  FBB4 4A 44 66 62 						.DB 04ah, 044h, 066h, 062h
0110+  FBB8 3A 00 00 00 						.DB 03ah, 000h, 000h, 000h, 082h
0110+  FBBC 82 
0111+  FBBD 4A 44 7A 00 						.DB 04ah, 044h, 07ah, 000h
0112+  FBC1 36 44 66 60 						.DB 036h, 044h, 066h, 060h
0113+  FBC5 4A 44 62 00 						.DB 04ah, 044h, 062h, 000h
0114+  FBC9 2C 00 00 7A 						.DB 02ch, 000h, 000h, 07ah, 081h
0114+  FBCD 81 
0115+  FBCE 00 00 00 00 						.DB 000h, 000h, 000h, 000h
0116+  FBD2 4A 44 60 00 						.DB 04ah, 044h, 060h, 000h, 081h
0116+  FBD6 81 
0117+  FBD7 4A 44 00 00 						.DB 04ah, 044h, 000h, 000h
0118+  FBDB 3A 00 7A 62 						.DB 03ah, 000h, 07ah, 062h, 082h
0118+  FBDF 82 
0119+  FBE0 4A 44 00 00 						.DB 04ah, 044h, 000h, 000h
0120+  FBE4 4A 44 00 00 						.DB 04ah, 044h, 000h, 000h
0121+  FBE8 4A 44 00 66 						.DB 04ah, 044h, 000h, 066h, 082h
0121+  FBEC 82 
0122+  FBED 2C 00 62 00 						.DB 02ch, 000h, 062h, 000h, 081h
0122+  FBF1 81 
0123+  FBF2 00 00 00 7A 						.DB 000h, 000h, 000h, 07ah
0124+  FBF6 4A 44 00 66 						.DB 04ah, 044h, 000h, 066h, 081h
0124+  FBFA 81 
0125+  FBFB 4A 44 66 6A 						.DB 04ah, 044h, 066h, 06ah
0126+  FBFF 00 00 00 00 						.DB 000h, 000h, 000h, 000h, 082h
0126+  FC03 82 
0127+  FC04 00 00 7A 00 						.DB 000h, 000h, 07ah, 000h
0128+  FC08 00 00 66 6C 						.DB 000h, 000h, 066h, 06ch
0129+  FC0C 00 00 6A 00 						.DB 000h, 000h, 06ah, 000h
0130+  FC10 80          						.DB 080h
0798   FC11             
0799   FC11~            .IF $ >= BIOS_TOP
0800   FC11~                .ECHO "End of BIOS is too high ("
0801   FC11~                .ECHO $
0802   FC11~                .ECHO " > "
0803   FC11~                .ECHO BIOS_TOP
0804   FC11~                .ECHO ") \n\n"
0805   FC11~                .STOP
0806   FC11             .ENDIF
0807   FC11             
0808   FC11             .ECHO "Bios Size is "
0809   FC11             .ECHO $-BIOS_START
0810   FC11             .ECHO ". Limit is "
0811   FC11             .ECHO BIOS_TOP-BIOS_START
0812   FC11             .ECHO "\n\n"
0813   FC11             
0814   FC11                                 .ENDtasm: Number of errors = 0
